# Cursor Rules for Rental Shop Next.js Monorepo

## üéØ DRY Principles & Best Practices

### **ALWAYS FOLLOW DRY (Don't Repeat Yourself)**

#### **1. Configuration Management**
- ‚úÖ Use shared base configurations (`tsconfig.base.json`, `tsup.config.base.ts`)
- ‚úÖ Extend base configs in packages, don't duplicate settings
- ‚úÖ Keep package-specific configs minimal (3-5 lines max)
- ‚ùå Never duplicate TypeScript or build configurations

#### **2. Component Development**
- ‚úÖ Create reusable components in `packages/ui/src/components/`
- ‚úÖ Use shared components across all apps (`@rentalshop/ui`)
- ‚úÖ Follow consistent component structure with proper TypeScript types
- ‚ùå Don't create duplicate components in individual apps

#### **3. Utility Functions**
- ‚úÖ Centralize common functions in `packages/utils/src/`
- ‚úÖ Use shared utilities everywhere (`@rentalshop/utils`)
- ‚úÖ Create domain-specific utilities in appropriate packages
- ‚ùå Don't duplicate utility functions across packages

#### **4. Type Definitions**
- ‚úÖ Define types once in `packages/database/src/types.ts`
- ‚úÖ Import types from shared packages (`@rentalshop/database`)
- ‚úÖ Use consistent naming conventions (PascalCase for interfaces)
- ‚ùå Don't redefine types in multiple places

### **Component Organization Rules**

#### **üìÅ `/forms` - Pure Form Components**
**When to create here:**
- **Reusable form logic** that can be used across different contexts
- **Form validation and state management**
- **Input field components and form layouts**
- **NO business logic or API calls**

**Examples:**
```typescript
// ‚úÖ GOOD: Pure form components
/forms/ProductForm.tsx        // Form logic + validation
/forms/CustomerForm.tsx       // Form logic + validation  
/forms/OrderForm.tsx          // Form logic + validation
/forms/LoginForm.tsx          // Form logic + validation
```

**Characteristics:**
- Form inputs and validation
- State management for form data
- Form submission handling
- NO API calls
- NO business logic
- Reusable across different business contexts

#### **üìÅ `/features` - Business Logic Components**
**When to create here:**
- **Complete business features** with API integration
- **Components that combine forms + business logic**
- **Reusable business components** (cards, tables, dialogs)
- **Components that make API calls or handle business operations**

**Examples:**
```typescript
// ‚úÖ GOOD: Business logic components
/features/ProductDialog.tsx   // Dialog + API calls + business logic
/features/ProductTable.tsx    // Table + data fetching + actions
/features/ProductCard.tsx     // Card + business operations
/features/CustomerDialog.tsx  // Dialog + API calls + business logic
```

**Characteristics:**
- API calls and data fetching
- Business logic and operations
- Combines multiple components (including forms)
- Handles save/cancel operations
- Specific to business domain

#### **Component Decision Tree**
```
Is it a FORM with validation and inputs?
‚îú‚îÄ YES ‚Üí /forms/
‚îÇ   ‚îú‚îÄ Does it make API calls? ‚Üí NO ‚úÖ
‚îÇ   ‚îú‚îÄ Does it have business logic? ‚Üí NO ‚úÖ
‚îÇ   ‚îî‚îÄ Is it reusable across contexts? ‚Üí YES ‚úÖ
‚îÇ
‚îî‚îÄ NO ‚Üí /features/
    ‚îú‚îÄ Does it make API calls? ‚Üí YES ‚úÖ
    ‚îú‚îÄ Does it handle business operations? ‚Üí YES ‚úÖ
    ‚îú‚îÄ Does it combine multiple components? ‚Üí YES ‚úÖ
    ‚îî‚îÄ Is it a complete business feature? ‚Üí YES ‚úÖ
```

#### **Quick Rules of Thumb**
1. **`/forms`** = "How to collect and validate data"
2. **`/features`** = "What to do with the data + business operations"
3. **`/forms`** = Reusable across different business contexts
4. **`/features`** = Specific to business domain
5. **`/forms`** = No API calls, no business logic
6. **`/features`** = API calls, business logic, data management

### **Database Design Principles & Performance**

#### **Database Schema Design**
```sql
-- ‚úÖ GOOD: Proper indexing for rental shop queries
CREATE INDEX idx_orders_status_outlet ON orders(status, outlet_id);
CREATE INDEX idx_orders_customer_created ON orders(customer_id, created_at DESC);
CREATE INDEX idx_orders_pickup_return ON orders(pickup_plan_at, return_plan_at);
CREATE INDEX idx_orders_search ON orders(order_number, customer_name, customer_phone);
CREATE INDEX idx_order_items_product ON order_items(product_id, order_id);
CREATE INDEX idx_payments_order_status ON payments(order_id, status);
CREATE INDEX idx_products_outlet_available ON products(outlet_id, available DESC);
CREATE INDEX idx_customers_merchant_search ON customers(merchant_id, first_name, last_name, phone);
```

#### **Indexing Strategy**
```typescript
// ‚úÖ GOOD: Index for common query patterns
// Orders by status and outlet (for staff dashboards)
// Orders by customer and date (for customer history)
// Orders by pickup/return dates (for scheduling)
// Products by availability (for inventory management)
// Payments by order and status (for financial tracking)

// ‚ùå BAD: Missing indexes on frequently queried fields
// No index on order_number for lookups
// No index on customer search fields
// No composite indexes for complex queries
```

#### **Query Optimization**
```typescript
// ‚úÖ GOOD: Efficient queries with proper joins
const orders = await prisma.order.findMany({
  where: {
    outletId: outletId,
    status: { in: ['ACTIVE', 'CONFIRMED'] },
    returnPlanAt: { lt: new Date() }
  },
  include: {
    customer: { select: { firstName: true, lastName: true, phone: true } },
    orderItems: { 
      include: { product: { select: { name: true, barcode: true } } }
    }
  },
  orderBy: { createdAt: 'desc' },
  take: 20
});

// ‚ùå BAD: N+1 queries or inefficient includes
const orders = await prisma.order.findMany();
for (const order of orders) {
  const customer = await prisma.customer.findUnique({ where: { id: order.customerId } });
  const items = await prisma.orderItem.findMany({ where: { orderId: order.id } });
}
```

#### **Database Schema Best Practices**
```prisma
// ‚úÖ GOOD: Proper relationships and constraints
model Order {
  id            String   @id @default(cuid())
  orderNumber   String   @unique // Indexed for fast lookups
  orderType     String   // RENT, SALE, RENT_TO_OWN
  status        String   @default("PENDING")
  outletId      String
  customerId    String?
  
  // Timestamps for tracking
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Rental-specific fields
  pickupPlanAt  DateTime?
  returnPlanAt  DateTime?
  pickedUpAt    DateTime?
  returnedAt    DateTime?
  
  // Financial fields
  totalAmount   Float
  depositAmount Float    @default(0)
  
  // Relations
  outlet      Outlet      @relation(fields: [outletId], references: [id])
  customer    Customer?   @relation(fields: [customerId], references: [id])
  orderItems  OrderItem[]
  payments    Payment[]
  
  @@index([status, outletId]) // Composite index for staff queries
  @@index([customerId, createdAt(sort: Desc)]) // Customer history
  @@index([pickupPlanAt, returnPlanAt]) // Scheduling queries
  @@index([orderNumber]) // Fast order lookups
}

// ‚úÖ GOOD: Optimized product model for inventory
model Product {
  id          String   @id @default(cuid())
  outletId    String
  name        String
  barcode     String?  @unique
  stock       Int      @default(0)
  renting     Int      @default(0)
  available   Int      @default(0) // Computed field
  rentPrice   Float
  deposit     Float    @default(0)
  
  outlet      Outlet   @relation(fields: [outletId], references: [id])
  orderItems  OrderItem[]
  
  @@index([outletId, available(sort: Desc)]) // Inventory queries
  @@index([barcode]) // Barcode scanning
  @@index([name]) // Product search
}
```

#### **Performance Optimization Rules**
```typescript
// ‚úÖ GOOD: Pagination for large datasets
export async function searchOrders(filters: OrderSearchFilter) {
  const { limit = 20, offset = 0 } = filters;
  
  const [orders, total] = await Promise.all([
    prisma.order.findMany({
      where: buildWhereClause(filters),
      include: { customer: true, outlet: true },
      orderBy: { createdAt: 'desc' },
      take: limit,
      skip: offset,
    }),
    prisma.order.count({ where: buildWhereClause(filters) })
  ]);
  
  return { orders, total, hasMore: offset + limit < total };
}

// ‚úÖ GOOD: Efficient search with full-text indexing
export async function searchProducts(query: string) {
  return await prisma.product.findMany({
    where: {
      OR: [
        { name: { contains: query, mode: 'insensitive' } },
        { barcode: { equals: query } },
        { description: { contains: query, mode: 'insensitive' } }
      ]
    },
    include: { outlet: true },
    take: 50
  });
}

// ‚ùå BAD: No pagination or inefficient search
export async function getAllOrders() {
  return await prisma.order.findMany({
    include: { customer: true, outlet: true, orderItems: true }
  }); // Could return thousands of records
}
```

#### **Data Integrity & Constraints**
```prisma
// ‚úÖ GOOD: Proper constraints and validation
model OrderItem {
  id          String   @id @default(cuid())
  orderId     String
  productId   String
  quantity    Int      @default(1)
  unitPrice   Float
  totalPrice  Float
  
  order       Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product     Product  @relation(fields: [productId], references: [id])
  
  @@index([orderId, productId]) // Composite index for order items
  @@check(quantity > 0) // Business rule validation
  @@check(unitPrice >= 0) // Price validation
}

model Payment {
  id        String   @id @default(cuid())
  orderId   String
  amount    Float
  method    String
  status    String   @default("PENDING")
  
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  @@index([orderId, status]) // Payment tracking
  @@check(amount > 0) // Amount validation
}
```

### **Configuration Best Practices**

#### **TypeScript Configuration**
```typescript
// ‚úÖ GOOD: Package tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}

// ‚ùå BAD: Duplicating full config
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "esnext",
    // ... 20+ lines of duplicated config
  }
}
```

#### **Build Configuration**
```typescript
// ‚úÖ GOOD: Package tsup.config.ts
import { createBaseConfig } from '../../tsup.config.base';
export default createBaseConfig('src/index.ts', ['external-deps']);

// ‚ùå BAD: Duplicating full config
export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm', 'cjs'],
  dts: true,
  // ... 15+ lines of duplicated config
});
```

### **Code Organization Rules**

#### **Import Patterns & Component Usage**
```typescript
// ‚úÖ GOOD: Centralized imports from @rentalshop/ui
import { 
  Button, 
  Card, 
  Input, 
  Select,
  Textarea,
  Badge,
  formatDate,
  formatCurrency,
  cn 
} from '@rentalshop/ui';

// ‚úÖ GOOD: Import business components
import { OrderCard, OrderForm } from '@rentalshop/ui';
import { CustomerCard, CustomerForm } from '@rentalshop/ui';
import { LoginForm, RegisterForm } from '@rentalshop/ui';

// ‚úÖ GOOD: Use components with proper structure
export default function LoginPage() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Login</CardTitle>
      </CardHeader>
      <CardContent>
        <Input type="email" placeholder="Email" />
        <Button variant="primary">Login</Button>
      </CardContent>
    </Card>
  );
}

// ‚ùå BAD: Use relative imports or create app-specific components
import { Button } from '../components/Button';
import { Card } from '../../shared/card';
import { cn } from '../../lib/utils';

// ‚ùå BAD: Inline components instead of using shared ones
export default function LoginPage() {
  return (
    <div className="card">
      <input type="email" />
      <button className="btn-primary">Login</button>
    </div>
  );
}
```

#### **File Structure**
```
packages/
‚îú‚îÄ‚îÄ ui/src/components/     # ‚úÖ Shared UI components
‚îú‚îÄ‚îÄ auth/src/              # ‚úÖ Authentication logic
‚îú‚îÄ‚îÄ database/src/          # ‚úÖ Database utilities with proper indexing
‚îî‚îÄ‚îÄ utils/src/             # ‚úÖ Common utilities

apps/
‚îú‚îÄ‚îÄ client/app/            # ‚úÖ Client-specific pages
‚îú‚îÄ‚îÄ admin/app/             # ‚úÖ Admin-specific pages
‚îî‚îÄ‚îÄ api/app/api/           # ‚úÖ API endpoints with optimized queries
```

#### **Import Patterns**
```typescript
// ‚úÖ GOOD: Import from shared packages with centralized UI components
import { 
  Button, 
  Card, 
  Input, 
  Select,
  Textarea,
  Badge,
  formatDate,
  formatCurrency,
  cn 
} from '@rentalshop/ui';
import { loginUser } from '@rentalshop/auth';
import { prisma } from '@rentalshop/database';
import { validateInput } from '@rentalshop/utils';

// ‚úÖ GOOD: Import specific components when needed
import { OrderCard, OrderForm } from '@rentalshop/ui';
import { CustomerCard, CustomerForm } from '@rentalshop/ui';

// ‚ùå BAD: Import from individual apps or relative paths
import { Button } from '../../../components/Button';
import { Card } from '../shared/card';
import { cn } from '../../lib/utils';
```

### **Component Development Rules**

#### **Centralized Component Architecture**
```typescript
// ‚úÖ GOOD: All components exported from centralized location
// packages/ui/src/index.tsx
export * from './components'; // Exports everything from components/index.ts

// packages/ui/src/components/index.ts
// ============================================================================
// SHARED COMPONENTS (Core UI Components)
// ============================================================================
export { Button, buttonVariants } from './shared/button';
export { Card, CardHeader, CardTitle, CardContent } from './shared/card';
export { Input } from './shared/input';
export { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './shared/select';
export { Textarea } from './shared/textarea';
export { Badge, badgeVariants } from './shared/badge';

// ============================================================================
// BUSINESS COMPONENTS
// ============================================================================
export { LoginForm, RegisterForm, ForgetPasswordForm } from './auth';
export { CustomerCard, CustomerForm } from './customers';
export { ProductCard, ProductGrid } from './products';
export { OrderCard, OrderForm } from './orders';
```

#### **Component Structure**
```typescript
// ‚úÖ GOOD: Consistent component structure with centralized imports
// packages/ui/src/components/shared/button.tsx
import React from 'react';
import { cn } from '@rentalshop/ui';
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-lg text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-action-primary text-text-inverted hover:bg-brand-primary",
        destructive: "bg-action-danger text-text-inverted hover:bg-red-700",
        outline: "border border-border bg-bg-card text-text-primary hover:bg-bg-secondary",
        secondary: "bg-bg-secondary text-text-primary hover:bg-bg-tertiary",
        ghost: "hover:bg-bg-secondary hover:text-text-primary",
        link: "text-action-primary underline-offset-4 hover:underline",
        success: "bg-action-success text-text-inverted hover:bg-green-700",
        warning: "bg-action-warning text-text-inverted hover:bg-orange-700",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);

Button.displayName = "Button";

export { Button, buttonVariants };
```

#### **Component Usage**
```typescript
// ‚úÖ GOOD: Use centralized UI components
// apps/client/app/login/page.tsx
import { 
  Button, 
  Input, 
  Card, 
  CardHeader, 
  CardTitle, 
  CardContent 
} from '@rentalshop/ui';

export default function LoginPage() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Login</CardTitle>
      </CardHeader>
      <CardContent>
        <Input type="email" placeholder="Email" />
        <Button variant="primary">Login</Button>
      </CardContent>
    </Card>
  );
}

// ‚úÖ GOOD: Import specific business components
import { LoginForm, RegisterForm } from '@rentalshop/ui';

export default function AuthPage() {
  return <LoginForm onSubmit={handleLogin} />;
}

// ‚ùå BAD: Create app-specific components or use relative imports
export default function LoginPage() {
  return (
    <div className="card">
      <input type="email" />
      <button className="btn-primary">Login</button>
    </div>
  );
}

// ‚ùå BAD: Use relative imports
import { Button } from '../components/Button';
import { Card } from '../../shared/card';
```

### **API Development Rules**

#### **API Route Structure**
```typescript
// ‚úÖ GOOD: Consistent API structure with proper indexing
// apps/api/app/api/orders/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { searchOrders } from '@rentalshop/database';
import { validateOrderInput } from '@rentalshop/utils';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const filters = parseSearchParams(searchParams);
    
    // Use indexed queries for performance
    const result = await searchOrders(filters);
    
    return NextResponse.json(result);
  } catch (error) {
    return NextResponse.json(
      { error: error.message },
      { status: 400 }
    );
  }
}
```

#### **Database Operations**
```typescript
// ‚úÖ GOOD: Use shared database client with proper indexing
// packages/orders/src/orders.ts
import { prisma } from '@rentalshop/database';

export const searchOrders = async (filters: OrderFilters) => {
  // Use indexed fields for efficient queries
  const where = {
    outletId: filters.outletId,
    status: filters.status,
    createdAt: {
      gte: filters.startDate,
      lte: filters.endDate
    }
  };
  
  return await prisma.order.findMany({
    where,
    include: { customer: true, outlet: true },
    orderBy: { createdAt: 'desc' },
    take: filters.limit || 20,
    skip: filters.offset || 0
  });
};

// ‚ùå BAD: Create separate database connections
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
```

### **Type Safety Rules**

#### **Type Definitions**
```typescript
// ‚úÖ GOOD: Centralized types with proper indexing considerations
// packages/database/src/types.ts
export interface OrderSearchFilter {
  outletId?: string;
  status?: OrderStatus;
  startDate?: Date;
  endDate?: Date;
  limit?: number;
  offset?: number;
  // Only include fields that are indexed for efficient queries
}

// ‚úÖ GOOD: Index-aware query types
export interface ProductSearchFilter {
  outletId?: string;
  available?: boolean;
  categoryId?: string;
  search?: string; // For indexed name/barcode search
  limit?: number;
  offset?: number;
}

// ‚ùå BAD: Redefine types
interface Order {
  id: string;
  orderNumber: string;
  // ... duplicated definition
}
```

#### **Validation Schemas**
```typescript
// ‚úÖ GOOD: Shared validation with database constraints
// packages/utils/src/validation.ts
import { z } from 'zod';

export const orderSchema = z.object({
  orderType: z.enum(['RENT', 'SALE', 'RENT_TO_OWN']),
  outletId: z.string().min(1),
  customerId: z.string().optional(),
  orderItems: z.array(z.object({
    productId: z.string().min(1),
    quantity: z.number().positive(),
    unitPrice: z.number().nonnegative()
  })).min(1)
});

// ‚úÖ GOOD: Use everywhere
import { orderSchema } from '@rentalshop/utils';

// ‚ùå BAD: Duplicate schemas
const orderSchema = z.object({
  orderType: z.enum(['RENT', 'SALE']),
  // ... duplicated definition
});
```

### **Performance Rules**

#### **Bundle Optimization**
```typescript
// ‚úÖ GOOD: External dependencies
// packages/ui/tsup.config.ts
export default createBaseConfig('src/index.tsx', [
  'react',
  'react-dom',
  'lucide-react'
]);

// ‚úÖ GOOD: Tree shaking
// packages/ui/src/index.tsx
export { Button } from './components/button';
export { Card } from './components/card';
// Only export what's needed

// ‚ùå BAD: Bundle everything
export * from './components';
```

#### **Import Optimization**
```typescript
// ‚úÖ GOOD: Specific imports
import { Button } from '@rentalshop/ui';

// ‚ùå BAD: Import everything
import * as UI from '@rentalshop/ui';
```

### **Error Handling Rules**

#### **Consistent Error Handling**
```typescript
// ‚úÖ GOOD: Shared error class
// packages/utils/src/errors.ts
export class AppError extends Error {
  constructor(
    message: string,
    public statusCode: number = 500,
    public code?: string
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// ‚úÖ GOOD: Use everywhere
import { AppError } from '@rentalshop/utils';
throw new AppError('User not found', 404, 'USER_NOT_FOUND');

// ‚ùå BAD: Inconsistent error handling
throw new Error('User not found');
return { error: 'User not found' };
```

### **Documentation Rules**

#### **Code Documentation**
```typescript
// ‚úÖ GOOD: JSDoc comments with performance notes
/**
 * Search orders with optimized database queries
 * Uses indexed fields: status, outletId, createdAt for performance
 * @param filters - Search filters (only indexed fields)
 * @returns Promise with paginated order results
 * @throws {AppError} When database query fails
 */
export const searchOrders = async (filters: OrderSearchFilter): Promise<OrderSearchResponse> => {
  // Implementation with proper indexing
};

// ‚ùå BAD: No documentation
export const searchOrders = async (filters) => {
  // Implementation
};
```

### **Security Rules**

#### **Input Validation**
```typescript
// ‚úÖ GOOD: Validate all inputs with database constraints
import { orderSchema } from '@rentalshop/utils';

export async function POST(request: NextRequest) {
  const body = await request.json();
  const validatedData = orderSchema.parse(body);
  // ... rest of logic
}

// ‚ùå BAD: No validation
export async function POST(request: NextRequest) {
  const body = await request.json();
  // Use body directly without validation
}
```

#### **Environment Variables**
```bash
# ‚úÖ GOOD: Use consistent naming
DATABASE_URL="postgresql://..."
JWT_SECRET="your-secret"
NEXTAUTH_SECRET="your-secret"

# ‚ùå BAD: Inconsistent naming
DB_URL="postgresql://..."
SECRET_KEY="your-secret"
AUTH_SECRET="your-secret"
```

### **Testing Rules**

#### **Test Structure**
```typescript
// ‚úÖ GOOD: Consistent test structure with database mocking
// packages/utils/src/__tests__/date.test.ts
import { formatDate } from '../date';

describe('formatDate', () => {
  it('should format date correctly', () => {
    const date = new Date('2024-01-01');
    expect(formatDate(date)).toBe('01/01/2024');
  });
});

// ‚ùå BAD: Inconsistent test structure
test('formatDate works', () => {
  // Test without proper structure
});
```

### **Git Workflow Rules**

#### **Commit Messages**
```bash
# ‚úÖ GOOD: Conventional commits
feat(ui): add new product card component
fix(api): resolve authentication bug
docs(readme): update installation instructions

# ‚ùå BAD: Inconsistent commits
added new component
fixed bug
updated docs
```

### **Maintenance Rules**

#### **Dependency Management**
```json
// ‚úÖ GOOD: Use workspace dependencies
{
  "dependencies": {
    "@rentalshop/ui": "workspace:*",
    "@rentalshop/auth": "workspace:*",
    "@rentalshop/database": "workspace:*",
    "@rentalshop/utils": "workspace:*"
  }
}

// ‚ùå BAD: Use version numbers
{
  "dependencies": {
    "@rentalshop/ui": "1.0.0",
    "@rentalshop/auth": "1.0.0"
  }
}
```

### **Code Quality Rules**

#### **Linting and Formatting**
- ‚úÖ Always run `yarn lint` before committing
- ‚úÖ Use Prettier for consistent formatting
- ‚úÖ Follow TypeScript strict mode
- ‚ùå Don't disable linting rules without justification

#### **Type Safety**
- ‚úÖ Use strict TypeScript configuration
- ‚úÖ Define proper types for all functions
- ‚úÖ Use type guards for runtime validation
- ‚ùå Don't use `any` type without justification

### **Database Performance Checklist**

Before submitting any database changes, ensure:

- [ ] **Proper Indexing**: All frequently queried fields are indexed
- [ ] **Composite Indexes**: Multi-field queries have appropriate composite indexes
- [ ] **Query Optimization**: No N+1 queries or inefficient joins
- [ ] **Pagination**: Large datasets use proper pagination
- [ ] **Constraints**: Business rules enforced with database constraints
- [ ] **Relationships**: Proper foreign key relationships with cascade rules
- [ ] **Search Optimization**: Full-text search on appropriate fields
- [ ] **Performance Testing**: Queries tested with realistic data volumes
- [ ] **Monitoring**: Query performance monitored in production
- [ ] **Backup Strategy**: Database backup and recovery procedures in place

### **Review Checklist**

Before submitting any code, ensure:

- [ ] No duplicated configurations
- [ ] Uses centralized `@rentalshop/ui` imports for all UI components
- [ ] No relative imports for UI components
- [ ] Uses shared components and utilities
- [ ] Follows consistent naming conventions
- [ ] Includes proper TypeScript types
- [ ] Has appropriate error handling
- [ ] Includes tests for new functionality
- [ ] Updates documentation if needed
- [ ] Follows security best practices
- [ ] Optimized for performance with proper indexing
- [ ] Follows DRY principles
- [ ] Database queries are optimized and indexed
- [ ] No N+1 query problems
- [ ] Proper pagination for large datasets

### **Remember**

**ALWAYS prioritize:**
1. **DRY (Don't Repeat Yourself)** - Never duplicate code or configurations
2. **Centralized Imports** - Use `@rentalshop/ui` for all UI components and utilities
3. **Shared Resources** - Use packages for reusable code
4. **Consistency** - Follow established patterns
5. **Type Safety** - Use TypeScript effectively
6. **Performance** - Optimize bundles, imports, and database queries
7. **Security** - Validate inputs and handle errors properly
8. **Database Performance** - Proper indexing and query optimization
9. **Scalability** - Design for growth and high data volumes

**NEVER:**
- Duplicate configurations across packages
- Use relative imports for UI components (`import { Button } from '../components/Button'`)
- Create app-specific versions of shared components
- Redefine types that already exist
- Skip input validation
- Use `any` type without justification
- Commit without running linting and tests
- Create unindexed queries on frequently accessed fields
- Use N+1 queries or inefficient database operations
- Skip pagination for potentially large datasets
- Ignore database performance implications