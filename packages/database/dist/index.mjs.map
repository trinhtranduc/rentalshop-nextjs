{"version":3,"sources":["../src/client.ts","../src/user.ts","../src/customer.ts","../src/product.ts","../src/order.ts","../src/payment.ts","../src/outlet.ts","../src/plan.ts","../src/subscription.ts","../src/subscription-activity.ts","../src/merchant.ts","../src/order-number-generator.ts","../src/category.ts","../src/audit-logs.ts","../src/order-items.ts","../src/sessions.ts","../src/audit.ts","../src/registration.ts","../src/index.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\n// Global Prisma client instance for singleton pattern\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\n// Create a singleton Prisma client instance\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n});\n\n// Store the instance globally in development to prevent multiple instances\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma;\n} ","// ============================================================================\n// USER FUNCTIONS\n// ============================================================================\n// This file contains user functions that use integer IDs:\n// - Input: id (number)\n// - Database: queries by id (auto-incrementing integer)\n// - Return: includes id (number)\n\nimport { prisma } from './client';\nimport type { UserCreateInput, UserUpdateInput } from '@rentalshop/types';\nimport { hashPassword } from '@rentalshop/auth';\n\n// ============================================================================\n// USER LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find user by ID\n */\nexport async function findUserById(id: number) {\n  return await prisma.user.findUnique({\n    where: { id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get user by ID\n */\nexport async function getUserById(id: number) {\n  return await prisma.user.findUnique({\n    where: { id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// USER CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new user - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createUser(input: UserCreateInput): Promise<any> {\n  // Generate next user id\n  const lastUser = await prisma.user.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastUser?.id || 0) + 1;\n\n  // Find merchant by id if provided\n  let merchantId: number | undefined;\n  if (input.merchantId) {\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: input.merchantId }\n    });\n    if (!merchant) {\n      throw new Error(`Merchant with id ${input.merchantId} not found`);\n    }\n    merchantId = merchant.id;\n  }\n\n  // Find outlet by id if provided\n  let outletId: number | undefined;\n  if (input.outletId) {\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: input.outletId }\n    });\n    if (!outlet) {\n      throw new Error(`Outlet with id ${input.outletId} not found`);\n    }\n    outletId = outlet.id;\n  }\n\n  // Create user\n  const user = await prisma.user.create({\n    data: {\n      id: nextPublicId,\n      email: input.email,\n      password: input.password,\n      firstName: input.firstName,\n      lastName: input.lastName,\n      phone: input.phone,\n      role: input.role,\n      isActive: true,\n      merchantId,\n      outletId,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return user;\n}\n\n// ============================================================================\n// USER UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update user - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateUser(\n  id: number,\n  input: UserUpdateInput\n): Promise<any> {\n  // Find user by id\n  const existingUser = await prisma.user.findUnique({\n    where: { id }\n  });\n\n  if (!existingUser) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  // Update user - only update fields that are provided\n  const updateData: any = {};\n  if (input.firstName !== undefined) updateData.firstName = input.firstName;\n  if (input.lastName !== undefined) updateData.lastName = input.lastName;\n  if (input.phone !== undefined) updateData.phone = input.phone;\n  // Note: email updates are disabled for security reasons\n\n  const updatedUser = await prisma.user.update({\n    where: { id },\n    data: updateData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n          phone: true,\n          address: true,\n          city: true,\n          state: true,\n          zipCode: true,\n          country: true,\n          businessType: true,\n          taxId: true,\n          website: true,\n          description: true,\n          isActive: true,\n          planId: true,\n          // subscriptionStatus removed - use subscription.status\n          totalRevenue: true,\n          createdAt: true,\n          lastActiveAt: true,\n        }\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          phone: true,\n          description: true,\n          isActive: true,\n          isDefault: true,\n          createdAt: true,\n          merchant: {\n            select: {\n              id: true,\n              name: true,\n            }\n          }\n        }\n      },\n    },\n  });\n\n  return updatedUser;\n}\n\n// ============================================================================\n// USER UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get users by merchant - follows dual ID system\n */\nexport async function getUsersByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.user.findMany({\n    where: { merchantId: merchant.id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get users by outlet - follows dual ID system\n */\nexport async function getUsersByOutlet(outletId: number) {\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  return await prisma.user.findMany({\n    where: { outletId: outlet.id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n// ============================================================================\n// USER SOFT DELETE FUNCTIONS\n// ============================================================================\n\n/**\n * Soft delete user by public ID - follows dual ID system\n * Sets isActive to false and deletedAt to current timestamp\n */\nexport async function softDeleteUser(id: number): Promise<any> {\n  // Find user by id\n  const user = await prisma.user.findUnique({\n    where: { id },\n    select: { id: true, email: true, isActive: true, deletedAt: true }\n  });\n\n  if (!user) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  if (user.deletedAt) {\n    throw new Error(`User with id ${id} is already deleted`);\n  }\n\n  // Soft delete the user\n  const deletedUser = await prisma.user.update({\n    where: { id: user.id },\n    data: {\n      isActive: false,\n      deletedAt: new Date(),\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return deletedUser;\n}\n\n/**\n * Restore soft deleted user by public ID - follows dual ID system\n * Sets isActive to true and clears deletedAt\n */\nexport async function restoreUser(id: number): Promise<any> {\n  // Find user by id\n  const user = await prisma.user.findUnique({\n    where: { id },\n    select: { id: true, email: true, isActive: true, deletedAt: true }\n  });\n\n  if (!user) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  if (!user.deletedAt) {\n    throw new Error(`User with id ${id} is not deleted`);\n  }\n\n  // Restore the user\n  const restoredUser = await prisma.user.update({\n    where: { id: user.id },\n    data: {\n      isActive: true,\n      deletedAt: null,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return restoredUser;\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedUsers = {\n  /**\n   * Find user by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.user.findUnique({\n      where: { id },\n      include: {\n        merchant: { \n          select: { \n            id: true, \n            name: true,\n            email: true,\n            phone: true,\n            address: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            businessType: true,\n            pricingType: true,\n            taxId: true,\n            website: true,\n            description: true,\n            isActive: true,\n            planId: true,\n            // subscriptionStatus removed - use subscription.status\n            totalRevenue: true,\n            createdAt: true,\n            lastActiveAt: true\n          } \n        },\n        outlet: { \n          select: { \n            id: true, \n            name: true,\n            address: true,\n            phone: true,\n            description: true,\n            isActive: true,\n            isDefault: true,\n            createdAt: true,\n            merchant: {\n              select: {\n                id: true,\n                name: true,\n              }\n            }\n          } \n        }\n      }\n    });\n  },\n\n  /**\n   * Find user by email (simplified API)\n   */\n  findByEmail: async (email: string) => {\n    return await prisma.user.findUnique({\n      where: { email },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Find first user matching criteria (simplified API)\n   */\n  findFirst: async (where: any) => {\n    return await prisma.user.findFirst({\n      where,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Create new user (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('🔍 simplifiedUsers.create called with data:', data);\n      \n      // Password should already be hashed when passed to this function\n      const userData = { ...data };\n\n      // Validate merchantId exists if provided\n      if (userData.merchantId && typeof userData.merchantId === 'number') {\n        const merchant = await prisma.merchant.findUnique({\n          where: { id: userData.merchantId },\n          select: { id: true, name: true }\n        });\n        \n        if (!merchant) {\n          throw new Error(`Merchant with id ${userData.merchantId} not found`);\n        }\n        \n        console.log('✅ Merchant found:', merchant);\n        // Keep the number ID as-is since schema uses Int IDs\n      }\n\n      // Validate outletId exists if provided\n      if (userData.outletId && typeof userData.outletId === 'number') {\n        const outlet = await prisma.outlet.findUnique({\n          where: { id: userData.outletId },\n          select: { id: true, name: true, merchantId: true }\n        });\n        \n        if (!outlet) {\n          throw new Error(`Outlet with id ${userData.outletId} not found`);\n        }\n        \n        // Validate outlet belongs to the same merchant\n        if (userData.merchantId && outlet.merchantId !== userData.merchantId) {\n          throw new Error(`Outlet ${userData.outletId} does not belong to merchant ${userData.merchantId}`);\n        }\n        \n        console.log('✅ Outlet found:', outlet);\n        // Keep the number ID as-is since schema uses Int IDs\n      }\n\n      // Check for duplicate email globally\n      if (userData.email) {\n        const existingEmail = await prisma.user.findUnique({\n          where: { email: userData.email },\n          select: { id: true, email: true }\n        });\n        \n        if (existingEmail) {\n          throw new Error(`Email ${userData.email} is already registered`);\n        }\n      }\n\n      // Check for duplicate phone within merchant\n      if (userData.phone && userData.merchantId) {\n        const existingPhone = await prisma.user.findFirst({\n          where: { \n            phone: userData.phone,\n            merchantId: userData.merchantId\n          },\n          select: { id: true, phone: true, merchantId: true }\n        });\n        \n        if (existingPhone) {\n          throw new Error(`Phone number ${userData.phone} is already registered in this merchant`);\n        }\n      }\n\n      // Generate next user id\n      const lastUser = await prisma.user.findFirst({\n        orderBy: { id: 'desc' },\n        select: { id: true }\n      });\n      const nextPublicId = (lastUser?.id || 0) + 1;\n      userData.id = nextPublicId;\n\n      const user = await prisma.user.create({\n        data: userData,\n        include: {\n          merchant: { \n            select: { \n              id: true, \n              name: true,\n              email: true,\n              phone: true,\n              address: true,\n              city: true,\n              state: true,\n              zipCode: true,\n              country: true,\n              businessType: true,\n              taxId: true,\n              website: true,\n              description: true,\n              isActive: true,\n              planId: true,\n              // subscriptionStatus removed - use subscription.status\n              totalRevenue: true,\n              createdAt: true,\n              lastActiveAt: true\n            } \n          },\n          outlet: { \n            select: { \n              id: true, \n              name: true,\n              address: true,\n              phone: true,\n              description: true,\n              isActive: true,\n              isDefault: true,\n              createdAt: true,\n              merchant: {\n                select: {\n                  id: true,\n                  name: true,\n                }\n              }\n            } \n          }\n        }\n      });\n      \n      console.log('✅ User created successfully:', user);\n      return user;\n    } catch (error) {\n      console.error('❌ Error in simplifiedUsers.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update user (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.user.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Delete user (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.user.update({\n      where: { id },\n      data: { \n        isActive: false,\n        deletedAt: new Date()\n      }\n    });\n  },\n\n  /**\n   * Search users with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.outletId) where.outletId = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.role) where.role = whereFilters.role;\n    \n    // Text search (case-insensitive)\n    if (whereFilters.search) {\n      where.OR = [\n        { firstName: { contains: whereFilters.search, mode: 'insensitive' } },\n        { lastName: { contains: whereFilters.search, mode: 'insensitive' } },\n        { email: { contains: whereFilters.search, mode: 'insensitive' } }\n      ];\n    }\n\n    // ✅ Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [users, total] = await Promise.all([\n      prisma.user.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          outlet: { select: { id: true, name: true } }\n        },\n        orderBy, // ✅ Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.user.count({ where })\n    ]);\n\n    console.log(`📊 db.users.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, users=${users.length}`);\n\n    return {\n      data: users,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.user.count({ where });\n  }\n};\n","// ============================================================================\n// NEW: CORRECT DUAL ID CUSTOMER FUNCTIONS\n// ============================================================================\n// This file contains only the correct customer functions that follow the dual ID system:\n// - Input: id (number)\n// - Database: queries by id, uses CUIDs for relationships\n// - Return: includes both id (CUID) and id (number)\n\nimport { prisma } from './client';\nimport type { \n  CustomerInput, \n  CustomerUpdateInput, \n  CustomerSearchFilter,\n  CustomerSearchResult,\n  CustomerSearchResponse \n} from '@rentalshop/types';\n\n// ============================================================================\n// CUSTOMER LOOKUP FUNCTIONS (BY PUBLIC ID)\n// ============================================================================\n\n/**\n * Get customer by public ID and merchant - follows dual ID system\n * Input: id (number) and merchantId (number), Output: Customer with relations\n */\nexport async function getCustomerByPublicId(id: number, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findFirst({\n    where: { \n      id,\n      merchantId: merchant.id // Use CUID for merchant\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      orders: {\n        select: {\n          id: true,\n          orderNumber: true,\n          status: true,\n          totalAmount: true,\n          createdAt: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get customer by email and merchant - follows dual ID system\n */\nexport async function getCustomerByEmail(email: string, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      email: email,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get customer by phone and merchant - follows dual ID system\n */\nexport async function getCustomerByPhone(phone: string, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      phone: phone,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// CUSTOMER CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new customer - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createCustomer(input: CustomerInput): Promise<any> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: input.merchantId }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${input.merchantId} not found`);\n  }\n\n  // Generate next customer id\n  const lastCustomer = await prisma.customer.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastCustomer?.id || 0) + 1;\n\n  // Create customer\n  const customer = await prisma.customer.create({\n    data: {\n      id: nextPublicId,\n      firstName: input.firstName,\n      lastName: input.lastName,\n      email: input.email && input.email.trim() !== '' ? input.email : null,\n      phone: input.phone,\n      address: input.address,\n      city: input.city,\n      state: input.state,\n      zipCode: input.zipCode,\n      country: input.country,\n      dateOfBirth: input.dateOfBirth,\n      idNumber: input.idNumber,\n      idType: input.idType,\n      notes: input.notes,\n      isActive: true, // Default to true\n      merchantId: merchant.id, // Use CUID\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return customer;\n}\n\n// ============================================================================\n// CUSTOMER UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update customer - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateCustomer(\n  id: number,\n  input: CustomerUpdateInput\n): Promise<any> {\n  // Find customer by id\n  const existingCustomer = await prisma.customer.findUnique({\n    where: { id }\n  });\n\n  if (!existingCustomer) {\n    throw new Error(`Customer with id ${id} not found`);\n  }\n\n  // Update customer\n  const updatedCustomer = await prisma.customer.update({\n    where: { id },\n    data: {\n      firstName: input.firstName,\n      lastName: input.lastName,\n      email: input.email,\n      phone: input.phone,\n      address: input.address,\n      city: input.city,\n      state: input.state,\n      zipCode: input.zipCode,\n      country: input.country,\n      dateOfBirth: input.dateOfBirth,\n      idNumber: input.idNumber,\n      idType: input.idType,\n      notes: input.notes,\n      isActive: input.isActive,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return updatedCustomer;\n}\n\n// ============================================================================\n// CUSTOMER SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Build order by clause for customer queries\n */\nfunction buildCustomerOrderByClause(sortBy?: string, sortOrder?: string): any {\n  const validSortFields = [\n    'createdAt', 'updatedAt', 'firstName', 'lastName', 'email', 'phone'\n  ];\n  \n  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';\n  const order = sortOrder === 'asc' ? 'asc' : 'desc';\n  \n  return { [field as string]: order };\n}\n\n/**\n * Search customers - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchCustomers(\n  filters: CustomerSearchFilter\n): Promise<CustomerSearchResponse> {\n  const {\n    q,\n    merchantId,\n    isActive,\n    city,\n    state,\n    country,\n    idType,\n    limit = 20,\n    offset = 0,\n    sortBy,\n    sortOrder\n  } = filters;\n\n  // Build where conditions\n  const where: any = {};\n\n  if (merchantId) {\n    // Find merchant by id\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: merchantId },\n      select: { id: true }\n    });\n    \n    if (merchant) {\n      where.merchantId = merchant.id; // Use CUID\n    }\n  }\n\n  // Default to active customers only\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  } else {\n    where.isActive = true;\n  }\n\n  if (city) {\n    where.city = { contains: city.toLowerCase() };\n  }\n\n  if (state) {\n    where.state = { contains: state.toLowerCase() };\n  }\n\n  if (country) {\n    where.country = { contains: country.toLowerCase() };\n  }\n\n  if (idType) {\n    where.idType = idType;\n  }\n\n  // Search query for name, email, phone, or idNumber (case-insensitive)\n  if (q && q.trim()) {\n    const searchQuery = q.trim();\n    where.OR = [\n      { firstName: { contains: searchQuery, mode: 'insensitive' } },\n      { lastName: { contains: searchQuery, mode: 'insensitive' } },\n      { email: { contains: searchQuery, mode: 'insensitive' } },\n      { phone: { contains: searchQuery } } // Phone numbers are usually exact match\n    ];\n  }\n\n  // Get total count\n  const total = await prisma.customer.count({ where });\n\n  // Get customers with pagination\n  const customers = await prisma.customer.findMany({\n    where,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    },\n    orderBy: buildCustomerOrderByClause(sortBy, sortOrder),\n    take: limit,\n    skip: offset\n  });\n\n  // Transform to match CustomerSearchResult type\n  const transformedCustomers: CustomerSearchResult[] = customers.map((customer: any) => ({\n    id: customer.id, // Use id (number) as required by CustomerSearchResult\n    firstName: customer.firstName,\n    lastName: customer.lastName,\n    email: customer.email || '',\n    phone: customer.phone,\n    address: customer.address || undefined,\n    city: customer.city || undefined,\n    state: customer.state || undefined,\n    zipCode: customer.zipCode || undefined,\n    country: customer.country || undefined,\n    dateOfBirth: customer.dateOfBirth || undefined,\n    idNumber: customer.idNumber || undefined,\n    idType: customer.idType as any,\n    notes: customer.notes || undefined,\n    isActive: customer.isActive,\n    createdAt: customer.createdAt,\n    updatedAt: customer.updatedAt,\n    merchantId: customer.merchant.id, // Add merchantId as required\n    merchant: {\n      id: customer.merchant.id, // Use id (number) as required\n      name: customer.merchant.name,\n    },\n  }));\n\n  return {\n    success: true,\n    data: {\n      customers: transformedCustomers as any, // Type assertion to handle CustomerWithMerchant mismatch\n      total,\n      page: Math.floor(offset / limit) + 1,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n      totalPages: Math.ceil(total / limit),\n    },\n  };\n}\n\n// ============================================================================\n// CUSTOMER UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get customers by merchant - follows dual ID system\n */\nexport async function getCustomersByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findMany({\n    where: { merchantId: merchant.id }, // Use CUID\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Check if customer exists by email - follows dual ID system\n */\nexport async function customerExistsByEmail(email: string, merchantId: number): Promise<boolean> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const customer = await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      email: email,\n    },\n  });\n\n  return !!customer;\n}\n\n/**\n * Check if customer exists by phone - follows dual ID system\n */\nexport async function customerExistsByPhone(phone: string, merchantId: number): Promise<boolean> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const customer = await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      phone: phone,\n    },\n  });\n\n  return !!customer;\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedCustomers = {\n  /**\n   * Find customer by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.customer.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        orders: {\n          select: { id: true, orderNumber: true, totalAmount: true, status: true, createdAt: true },\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new customer (simplified API)\n   */\n  create: async (data: any) => {\n    // Handle optional email field - convert empty string to null\n    const customerData = {\n      ...data,\n      email: data.email && data.email.trim() !== '' ? data.email : null\n    };\n    \n    // Remove merchant connection from data since it's handled by Prisma relations\n    delete customerData.merchant;\n    \n    return await prisma.customer.create({\n      data: customerData,\n      include: {\n        merchant: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Update customer (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.customer.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Search customers with pagination (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.outletId) where.outletId = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    \n    // Text search across multiple fields\n    if (whereFilters.search) {\n      where.OR = [\n        { firstName: { contains: whereFilters.search } },\n        { lastName: { contains: whereFilters.search } },\n        { email: { contains: whereFilters.search } },\n        { phone: { contains: whereFilters.search } }\n      ];\n    }\n\n    // Specific field filters\n    if (whereFilters.firstName) where.firstName = { contains: whereFilters.firstName };\n    if (whereFilters.lastName) where.lastName = { contains: whereFilters.lastName };\n    if (whereFilters.email) where.email = { contains: whereFilters.email };\n    if (whereFilters.phone) where.phone = { contains: whereFilters.phone };\n    if (whereFilters.city) where.city = { contains: whereFilters.city };\n    if (whereFilters.state) where.state = { contains: whereFilters.state };\n    if (whereFilters.country) where.country = { contains: whereFilters.country };\n\n    // ✅ Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email' || sortBy === 'phone') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [customers, total] = await Promise.all([\n      prisma.customer.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          _count: {\n            select: { orders: true }\n          }\n        },\n        orderBy, // ✅ Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.customer.count({ where })\n    ]);\n\n    console.log(`📊 db.customers.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, customers=${customers.length}`);\n\n    return {\n      data: customers,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Get customer statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.customer.count({ where });\n  }\n};\n","// ============================================================================\n// NEW: CORRECT DUAL ID PRODUCT FUNCTIONS\n// ============================================================================\n// This file contains only the correct product functions that follow the dual ID system:\n// - Input: id (number)\n// - Database: queries by id, uses CUIDs for relationships\n// - Return: includes both id (CUID) and id (number)\n\nimport { prisma } from './client';\nimport type { ProductSearchFilter } from '@rentalshop/types';\n\n// ============================================================================\n// PRODUCT LOOKUP FUNCTIONS (BY PUBLIC ID)\n// ============================================================================\n\n/**\n * Get product by id (number) - follows dual ID system\n * SECURITY: Enforces merchant isolation to prevent cross-tenant access\n */\nexport async function getProductById(id: number, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.product.findFirst({\n    where: { \n      id,\n      merchantId: merchant.id // Use CUID for merchant isolation\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outletStock: {\n        select: {\n          id: true,\n          stock: true,\n          available: true,\n          renting: true,\n          outlet: {\n            select: {\n      id: true,\n              name: true,\n              address: true,\n            },\n          },\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get product by barcode - follows dual ID system\n * SECURITY: Enforces merchant isolation to prevent cross-tenant access\n */\nexport async function getProductByBarcode(barcode: string, merchantId: number) {\n  // Find merchant by id to get the CUID\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.product.findFirst({\n    where: { \n      barcode,\n      merchantId: merchant.id // Use CUID for merchant isolation\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// PRODUCT SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Build order by clause for product queries\n */\nfunction buildProductOrderByClause(sortBy?: string, sortOrder?: string): any {\n  const validSortFields = [\n    'createdAt', 'updatedAt', 'name', 'rentPrice', 'salePrice', 'totalStock'\n  ];\n  \n  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';\n  const order = sortOrder === 'asc' ? 'asc' : 'desc';\n  \n  return { [field as string]: order };\n}\n\n/**\n * Search products - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchProducts(filters: ProductSearchFilter) {\n  const {\n    merchantId,\n    outletId,\n    categoryId,\n    search,\n    q, // Add q parameter support\n    page = 1,\n    limit = 20,\n    offset, // Add offset support\n    isActive = true,\n    available,\n    minPrice,\n    maxPrice,\n    sortBy,\n    sortOrder\n  } = filters;\n\n  // Use offset if provided, otherwise calculate from page\n  const skip = offset !== undefined ? offset : (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {\n    isActive,\n  };\n\n  if (merchantId) {\n    // Find merchant by id\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: merchantId },\n      select: { id: true }\n    });\n    \n    if (merchant) {\n      where.merchantId = merchant.id; // Use CUID\n    }\n  }\n\n  if (categoryId) {\n    // Find category by id\n    const category = await prisma.category.findUnique({\n      where: { id: categoryId },\n      select: { id: true }\n    });\n    \n    if (category) {\n      where.categoryId = category.id; // Use CUID\n    }\n  }\n\n  // Handle search query - use 'q' parameter first, fallback to 'search' for backward compatibility (case-insensitive)\n  const searchQuery = q || search;\n  if (searchQuery) {\n    const searchTerm = searchQuery.trim();\n    where.OR = [\n      { name: { contains: searchTerm, mode: 'insensitive' } },\n      { description: { contains: searchTerm, mode: 'insensitive' } },\n      { barcode: { equals: searchTerm } } // Barcode is usually exact match\n    ];\n  }\n\n  // If outletId is specified, only show products that have stock at that outlet\n  if (outletId) {\n    // Find outlet by id\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: outletId },\n      select: { id: true }\n    });\n    \n    if (outlet) {\n      where.outletStock = {\n        some: {\n          outletId: outlet.id, // Use CUID\n          stock: { gt: 0 }\n        }\n      };\n    }\n  }\n\n  // Add availability filter\n  if (available !== undefined) {\n    if (available) {\n      where.outletStock = {\n        some: {\n          available: { gt: 0 }\n        }\n      };\n    } else {\n      where.outletStock = {\n        none: {\n          available: { gt: 0 }\n        }\n      };\n    }\n  }\n\n  // Add price range filters\n  if (minPrice !== undefined || maxPrice !== undefined) {\n    where.rentPrice = {};\n    if (minPrice !== undefined) where.rentPrice.gte = minPrice;\n    if (maxPrice !== undefined) where.rentPrice.lte = maxPrice;\n  }\n\n  const [products, total] = await Promise.all([\n    prisma.product.findMany({\n      where,\n      select: {\n      id: true,\n        name: true,\n        description: true,\n        barcode: true,\n        totalStock: true,\n        rentPrice: true,\n        salePrice: true,\n        deposit: true,\n        images: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true,\n        category: {\n          select: {\n      id: true,\n            name: true\n          }\n        },\n        merchant: {\n          select: {\n      id: true,\n            name: true\n          }\n        },\n        outletStock: {\n          select: {\n            id: true,\n            stock: true,\n            available: true,\n            renting: true,\n            outlet: {\n              select: {\n      id: true,\n                name: true,\n                address: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: buildProductOrderByClause(sortBy, sortOrder),\n      take: limit,\n      skip: skip\n    }),\n    prisma.product.count({ where })\n  ]);\n\n  // Transform to match expected types\n  const transformedProducts = products.map((product: any) => ({\n    id: product.id, // Return id (number) for external use\n    name: product.name,\n    description: product.description,\n    barcode: product.barcode,\n    totalStock: product.totalStock,\n    rentPrice: product.rentPrice,\n    salePrice: product.salePrice,\n    deposit: product.deposit,\n    images: product.images,\n    isActive: product.isActive,\n    createdAt: product.createdAt,\n    updatedAt: product.updatedAt,\n    category: {\n      id: product.category.id, // Return id (number)\n      name: product.category.name,\n    },\n    merchant: {\n      id: product.merchant.id, // Return id (number)\n      name: product.merchant.name,\n    },\n    outletStock: product.outletStock.map((stock: any) => ({\n      id: stock.id, // Keep CUID for internal use\n      stock: stock.stock,\n      available: stock.available,\n      renting: stock.renting,\n      outlet: {\n        id: stock.outlet.id, // Return id (number)\n        name: stock.outlet.name,\n        address: stock.outlet.address,\n      },\n    })),\n  }));\n\n  return {\n    products: transformedProducts,\n    total,\n    page: offset !== undefined ? Math.floor(offset / limit) + 1 : page,\n    limit,\n    offset: skip,\n    hasMore: skip + limit < total,\n    totalPages: Math.ceil(total / limit),\n  };\n}\n\n// ============================================================================\n// DEFAULT CATEGORY FUNCTIONS\n// ============================================================================\n\n/**\n * Get or create default category for merchant\n */\nasync function getOrCreateDefaultCategory(merchantId: number): Promise<any> {\n  // First try to find existing default category\n  const existingDefault = await prisma.category.findFirst({\n    where: {\n      merchantId: merchantId, // merchantId is number (public ID)\n      name: 'General',\n      isActive: true\n    }\n  });\n\n  if (existingDefault) {\n    console.log('✅ Found existing default category:', existingDefault.id);\n    return existingDefault;\n  }\n\n  // Create default category if not exists\n  console.log('🔧 Creating default category for merchant:', merchantId);\n  \n  // Generate next category id\n  const lastCategory = await prisma.category.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastCategory?.id || 0) + 1;\n\n  const defaultCategory = await prisma.category.create({\n    data: {\n      id: nextPublicId,\n      name: 'General',\n      description: 'Default category for general products',\n      merchantId: merchantId,\n      isActive: true\n    }\n  });\n\n  console.log('✅ Created default category:', defaultCategory.id);\n  return defaultCategory;\n}\n\n// ============================================================================\n// PRODUCT CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new product - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createProduct(input: any): Promise<any> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: input.merchantId }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${input.merchantId} not found`);\n  }\n\n  // Find category by id if provided\n  let category = null;\n  if (input.categoryId) {\n    category = await prisma.category.findUnique({\n      where: { id: input.categoryId }\n    });\n    \n    if (!category) {\n      throw new Error(`Category with id ${input.categoryId} not found`);\n    }\n  }\n\n  // Generate next product id\n  const lastProduct = await prisma.product.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastProduct?.id || 0) + 1;\n\n  // Create product\n  const productData: any = {\n    id: nextPublicId,\n    name: input.name,\n    description: input.description,\n    barcode: input.barcode,\n    totalStock: input.totalStock || 0,\n    rentPrice: input.rentPrice,\n    salePrice: input.salePrice,\n    deposit: input.deposit || 0,\n    images: input.images,\n    isActive: input.isActive ?? true,\n    merchantId: merchant.id, // Use CUID\n  };\n\n  // Only add categoryId if category is provided\n  if (category) {\n    productData.categoryId = category.id;\n  }\n\n  const product = await prisma.product.create({\n    data: productData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return product;\n}\n\n// ============================================================================\n// PRODUCT UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update product - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateProduct(\n  id: number,\n  input: any\n): Promise<any> {\n  // Find product by id\n  const existingProduct = await prisma.product.findUnique({\n    where: { id }\n  });\n\n  if (!existingProduct) {\n    throw new Error(`Product with id ${id} not found`);\n  }\n\n  // Handle category update if categoryId is provided\n  let categoryId = undefined;\n  if (input.categoryId !== undefined) {\n    if (input.categoryId === null || input.categoryId === 0) {\n      // Remove category\n      categoryId = null;\n    } else {\n      // Find category by id\n      const category = await prisma.category.findUnique({\n        where: { id: input.categoryId }\n      });\n      \n      if (!category) {\n        throw new Error(`Category with id ${input.categoryId} not found`);\n      }\n      \n      categoryId = category.id; // Use CUID for database\n    }\n  }\n\n  // Prepare update data\n  const updateData: any = {};\n  \n  // Only update fields that are provided\n  if (input.name !== undefined) updateData.name = input.name;\n  if (input.description !== undefined) updateData.description = input.description;\n  if (input.barcode !== undefined) updateData.barcode = input.barcode;\n  if (input.totalStock !== undefined) updateData.totalStock = input.totalStock;\n  if (input.rentPrice !== undefined) updateData.rentPrice = input.rentPrice;\n  if (input.salePrice !== undefined) updateData.salePrice = input.salePrice;\n  if (input.deposit !== undefined) updateData.deposit = input.deposit;\n  if (input.images !== undefined) updateData.images = input.images;\n  if (input.isActive !== undefined) updateData.isActive = input.isActive;\n  if (categoryId !== undefined) updateData.categoryId = categoryId;\n\n  // Update product\n  const updatedProduct = await prisma.product.update({\n    where: { id },\n    data: updateData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return updatedProduct;\n}\n\n// ============================================================================\n// PRODUCT UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get products by merchant - follows dual ID system\n */\nexport async function getProductsByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.product.findMany({\n    where: { merchantId: merchant.id }, // Use CUID\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get products by category - follows dual ID system\n */\nexport async function getProductsByCategory(categoryId: number) {\n  // Find category by id\n  const category = await prisma.category.findUnique({\n    where: { id: categoryId },\n    select: { id: true }\n  });\n  \n  if (!category) {\n    throw new Error(`Category with id ${categoryId} not found`);\n  }\n\n  return await prisma.product.findMany({\n    where: { categoryId: category.id }, // Use CUID\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Update product stock - follows dual ID system\n */\nexport async function updateProductStock(\n  productId: number,\n  outletId: number,\n  stockChange: number\n): Promise<any> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id: productId },\n    select: { id: true }\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${productId} not found`);\n  }\n\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Update or create outlet stock\n  const outletStock = await prisma.outletStock.upsert({\n    where: {\n      productId_outletId: {\n        productId: product.id, // Use CUID\n        outletId: outlet.id, // Use CUID\n      },\n    },\n    update: {\n      stock: { increment: stockChange },\n      available: { increment: stockChange },\n    },\n    create: {\n      productId: product.id, // Use CUID\n      outletId: outlet.id, // Use CUID\n      stock: stockChange,\n      available: stockChange,\n      renting: 0,\n    },\n  });\n\n  return outletStock;\n}\n\n/**\n * Delete product - follows dual ID system\n * Input: id (number), Output: deleted product data\n */\nexport async function deleteProduct(id: number): Promise<any> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${id} not found`);\n  }\n\n  // Delete the product (this will cascade to outletStock due to Prisma schema)\n  const deletedProduct = await prisma.product.delete({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  // Transform to match expected types\n  return {\n    id: deletedProduct.id,\n    name: deletedProduct.name,\n    description: deletedProduct.description,\n    barcode: deletedProduct.barcode,\n    totalStock: deletedProduct.totalStock,\n    rentPrice: deletedProduct.rentPrice,\n    salePrice: deletedProduct.salePrice,\n    deposit: deletedProduct.deposit,\n    images: deletedProduct.images,\n    isActive: deletedProduct.isActive,\n    createdAt: deletedProduct.createdAt,\n    updatedAt: deletedProduct.updatedAt,\n    category: {\n      id: deletedProduct.category.id,\n      name: deletedProduct.category.name,\n    },\n    merchant: {\n      id: deletedProduct.merchant.id,\n      name: deletedProduct.merchant.name,\n    },\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedProducts = {\n  /**\n   * Find product by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.product.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Find product by barcode (simplified API)\n   */\n  findByBarcode: async (barcode: string) => {\n    return await prisma.product.findUnique({\n      where: { barcode },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new product (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('🔍 simplifiedProducts.create called with data:', data);\n      \n      // If no categoryId provided, get or create default category\n      if (!data.categoryId && data.merchant && data.merchant.connect && data.merchant.connect.id) {\n        const merchantPublicId = data.merchant.connect.id; // This is the public ID (number)\n        const defaultCategory = await getOrCreateDefaultCategory(merchantPublicId);\n        \n        // Add category connection to data\n        data.category = { connect: { id: defaultCategory.id } };\n        console.log('✅ Using default category:', defaultCategory.id, 'for merchant:', merchantPublicId);\n      }\n      \n      const product = await prisma.product.create({\n        data,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          category: { select: { id: true, name: true } },\n          outletStock: {\n            include: {\n              outlet: { select: { id: true, name: true } }\n            }\n          }\n        }\n      });\n      \n      console.log('✅ Product created successfully:', product.id);\n      return product;\n    } catch (error) {\n      console.error('❌ Error in simplifiedProducts.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update product (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.product.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Delete product (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.product.update({\n      where: { id },\n      data: { isActive: false }\n    });\n  },\n\n  /**\n   * Get product statistics (simplified API)\n   */\n  getStats: async (where: any = {}) => {\n    return await prisma.product.count({ where });\n  },\n\n  /**\n   * Search products with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.categoryId) where.categoryId = whereFilters.categoryId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    \n    // Text search\n    if (whereFilters.search) {\n      where.OR = [\n        { name: { contains: whereFilters.search } },\n        { description: { contains: whereFilters.search } },\n        { barcode: { contains: whereFilters.search } }\n      ];\n    }\n\n    // Price range\n    if (whereFilters.minPrice !== undefined || whereFilters.maxPrice !== undefined) {\n      where.rentPrice = {};\n      if (whereFilters.minPrice !== undefined) where.rentPrice.gte = whereFilters.minPrice;\n      if (whereFilters.maxPrice !== undefined) where.rentPrice.lte = whereFilters.maxPrice;\n    }\n\n    const [products, total] = await Promise.all([\n      prisma.product.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          category: { select: { id: true, name: true } },\n          outletStock: {\n            include: {\n              outlet: { select: { id: true, name: true } }\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit\n      }),\n      prisma.product.count({ where })\n    ]);\n\n    return {\n      data: products,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.product.count({ where });\n  }\n};\n","import { prisma } from './client';\nimport type { Prisma } from '@prisma/client';\nimport type { \n  OrderSearchFilter,\n  OrderSearchResult,\n  OrderSearchResponse\n} from '@rentalshop/types';\n\nexport interface OrderWithRelations {\n  id: number\n  orderNumber: string\n  orderType: string\n  status: string\n  totalAmount: number\n  depositAmount: number\n  securityDeposit: number\n  damageFee: number\n  lateFee: number\n  discountType?: string\n  discountValue: number\n  discountAmount: number\n  pickupPlanAt?: Date\n  returnPlanAt?: Date\n  pickedUpAt?: Date\n  returnedAt?: Date\n  rentalDuration?: number\n  isReadyToDeliver: boolean\n  collateralType?: string\n  collateralDetails?: string\n  notes?: string\n  pickupNotes?: string\n  returnNotes?: string\n  damageNotes?: string\n  createdAt: Date\n  updatedAt: Date\n  outletId: number\n  merchantId?: number // Extracted from outlet relation for authorization\n  customerId?: number\n  createdById: number\n  // Relations\n  customer?: {\n    id: number\n    firstName: string\n    lastName: string\n    phone?: string\n    email?: string\n    address?: string\n    idNumber?: string\n  }\n  outlet?: {\n    id: number\n    name: string\n    address: string\n    merchantId: number\n    merchant: {\n      id: number\n      name: string\n    }\n  }\n  createdBy?: {\n    id: number\n    firstName?: string\n    email: string\n  }\n  orderItems?: Array<{\n    id: number\n    quantity: number\n    unitPrice: number\n    totalPrice: number\n    productId: number\n    product?: {\n      id: number\n      name: string\n    }\n  }>\n  payments?: Array<{\n    id: number\n    amount: number\n    method: string\n    status: string\n    processedAt?: Date\n  }>\n}\n\nconst orderSelect = {\n  id: true,\n  orderNumber: true,\n  orderType: true,\n  status: true,\n  totalAmount: true,\n  depositAmount: true,\n  securityDeposit: true,\n  damageFee: true,\n  lateFee: true,\n  discountType: true,\n  discountValue: true,\n  discountAmount: true,\n  pickupPlanAt: true,\n  returnPlanAt: true,\n  pickedUpAt: true,\n  returnedAt: true,\n  rentalDuration: true,\n  isReadyToDeliver: true,\n  collateralType: true,\n  collateralDetails: true,\n  notes: true,\n  pickupNotes: true,\n  returnNotes: true,\n  damageNotes: true,\n  createdAt: true,\n  updatedAt: true,\n  outletId: true,\n  customerId: true,\n  createdById: true,\n} satisfies Prisma.OrderSelect\n\nconst orderInclude = {\n  customer: {\n    select: {\n      id: true,\n      firstName: true,\n      lastName: true,\n      phone: true,\n      email: true,\n      address: true,\n      idNumber: true,\n    }\n  },\n  outlet: {\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      merchantId: true, // Include merchantId for authorization checks\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        }\n      }\n    }\n  },\n  createdBy: {\n    select: {\n      id: true,\n      firstName: true,\n      email: true,\n    }\n  },\n  orderItems: {\n    select: {\n      id: true,\n      quantity: true,\n      unitPrice: true,\n      totalPrice: true,\n      productId: true,\n      product: {\n        select: {\n          id: true,\n          name: true,\n        }\n      }\n    }\n  },\n  payments: {\n    select: {\n      id: true,\n      amount: true,\n      method: true,\n      status: true,\n      processedAt: true,\n    }\n  }\n} satisfies Prisma.OrderInclude\n\nfunction transformOrder(order: any): OrderWithRelations {\n  return {\n    id: order.id,\n    orderNumber: order.orderNumber,\n    orderType: order.orderType,\n    status: order.status,\n    totalAmount: order.totalAmount,\n    depositAmount: order.depositAmount ?? 0,\n    securityDeposit: order.securityDeposit ?? 0,\n    damageFee: order.damageFee ?? 0,\n    lateFee: order.lateFee ?? 0,\n    discountType: order.discountType || undefined,\n    discountValue: order.discountValue ?? 0,\n    discountAmount: order.discountAmount ?? 0,\n    pickupPlanAt: order.pickupPlanAt || undefined,\n    returnPlanAt: order.returnPlanAt || undefined,\n    pickedUpAt: order.pickedUpAt || undefined,\n    returnedAt: order.returnedAt || undefined,\n    rentalDuration: order.rentalDuration || undefined,\n    isReadyToDeliver: order.isReadyToDeliver ?? false,\n    collateralType: order.collateralType || undefined,\n    collateralDetails: order.collateralDetails || undefined,\n    notes: order.notes || undefined,\n    pickupNotes: order.pickupNotes || undefined,\n    returnNotes: order.returnNotes || undefined,\n    damageNotes: order.damageNotes || undefined,\n    createdAt: order.createdAt,\n    updatedAt: order.updatedAt,\n    outletId: order.outletId,\n    merchantId: order.outlet?.merchantId, // Extract merchantId from outlet relation for authorization\n    customerId: order.customerId || undefined,\n    createdById: order.createdById,\n    // Relations\n    customer: order.customer,\n    outlet: order.outlet,\n    createdBy: order.createdBy,\n    orderItems: order.orderItems,\n    payments: order.payments,\n  }\n}\n\nexport async function getOrderById(id: number): Promise<OrderWithRelations | null> {\n  const order = await prisma.order.findUnique({\n    where: { id },\n    include: orderInclude,\n  })\n\n  if (!order) return null\n  return transformOrder(order)\n}\n\nexport async function getOrderByNumber(orderNumber: string): Promise<OrderWithRelations | null> {\n  const order = await prisma.order.findUnique({\n    where: { orderNumber },\n    include: orderInclude,\n  })\n\n  if (!order) return null\n  return transformOrder(order)\n}\n\nexport async function getOrdersByOutlet(outletId: number, limit = 50, offset = 0) {\n  const orders = await prisma.order.findMany({\n    where: { outletId },\n    include: orderInclude,\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: offset,\n  })\n\n  return orders.map(transformOrder)\n}\n\nexport async function getOrdersByCustomer(customerId: number, limit = 50, offset = 0) {\n  const orders = await prisma.order.findMany({\n    where: { customerId },\n    include: orderInclude,\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: offset,\n  })\n\n  return orders.map(transformOrder)\n}\n\nexport async function createOrder(data: {\n  orderNumber: string\n  orderType: string\n  status?: string\n  totalAmount: number\n  depositAmount?: number\n  securityDeposit?: number\n  damageFee?: number\n  lateFee?: number\n  discountType?: string\n  discountValue?: number\n  discountAmount?: number\n  pickupPlanAt?: Date\n  returnPlanAt?: Date\n  rentalDuration?: number\n  isReadyToDeliver?: boolean\n  collateralType?: string\n  collateralDetails?: string\n  notes?: string\n  pickupNotes?: string\n  outletId: number\n  customerId?: number\n  createdById: number\n}): Promise<OrderWithRelations> {\n  const order = await prisma.order.create({\n    data: {\n      orderNumber: data.orderNumber,\n      orderType: data.orderType,\n      status: data.status ?? 'RESERVED',\n      totalAmount: data.totalAmount,\n      depositAmount: data.depositAmount ?? 0,\n      securityDeposit: data.securityDeposit ?? 0,\n      damageFee: data.damageFee ?? 0,\n      lateFee: data.lateFee ?? 0,\n      discountType: data.discountType,\n      discountValue: data.discountValue ?? 0,\n      discountAmount: data.discountAmount ?? 0,\n      pickupPlanAt: data.pickupPlanAt,\n      returnPlanAt: data.returnPlanAt,\n      rentalDuration: data.rentalDuration,\n      isReadyToDeliver: data.isReadyToDeliver ?? false,\n      collateralType: data.collateralType,\n      collateralDetails: data.collateralDetails,\n      notes: data.notes,\n      pickupNotes: data.pickupNotes,\n      outletId: data.outletId,\n      customerId: data.customerId,\n      createdById: data.createdById,\n    },\n    include: orderInclude,\n  })\n\n  return transformOrder(order)\n}\n\nexport async function updateOrder(\n  id: number,\n  data: Partial<{\n    orderType: string\n    status: string\n    totalAmount: number\n    depositAmount: number\n    securityDeposit: number\n    damageFee: number\n    lateFee: number\n    discountType: string\n    discountValue: number\n    discountAmount: number\n    pickupPlanAt: Date\n    returnPlanAt: Date\n    pickedUpAt: Date\n    returnedAt: Date\n    rentalDuration: number\n    isReadyToDeliver: boolean\n    collateralType: string\n    collateralDetails: string\n    notes: string\n    pickupNotes: string\n    returnNotes: string\n    damageNotes: string\n    customerId: number\n    outletId: number\n    orderItems?: Array<{\n      productId: number\n      quantity: number\n      unitPrice: number\n      totalPrice: number\n      deposit?: number\n      notes?: string\n      rentalDays?: number\n    }>\n  }>\n): Promise<OrderWithRelations> {\n  console.log('🔧 updateOrder called with id:', id);\n  console.log('🔧 updateOrder data keys:', Object.keys(data));\n  console.log('🔧 updateOrder has orderItems?:', !!data.orderItems, 'length:', data.orderItems?.length);\n  \n  // Extract relationship IDs and orderItems from data\n  const { \n    orderItems, \n    customerId, \n    outletId,\n    ...allFields \n  } = data;\n  \n  // WHITELIST: Only valid Order model fields from schema\n  const validFields: (keyof typeof allFields)[] = [\n    'orderType', 'status', 'totalAmount', 'depositAmount', \n    'securityDeposit', 'damageFee', 'lateFee', 'discountType', \n    'discountValue', 'discountAmount', 'pickupPlanAt', 'returnPlanAt',\n    'pickedUpAt', 'returnedAt', 'rentalDuration', 'isReadyToDeliver',\n    'collateralType', 'collateralDetails', 'notes', 'pickupNotes',\n    'returnNotes', 'damageNotes'\n  ];\n  \n  // Build update data - filter to only valid fields\n  const updateData: any = {};\n  validFields.forEach(field => {\n    if (field in allFields && allFields[field as keyof typeof allFields] !== undefined) {\n      updateData[field] = allFields[field as keyof typeof allFields];\n    }\n  });\n  \n  console.log('🔧 Filtered update fields:', Object.keys(updateData));\n  \n  // Handle customer relationship if provided\n  if (customerId !== undefined) {\n    if (customerId === null) {\n      updateData.customer = { disconnect: true };\n    } else {\n      updateData.customer = { connect: { id: customerId } };\n    }\n  }\n  \n  // Handle outlet relationship if provided (should not change usually)\n  if (outletId !== undefined) {\n    updateData.outlet = { connect: { id: outletId } };\n  }\n  \n  // Handle order items separately if provided\n  if (orderItems && orderItems.length > 0) {\n    console.log('🔧 Processing', orderItems.length, 'order items');\n    updateData.orderItems = {\n      // Delete all existing order items\n      deleteMany: {},\n      // Create new order items\n      create: orderItems.map(item => ({\n        productId: item.productId,\n        quantity: item.quantity,\n        unitPrice: item.unitPrice,\n        totalPrice: item.totalPrice || (item.quantity * item.unitPrice),\n        deposit: item.deposit || 0,\n        notes: item.notes,\n        rentalDays: item.rentalDays\n      }))\n    }\n    console.log('🔧 Converted orderItems to nested write format');\n  }\n  \n  console.log('🔧 Final update data structure:', {\n    hasOrderItems: !!updateData.orderItems,\n    hasCustomer: !!updateData.customer,\n    hasOutlet: !!updateData.outlet\n  });\n  \n  const order = await prisma.order.update({\n    where: { id },\n    data: updateData,\n    include: orderInclude,\n  })\n\n  console.log('✅ Order updated successfully');\n  return transformOrder(order)\n}\n\nexport async function deleteOrder(id: number): Promise<boolean> {\n  try {\n    await prisma.order.delete({\n      where: { id },\n    })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport async function getOrderCount(outletId?: number, status?: string): Promise<number> {\n  const where: Prisma.OrderWhereInput = {}\n  if (outletId) where.outletId = outletId\n  if (status) where.status = status\n\n  return prisma.order.count({ where })\n}\n\nexport async function generateOrderNumber(outletId: number): Promise<string> {\n  const today = new Date()\n  const year = today.getFullYear()\n  const month = String(today.getMonth() + 1).padStart(2, '0')\n  const day = String(today.getDate()).padStart(2, '0')\n  \n  const prefix = `ORD-${year}${month}${day}`\n  \n  const latestOrder = await prisma.order.findFirst({\n    where: {\n      orderNumber: {\n        startsWith: prefix,\n      },\n      outletId,\n    },\n    orderBy: {\n      orderNumber: 'desc',\n    },\n    select: {\n      orderNumber: true,\n    },\n  })\n\n  let sequence = 1\n  if (latestOrder?.orderNumber) {\n    const lastSequence = parseInt(latestOrder.orderNumber.split('-').pop() || '0')\n    sequence = lastSequence + 1\n  }\n\n  return `${prefix}-${String(sequence).padStart(4, '0')}`\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\n// ============================================================================\n// LEGACY ORDER SEARCH (for backward compatibility)\n// ============================================================================\n\n/**\n * Search orders with filters (legacy function)\n * @deprecated Use simplifiedOrders.search instead\n */\nexport async function searchOrders(filters: OrderSearchFilter): Promise<OrderSearchResponse> {\n  \n  const {\n    q,\n    outletId,\n    customerId,\n    userId,\n    orderType,\n    status,\n    startDate,\n    endDate,\n    pickupDate,\n    returnDate,\n    limit = 20,\n    offset = 0\n  } = filters;\n\n  const where: any = {};\n\n  // Text search\n  if (q) {\n    where.OR = [\n      { orderNumber: { contains: q, mode: 'insensitive' } },\n      { customer: { firstName: { contains: q, mode: 'insensitive' } } },\n      { customer: { lastName: { contains: q, mode: 'insensitive' } } },\n      { customer: { phone: { contains: q, mode: 'insensitive' } } },\n    ];\n  }\n\n  // Filter by outlet\n  if (outletId) {\n    where.outletId = outletId;\n  }\n\n  // Filter by customer\n  if (customerId) {\n    where.customerId = customerId;\n  }\n\n  // Filter by user (created by)\n  if (userId) {\n    where.createdById = userId;  \n  }\n\n  // Filter by order type\n  if (orderType) {\n    where.orderType = orderType;\n  }\n\n  // Filter by status\n  if (status) {\n    where.status = status;\n  }\n\n  // Date filters\n  if (startDate || endDate) {\n    where.createdAt = {};\n    if (startDate) {\n      where.createdAt.gte = new Date(startDate);\n    }\n    if (endDate) {\n      where.createdAt.lte = new Date(endDate);\n    }\n  }\n\n  // Pickup date filter\n  if (pickupDate) {\n    where.pickupPlanAt = {\n      gte: new Date(pickupDate),\n      lt: new Date(new Date(pickupDate).getTime() + 24 * 60 * 60 * 1000)\n    };\n  }\n\n  // Return date filter\n  if (returnDate) {\n    where.returnPlanAt = {\n      gte: new Date(returnDate), \n      lt: new Date(new Date(returnDate).getTime() + 24 * 60 * 60 * 1000)\n    };\n  }\n\n  const [orders, total] = await Promise.all([\n    prisma.order.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset,\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        createdAt: true,\n        updatedAt: true,\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n          }\n        }\n      }\n    }),\n    prisma.order.count({ where })\n  ]);\n\n  const totalPages = Math.ceil(total / limit);\n  const page = Math.floor(offset / limit) + 1;\n\n  const transformedOrders: OrderSearchResult[] = orders.map(order => ({\n    id: order.id,\n    orderNumber: order.orderNumber,\n    orderType: order.orderType as any,\n    status: order.status as any,\n    totalAmount: order.totalAmount,\n    depositAmount: order.depositAmount,\n    pickupPlanAt: order.pickupPlanAt,\n    returnPlanAt: order.returnPlanAt,\n    pickedUpAt: order.pickedUpAt,\n    returnedAt: order.returnedAt,\n    isReadyToDeliver: false,\n    customer: order.customer ? {\n      id: order.customer.id,\n      firstName: order.customer.firstName,\n      lastName: order.customer.lastName,\n      email: order.customer.email,\n      phone: order.customer.phone || '',\n    } : null,\n    outlet: {\n      id: order.outlet?.id || 0,\n      name: order.outlet?.name || '',\n    },\n    orderItems: [],\n    createdAt: order.createdAt,\n    updatedAt: order.updatedAt,\n  }));\n\n  return {\n    success: true,\n    data: {\n      orders: transformedOrders,\n      total,\n      page,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n      totalPages\n    }\n  };\n}\n\nexport const simplifiedOrders = {\n  /**\n   * Find order by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.order.findUnique({\n      where: { id },\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { select: { id: true, name: true } },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          include: {\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Find order by order number (simplified API)\n   */\n  findByNumber: async (orderNumber: string) => {\n    return await prisma.order.findUnique({\n      where: { orderNumber },\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { \n          select: { \n            id: true, \n            name: true,\n            merchantId: true,\n            merchant: { select: { id: true, name: true } }\n          } \n        },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          include: {\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Create new order (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.order.create({\n      data,\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { select: { id: true, name: true } },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          include: {\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Update order (simplified API) - Now uses proper updateOrder function\n   */\n  update: async (id: number, data: any) => {\n    return await updateOrder(id, data);\n  },\n\n  /**\n   * Delete order (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.order.delete({\n      where: { id }\n    });\n  },\n\n  /**\n   * Search orders with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      where: whereClause, \n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause - start with provided where clause if any\n    const where: any = whereClause || {};\n    \n    // Handle merchant-level filtering (orders belong to outlets, outlets belong to merchants)\n    if (whereFilters.merchantId) {\n      where.outlet = {\n        merchantId: whereFilters.merchantId\n      };\n    }\n    \n    // Handle outlet-level filtering (overrides merchant filter if both are present)                                                                            \n    if (whereFilters.outletId) {\n      // Support both simple values and complex objects like { in: [...] }\n      where.outletId = whereFilters.outletId;\n    }\n    \n    if (whereFilters.customerId) where.customerId = whereFilters.customerId;\n    if (whereFilters.status) where.status = whereFilters.status;\n    if (whereFilters.orderType) where.orderType = whereFilters.orderType;\n    \n    // Filter by product (through order items)\n    if (whereFilters.productId) {\n      where.orderItems = {\n        some: {\n          productId: whereFilters.productId\n        }\n      };\n    }\n    \n    // Date range\n    if (whereFilters.startDate || whereFilters.endDate) {\n      where.createdAt = {};\n      if (whereFilters.startDate) where.createdAt.gte = whereFilters.startDate;\n      if (whereFilters.endDate) where.createdAt.lte = whereFilters.endDate;\n    }\n\n    // Text search\n    if (whereFilters.search) {\n      where.OR = [\n        { orderNumber: { contains: whereFilters.search } },\n        { customer: { firstName: { contains: whereFilters.search } } },\n        { customer: { lastName: { contains: whereFilters.search } } },\n        { customer: { phone: { contains: whereFilters.search } } }\n      ];\n    }\n\n    // ✅ Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'orderNumber') {\n      orderBy.orderNumber = sortOrder;\n    } else if (sortBy === 'totalAmount') {\n      orderBy.totalAmount = sortOrder;\n    } else if (sortBy === 'customer') {\n      orderBy.customer = { firstName: sortOrder };\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [orders, total] = await Promise.all([\n      // OPTIMIZED: Use select instead of include for better performance\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          pickupPlanAt: true,\n          returnPlanAt: true,\n          pickedUpAt: true,\n          returnedAt: true,\n          createdAt: true,\n          updatedAt: true,\n          customer: { \n            select: { \n              id: true, \n              firstName: true, \n              lastName: true, \n              phone: true, \n              email: true \n            } \n          },\n          outlet: { \n            select: { \n              id: true, \n              name: true,\n              merchant: { select: { id: true, name: true } }\n            } \n          },\n          createdBy: { \n            select: { \n              id: true, \n              firstName: true, \n              lastName: true \n            } \n          },\n          // OPTIMIZED: Count instead of loading all items\n          _count: {\n            select: {\n              orderItems: true,\n              payments: true\n            }\n          }\n        },\n        orderBy, // ✅ Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    console.log(`📊 db.orders.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, orders=${orders.length}`);\n\n    return {\n      data: orders,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Get order statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.order.count({ where });\n  },\n\n  /**\n   * Group orders by field (simplified API)\n   */\n  groupBy: async (args: any) => {\n    return await prisma.order.groupBy(args);\n  },\n\n  /**\n   * Aggregate orders (simplified API)\n   */\n  aggregate: async (args: any) => {\n    return await prisma.order.aggregate(args);\n  }\n};","import { prisma } from './client';\nimport type { Prisma } from '@prisma/client';\n\n/**\n * Create payment\n */\nexport async function createPayment(data: Prisma.PaymentCreateInput) {\n  return await prisma.payment.create({\n    data,\n    include: {\n      order: {\n        include: {\n          customer: { select: { firstName: true, lastName: true } },\n          outlet: { select: { name: true } }\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find payment by ID\n */\nexport async function findById(id: number) {\n  return await prisma.payment.findUnique({\n    where: { id },\n    include: {\n      order: {\n        include: {\n          customer: { select: { firstName: true, lastName: true } },\n          outlet: { select: { name: true } }\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find payments by subscription ID\n */\nexport async function findBySubscriptionId(subscriptionId: number, options: { limit?: number } = {}) {\n  const { limit = 20 } = options;\n  \n  return await prisma.payment.findMany({\n    where: { subscriptionId },\n    orderBy: { createdAt: 'desc' },\n    take: limit\n  });\n}\n\n/**\n * Search payments with pagination\n */\nexport async function searchPayments(filters: any) {\n  const { where, include, orderBy, take = 20, skip = 0 } = filters;\n  \n  const [payments, total] = await Promise.all([\n    prisma.payment.findMany({\n      where,\n      include,\n      orderBy,\n      take,\n      skip\n    }),\n    prisma.payment.count({ where })\n  ]);\n\n  return {\n    data: payments,\n    total,\n    page: Math.floor(skip / take) + 1,\n    limit: take,\n    hasMore: skip + take < total\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED PAYMENTS API\n// ============================================================================\n\nexport const simplifiedPayments = {\n  /**\n   * Create payment (simplified API)\n   */\n  create: createPayment,\n\n  /**\n   * Find payment by ID (simplified API)\n   */\n  findById,\n\n  /**\n   * Find payments by subscription ID (simplified API)\n   */\n  findBySubscriptionId,\n\n  /**\n   * Search payments (simplified API)\n   */\n  search: searchPayments,\n\n  /**\n   * Get payment statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.payment.count({ where });\n  },\n\n  /**\n   * Group payments by field (simplified API)\n   */\n  groupBy: async (args: any) => {\n    return await prisma.payment.groupBy(args);\n  },\n\n  /**\n   * Aggregate payments (simplified API)\n   */\n  aggregate: async (args: any) => {\n    return await prisma.payment.aggregate(args);\n  }\n};\n","// ============================================================================\n// OUTLET DATABASE FUNCTIONS\n// ============================================================================\n// This file contains outlet functions that use integer ID system:\n// - Input: id (number)\n// - Database: queries by id (integer), uses integer IDs for relationships\n// - Return: includes id (number)\n\nimport { prisma } from './client';\nimport type { \n  OutletCreateInput, \n  OutletUpdateInput, \n  OutletSearchFilter,\n  OutletSearchResponse \n} from '@rentalshop/types';\n\n// ============================================================================\n// OUTLET SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Search outlets - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchOutlets(filters: OutletSearchFilter): Promise<OutletSearchResponse> {\n  const {\n    merchantId,\n    outletId, // Add outletId filter for outlet-level users\n    isActive,\n    search,\n    page = 1,\n    limit = 20\n  } = filters;\n\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {};\n\n  if (merchantId) {\n    // Find merchant by id\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: merchantId },\n      select: { id: true }\n    });\n    \n    if (merchant) {\n      where.merchantId = merchant.id;\n    }\n  }\n\n  // Outlet-level filtering: Users can only see their assigned outlet\n  if (outletId) {\n    // Find outlet by id\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: outletId },\n      select: { id: true }\n    });\n    \n    if (outlet) {\n      where.id = outlet.id;\n    }\n  }\n\n  // Only filter by isActive if explicitly provided\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  }\n\n  if (search) {\n    where.OR = [\n      { name: { contains: search, mode: 'insensitive' } },\n      { address: { contains: search, mode: 'insensitive' } },\n      { description: { contains: search, mode: 'insensitive' } }\n    ];\n  }\n\n  // Get total count\n  const total = await prisma.outlet.count({ where });\n\n  // Get outlets with pagination\n  const outlets = await prisma.outlet.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    },\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: skip\n  });\n\n  // Transform to match expected types\n  const transformedOutlets = outlets.map((outlet: any) => ({\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    isDefault: outlet.isDefault || false,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  }));\n\n  return {\n    outlets: transformedOutlets,\n    total,\n    page,\n    limit,\n    totalPages: Math.ceil(total / limit),\n    hasMore: skip + limit < total,\n  };\n}\n\n/**\n * Get outlets by merchant - follows dual ID system\n */\nexport async function getOutletsByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const outlets = await prisma.outlet.findMany({\n    where: { merchantId: merchant.id },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  // Transform to match expected types\n  return outlets.map((outlet: any) => ({\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    isDefault: outlet.isDefault || false,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  }));\n}\n\n/**\n * Get outlet by public ID - follows dual ID system\n */\nexport async function getOutletByPublicId(id: number) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    }\n  });\n\n  if (!outlet) return null;\n\n  // Transform to match expected types\n  return {\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address,\n    phone: outlet.phone,\n    description: outlet.description,\n    isActive: outlet.isActive,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  };\n}\n\n/**\n * Create outlet - follows dual ID system\n */\nexport async function createOutlet(input: OutletCreateInput, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  // Generate unique id\n  const id = Math.floor(Math.random() * 1000000) + 100000;\n\n  const outlet = await prisma.outlet.create({\n    data: {\n      id,\n      name: input.name.trim(),\n      address: input.address?.trim(),\n      phone: input.phone?.trim(),\n      description: input.description?.trim(),\n      merchantId: merchant.id,\n      isActive: true\n    },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    }\n  });\n\n  // Transform to match expected types\n  return {\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  };\n}\n\n/**\n * Update outlet - follows dual ID system\n */\nexport async function updateOutlet(id: number, input: OutletUpdateInput) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: { id: true, merchantId: true, name: true, isDefault: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${id} not found`);\n  }\n\n  // Prevent disabling default outlets\n  if (outlet.isDefault && input.isActive === false) {\n    throw new Error('Default outlet cannot be disabled');\n  }\n\n  const updatedOutlet = await prisma.outlet.update({\n    where: { id: outlet.id },\n    data: {\n      ...(input.name !== undefined && { name: input.name.trim() }),\n      ...(input.address !== undefined && { address: input.address?.trim() }),\n      ...(input.phone !== undefined && { phone: input.phone?.trim() }),\n      ...(input.city !== undefined && { city: input.city?.trim() }),\n      ...(input.state !== undefined && { state: input.state?.trim() }),\n      ...(input.zipCode !== undefined && { zipCode: input.zipCode?.trim() }),\n      ...(input.country !== undefined && { country: input.country?.trim() }),\n      ...(input.description !== undefined && { description: input.description?.trim() }),\n      ...(input.isActive !== undefined && { isActive: input.isActive })\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    }\n  });\n\n  // Transform to match expected types\n  return {\n    id: updatedOutlet.id, // Return id as \"id\" to frontend\n    name: updatedOutlet.name,\n    address: updatedOutlet.address || undefined,\n    phone: updatedOutlet.phone || undefined,\n    city: (updatedOutlet as any).city || undefined,\n    state: (updatedOutlet as any).state || undefined,\n    zipCode: (updatedOutlet as any).zipCode || undefined,\n    country: (updatedOutlet as any).country || undefined,\n    description: updatedOutlet.description || undefined,\n    isActive: updatedOutlet.isActive,\n    createdAt: updatedOutlet.createdAt,\n    updatedAt: updatedOutlet.updatedAt,\n    merchantId: updatedOutlet.merchant.id, // Return merchant id\n    merchant: {\n      id: updatedOutlet.merchant.id,\n      name: updatedOutlet.merchant.name\n    }\n  };\n}\n\n/**\n * Delete outlet - follows dual ID system\n */\nexport async function deleteOutlet(id: number) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${id} not found`);\n  }\n\n  await prisma.outlet.delete({\n    where: { id: outlet.id }\n  });\n\n  return { success: true };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedOutlets = {\n  /**\n   * Find outlet by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.outlet.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        _count: {\n          select: { \n            users: true,\n            orders: true,\n            products: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new outlet (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('🔍 simplifiedOutlets.create called with data:', data);\n      \n      // Validate that merchant exists if merchant connection is provided\n      if (data.merchant && data.merchant.connect && data.merchant.connect.id) {\n        const merchantId = data.merchant.connect.id;\n        const merchant = await prisma.merchant.findUnique({\n          where: { id: merchantId },\n          select: { id: true }\n        });\n        \n        if (!merchant) {\n          throw new Error(`Merchant with id ${merchantId} not found`);\n        }\n        \n        console.log('✅ Merchant found:', merchant);\n      }\n      \n      const outlet = await prisma.outlet.create({\n        data,\n        include: {\n          merchant: { select: { id: true, name: true } }\n        }\n      });\n      \n      console.log('✅ Outlet created successfully:', outlet);\n      return outlet;\n    } catch (error) {\n      console.error('❌ Error in simplifiedOutlets.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update outlet (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.outlet.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Find first outlet matching criteria (simplified API)\n   */\n  findFirst: async (where: any) => {\n    return await prisma.outlet.findFirst({\n      where,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        _count: {\n          select: { \n            users: true,\n            orders: true,\n            products: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get outlet statistics (simplified API)\n   */\n  getStats: async (options: any) => {\n    return await prisma.outlet.count(options.where);\n  },\n\n  /**\n   * Update multiple outlets (simplified API)\n   */\n  updateMany: async (where: any, data: any) => {\n    return await prisma.outlet.updateMany({\n      where,\n      data\n    });\n  },\n\n  /**\n   * Search outlets with pagination (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc', ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    console.log('🔍 DB outlet.search - Received filters:', filters);\n    console.log('🔍 DB outlet.search - whereFilters:', whereFilters);\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.outletId) where.id = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.status) where.status = whereFilters.status;\n    \n    // Text search across multiple fields - ONLY search by name\n    const searchTerm = whereFilters.search?.trim();\n    console.log('🔍 DB outlet.search - searchTerm:', searchTerm, 'length:', searchTerm?.length);\n    \n    if (searchTerm && searchTerm.length > 0) {\n      where.name = { \n        contains: searchTerm, \n        mode: 'insensitive' \n      };\n      console.log('✅ DB outlet.search - Added name filter:', where.name);\n    } else {\n      console.log('⚠️ DB outlet.search - No search term, will return all outlets for this merchant');\n    }\n    \n    console.log('🔍 DB outlet.search - Final where clause:', JSON.stringify(where, null, 2));\n\n    // Specific field filters (not used in current implementation)\n    if (whereFilters.name) where.name = { contains: whereFilters.name, mode: 'insensitive' };\n    if (whereFilters.address) where.address = { contains: whereFilters.address, mode: 'insensitive' };\n    if (whereFilters.phone) where.phone = { contains: whereFilters.phone, mode: 'insensitive' };\n\n    // Build orderBy based on sortBy and sortOrder\n    const orderBy: any = {};\n    if (sortBy === 'name' || sortBy === 'createdAt' || sortBy === 'updatedAt') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      orderBy.createdAt = 'desc'; // Default\n    }\n\n    const [outlets, total] = await Promise.all([\n      prisma.outlet.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          _count: {\n            select: { \n              users: true,\n              orders: true\n            }\n          }\n        },\n        orderBy,\n        skip,\n        take: limit\n      }),\n      prisma.outlet.count({ where })\n    ]);\n\n    console.log(`📊 db.outlets.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, outlets=${outlets.length}`);\n\n    return {\n      data: outlets,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.outlet.count({ where });\n  }\n};\n","// ============================================================================\n// PLAN DATABASE FUNCTIONS - MODERN SUBSCRIPTION SYSTEM\n// ============================================================================\n\nimport { prisma } from './client';\nimport type { Plan, PlanCreateInput, PlanUpdateInput, PlanFilters } from '@rentalshop/types';\nimport { calculatePlanPricing } from './subscription';\n\n/**\n * Helper function to generate pricing object for a plan\n */\nfunction generatePlanPricing(basePrice: number) {\n  return {\n    monthly: {\n      price: basePrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: basePrice * 3 * 0.95, // 5% discount for quarterly\n      discount: 5,\n      savings: basePrice * 3 * 0.05\n    },\n    yearly: {\n      price: basePrice * 12 * 0.85, // 15% discount for yearly\n      discount: 15,\n      savings: basePrice * 12 * 0.15\n    }\n  };\n}\n\n/**\n * Get plan by public ID\n */\nexport async function getPlanById(id: number): Promise<Plan | null> {\n  try {\n    const plan = await prisma.plan.findUnique({\n      where: { id }\n    });\n\n    if (!plan) return null;\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error getting plan by public ID:', error);\n    throw error;\n  }\n}\n\n/**\n * Get all plans\n */\nexport async function getAllPlans(): Promise<Plan[]> {\n  try {\n    const plans = await prisma.plan.findMany({\n      where: { isActive: true },\n      orderBy: { sortOrder: 'asc' }\n    });\n\n    return plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Error getting all plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Search plans with filters\n */\nexport async function searchPlans(filters: PlanFilters = {}): Promise<{ plans: Plan[]; total: number; hasMore: boolean }> {\n  try {\n    const where: any = {};\n\n    // Apply filters\n    if (filters.search) {\n      where.OR = [\n        { name: { contains: filters.search, mode: 'insensitive' } },\n        { description: { contains: filters.search, mode: 'insensitive' } }\n      ];\n    }\n\n    if (filters.isActive !== undefined) {\n      where.isActive = filters.isActive;\n    }\n\n    if (filters.isPopular !== undefined) {\n      where.isPopular = filters.isPopular;\n    }\n\n    // Get total count\n    const total = await prisma.plan.count({ where });\n\n    // Get plans with pagination\n    const plans = await prisma.plan.findMany({\n      where,\n      orderBy: { sortOrder: 'asc' },\n      take: filters.limit || 20,\n      skip: filters.offset || 0\n    });\n\n    const transformedPlans = plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n\n    return {\n      plans: transformedPlans,\n      total,\n      hasMore: (filters.offset || 0) + (filters.limit || 20) < total\n    };\n  } catch (error) {\n    console.error('Error searching plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Create a new plan\n */\nexport async function createPlan(data: PlanCreateInput): Promise<Plan> {\n  try {\n    const plan = await prisma.plan.create({\n      data: {\n        name: data.name,\n        description: data.description,\n        basePrice: data.basePrice,\n        currency: data.currency || 'USD',\n        trialDays: data.trialDays,\n        limits: JSON.stringify(data.limits),\n        features: JSON.stringify(data.features),\n        isActive: data.isActive ?? true,\n        isPopular: data.isPopular ?? false,\n        sortOrder: data.sortOrder ?? 0\n      }\n    });\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error creating plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Update a plan\n */\nexport async function updatePlan(id: number, data: PlanUpdateInput): Promise<Plan | null> {\n  try {\n    const plan = await prisma.plan.update({\n      where: { id },\n      data: {\n        ...(data.name && { name: data.name }),\n        ...(data.description && { description: data.description }),\n        ...(data.basePrice && { basePrice: data.basePrice }),\n        ...(data.currency && { currency: data.currency }),\n        ...(data.trialDays && { trialDays: data.trialDays }),\n        ...(data.limits && {\n          limits: JSON.stringify(data.limits)\n        }),\n        ...(data.features && { features: JSON.stringify(data.features) }),\n        ...(data.isActive !== undefined && { isActive: data.isActive }),\n        ...(data.isPopular !== undefined && { isPopular: data.isPopular }),\n        ...(data.sortOrder !== undefined && { sortOrder: data.sortOrder })\n      }\n    });\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error updating plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Delete a plan (soft delete)\n */\nexport async function deletePlan(id: number): Promise<boolean> {\n  try {\n    await prisma.plan.update({\n      where: { id },\n      data: { \n        isActive: false,\n        deletedAt: new Date()\n      }\n    });\n    return true;\n  } catch (error) {\n    console.error('Error deleting plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Get active plans\n */\nexport async function getActivePlans(): Promise<Plan[]> {\n  try {\n    const plans = await prisma.plan.findMany({\n      where: { \n        isActive: true,\n        deletedAt: null\n      },\n      orderBy: { sortOrder: 'asc' }\n    });\n\n    return plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Error getting active plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Get plan statistics\n */\nexport async function getPlanStats() {\n  try {\n    const [totalPlans, activePlans, popularPlans] = await Promise.all([\n      prisma.plan.count(),\n      prisma.plan.count({ where: { isActive: true } }),\n      prisma.plan.count({ where: { isPopular: true } })\n    ]);\n\n    return {\n      totalPlans,\n      activePlans,\n      popularPlans\n    };\n  } catch (error) {\n    console.error('Error getting plan stats:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedPlans = {\n  /**\n   * Find plan by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.plan.findUnique({\n      where: { id }\n    });\n  },\n\n  /**\n   * Create new plan (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.plan.create({\n      data\n    });\n  },\n\n  /**\n   * Update plan (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.plan.update({\n      where: { id },\n      data\n    });\n  },\n\n  /**\n   * Delete plan (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.plan.delete({\n      where: { id }\n    });\n  },\n\n  /**\n   * Search plans with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.isPopular !== undefined) where.isPopular = whereFilters.isPopular;\n    \n    // Text search\n    if (whereFilters.search) {\n      where.OR = [\n        { name: { contains: whereFilters.search } },\n        { description: { contains: whereFilters.search } }\n      ];\n    }\n\n    // Price range\n    if (whereFilters.minPrice !== undefined || whereFilters.maxPrice !== undefined) {\n      where.basePrice = {};\n      if (whereFilters.minPrice !== undefined) where.basePrice.gte = whereFilters.minPrice;\n      if (whereFilters.maxPrice !== undefined) where.basePrice.lte = whereFilters.maxPrice;\n    }\n\n    const [plans, total] = await Promise.all([\n      prisma.plan.findMany({\n        where,\n        orderBy: { sortOrder: 'asc' },\n        skip,\n        take: limit\n      }),\n      prisma.plan.count({ where })\n    ]);\n\n    return {\n      data: plans,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  /**\n   * Get plan statistics (simplified API)\n   */\n  getStats: async () => {\n    const [totalPlans, activePlans, popularPlans] = await Promise.all([\n      prisma.plan.count(),\n      prisma.plan.count({ where: { isActive: true } }),\n      prisma.plan.count({ where: { isPopular: true } })\n    ]);\n\n    return {\n      totalPlans,\n      activePlans,\n      popularPlans\n    };\n  }\n};","// ============================================================================\n// SIMPLIFIED SUBSCRIPTION DATABASE FUNCTIONS\n// ============================================================================\n\nimport { prisma } from './client';\nimport { calculateSubscriptionPrice, getPricingBreakdown } from '@rentalshop/utils';\nimport type { \n  Subscription, \n  Plan, \n  PlanLimits,\n  SubscriptionCreateInput, \n  SubscriptionUpdateInput,\n  SubscriptionStatus,\n  BillingInterval\n} from '@rentalshop/types';\n\n// ============================================================================\n// PRICING UTILITIES\n// ============================================================================\n\n/**\n * Generate pricing object from base price\n */\nfunction generatePricingFromBasePrice(basePrice: number) {\n  const monthlyPrice = basePrice;\n  const quarterlyPrice = monthlyPrice * 3;\n  const yearlyPrice = monthlyPrice * 12;\n  \n  return {\n    monthly: {\n      price: monthlyPrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: quarterlyPrice,\n      discount: 5, // 5% discount for quarterly\n      savings: quarterlyPrice * 0.05\n    },\n    yearly: {\n      price: yearlyPrice,\n      discount: 15, // 15% discount for yearly\n      savings: yearlyPrice * 0.15\n    }\n  };\n}\n\n/**\n * Convert Prisma plan object to our Plan type\n */\nfunction convertPrismaPlanToPlan(prismaPlan: any): Plan {\n  return {\n    id: prismaPlan.id,\n    name: prismaPlan.name,\n    description: prismaPlan.description,\n    basePrice: prismaPlan.basePrice,\n    currency: prismaPlan.currency,\n    trialDays: prismaPlan.trialDays,\n    limits: JSON.parse(prismaPlan.limits as string) as PlanLimits,\n    features: JSON.parse(prismaPlan.features as string) as string[],\n    isActive: prismaPlan.isActive,\n    isPopular: prismaPlan.isPopular,\n    sortOrder: prismaPlan.sortOrder,\n    pricing: generatePricingFromBasePrice(prismaPlan.basePrice),\n    createdAt: prismaPlan.createdAt,\n    updatedAt: prismaPlan.updatedAt,\n    deletedAt: prismaPlan.deletedAt || undefined\n  };\n}\n\n/**\n * Helper function to generate pricing object for a plan\n */\nfunction generatePlanPricing(basePrice: number) {\n  return {\n    monthly: {\n      price: basePrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: basePrice * 3 * 0.95, // 5% discount for quarterly\n      discount: 5,\n      savings: basePrice * 3 * 0.05\n    },\n    yearly: {\n      price: basePrice * 12 * 0.85, // 15% discount for yearly\n      discount: 15,\n      savings: basePrice * 12 * 0.15\n    }\n  };\n}\n\n/**\n * Helper function to transform database plan to Plan type\n */\nfunction transformPlanFromDb(plan: any): Plan {\n  return {\n    id: plan.id,\n    name: plan.name,\n    description: plan.description,\n    basePrice: plan.basePrice,\n    currency: plan.currency,\n    trialDays: plan.trialDays,\n    limits: typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits,\n    features: typeof plan.features === 'string' ? JSON.parse(plan.features) : plan.features,\n    isActive: plan.isActive,\n    isPopular: plan.isPopular,\n    sortOrder: plan.sortOrder,\n    pricing: generatePlanPricing(plan.basePrice),\n    createdAt: plan.createdAt,\n    updatedAt: plan.updatedAt,\n    ...(plan.deletedAt && { deletedAt: plan.deletedAt })\n  };\n}\n\nexport function calculatePlanPricing(plan: Plan): Record<BillingInterval, number> {\n  const pricing: Record<BillingInterval, number> = {} as any;\n  \n  const intervals: BillingInterval[] = ['month', 'quarter', 'semiAnnual', 'year'];\n  \n  for (const interval of intervals) {\n    pricing[interval] = calculateSubscriptionPrice(plan, interval);\n  }\n  \n  return pricing;\n}\n\nexport function calculatePeriodEnd(startDate: Date, billingInterval: BillingInterval): Date {\n  const endDate = new Date(startDate);\n  \n  switch (billingInterval) {\n    case 'month':\n      endDate.setMonth(endDate.getMonth() + 1);\n      break;\n    case 'quarter':\n      endDate.setMonth(endDate.getMonth() + 3);\n      break;\n    case 'semiAnnual':\n      endDate.setMonth(endDate.getMonth() + 6);\n      break;\n    case 'year':\n      endDate.setFullYear(endDate.getFullYear() + 1);\n      break;\n    default:\n      endDate.setMonth(endDate.getMonth() + 1);\n  }\n  \n  return endDate;\n}\n\n// ============================================================================\n// SUBSCRIPTION QUERIES\n// ============================================================================\n\nexport async function getSubscriptionByMerchantId(merchantId: number): Promise<Subscription | null> {\n  // Find the merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    return null;\n  }\n  \n  const subscription = await prisma.subscription.findUnique({\n    where: { merchantId: merchant.id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  if (!subscription) return null;\n\n  return {\n    id: subscription.id,\n    merchantId: subscription.merchantId,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    merchant: subscription.merchant,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\nexport async function getAllSubscriptions(): Promise<Subscription[]> {\n  const subscriptions = await prisma.subscription.findMany({\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    },\n    orderBy: { createdAt: 'desc' }\n  });\n\n  return subscriptions.map((sub: any) => ({\n    id: sub.id,\n    merchantId: sub.merchantId,\n    planId: sub.planId,\n    status: sub.status as SubscriptionStatus,\n    billingInterval: sub.interval as BillingInterval,\n    currentPeriodStart: sub.currentPeriodStart,\n    currentPeriodEnd: sub.currentPeriodEnd,\n    amount: sub.amount,\n    createdAt: sub.createdAt,\n    updatedAt: sub.updatedAt,\n    merchant: sub.merchant,\n    plan: convertPrismaPlanToPlan(sub.plan)\n  }));\n}\n\n// ============================================================================\n// SUBSCRIPTION SEARCH\n// ============================================================================\n\nexport async function searchSubscriptions(filters: {\n  merchantId?: number;\n  planId?: number;\n  status?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  offset?: number;\n}): Promise<{ subscriptions: Subscription[]; total: number; hasMore: boolean }> {\n  const where: any = {};\n\n  // Apply filters\n  if (filters.merchantId) {\n    where.merchantId = filters.merchantId;\n  }\n\n  if (filters.planId) {\n    where.planId = filters.planId;\n  }\n\n  if (filters.status) {\n    where.status = filters.status;\n  }\n\n  if (filters.startDate || filters.endDate) {\n    where.currentPeriodStart = {};\n    if (filters.startDate) where.currentPeriodStart.gte = filters.startDate;\n    if (filters.endDate) where.currentPeriodStart.lte = filters.endDate;\n  }\n\n  // Get total count\n  const total = await prisma.subscription.count({ where });\n\n  // Get subscriptions with pagination\n  const subscriptions = await prisma.subscription.findMany({\n    where,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    },\n    orderBy: { createdAt: 'desc' },\n    take: filters.limit || 20,\n    skip: filters.offset || 0\n  });\n\n  const hasMore = (filters.offset || 0) + (filters.limit || 20) < total;\n\n  return {\n    subscriptions: subscriptions.map((sub: any) => ({\n      id: sub.id,\n      merchantId: sub.merchantId,\n      planId: sub.planId,\n      status: sub.status as SubscriptionStatus,\n      billingInterval: sub.interval as BillingInterval,\n      currentPeriodStart: sub.currentPeriodStart,\n      currentPeriodEnd: sub.currentPeriodEnd,\n      amount: sub.amount,\n      createdAt: sub.createdAt,\n      updatedAt: sub.updatedAt,\n      merchant: sub.merchant,\n      plan: {\n        id: sub.plan.id,\n        name: sub.plan.name,\n        description: sub.plan.description,\n        basePrice: sub.plan.basePrice,\n        currency: sub.plan.currency,\n        trialDays: sub.plan.trialDays,\n        limits: JSON.parse(sub.plan.limits as string) as PlanLimits,\n        features: JSON.parse(sub.plan.features as string) as string[],\n        isActive: sub.plan.isActive,\n        isPopular: sub.plan.isPopular,\n        sortOrder: sub.plan.sortOrder,\n        pricing: generatePricingFromBasePrice(sub.plan.basePrice),\n        createdAt: sub.plan.createdAt,\n        updatedAt: sub.plan.updatedAt\n      }\n    })),\n    total,\n    hasMore\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION MUTATIONS\n// ============================================================================\n\nexport async function createSubscription(data: SubscriptionCreateInput): Promise<Subscription> {\n  // Get merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: data.merchantId }\n  });\n\n  if (!merchant) {\n    throw new Error('Merchant not found');\n  }\n\n  // Get plan by id\n  const plan = await prisma.plan.findUnique({\n    where: { id: data.planId }\n  });\n\n  if (!plan) {\n    throw new Error('Plan not found');\n  }\n\n  // Check if merchant already has a subscription\n  const existingSubscription = await prisma.subscription.findUnique({\n    where: { merchantId: merchant.id }\n  });\n\n  if (existingSubscription) {\n    throw new Error('Merchant already has a subscription');\n  }\n\n  // Calculate pricing based on billing interval\n  const billingInterval = data.billingInterval || 'month';\n  const convertedPlan = convertPrismaPlanToPlan(plan);\n  const amount = calculateSubscriptionPrice(convertedPlan, billingInterval);\n  \n  // Calculate dates\n  const startDate = data.startDate || new Date();\n  const currentPeriodEnd = calculatePeriodEnd(startDate, billingInterval);\n\n  const subscription = await prisma.subscription.create({\n    data: {\n      merchantId: merchant.id,\n      planId: plan.id,\n      status: data.status || 'trial',\n      interval: billingInterval,\n      currentPeriodStart: startDate,\n      currentPeriodEnd: currentPeriodEnd,\n      amount: amount\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  // Update merchant subscription status\n  await prisma.merchant.update({\n    where: { id: merchant.id },\n    data: {\n      // // subscriptionStatus: (removed - use subscription.status) (removed - use subscription.status) subscription.status\n    }\n  });\n\n  return {\n    id: subscription.id,\n    merchantId: subscription.merchantId,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    merchant: subscription.merchant,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\n// ============================================================================\n// PLAN FUNCTIONS\n// ============================================================================\n\nexport async function getAllPlans(): Promise<Plan[]> {\n  const plans = await prisma.plan.findMany({\n    where: { isActive: true },\n    orderBy: { sortOrder: 'asc' }\n  });\n\n  return plans.map((plan: any) => convertPrismaPlanToPlan(plan));\n}\n\nexport async function getPlanById(planId: number): Promise<Plan | null> {\n  const plan = await prisma.plan.findUnique({\n    where: { id: planId }\n  });\n\n  if (!plan) return null;\n\n  return {\n    id: plan.id,\n    name: plan.name,\n    description: plan.description,\n    basePrice: plan.basePrice,\n    currency: plan.currency,\n    trialDays: plan.trialDays,\n    limits: JSON.parse(plan.limits as string) as PlanLimits,\n    features: JSON.parse(plan.features as string) as string[],\n    isActive: plan.isActive,\n    isPopular: plan.isPopular,\n    sortOrder: plan.sortOrder,\n    pricing: generatePricingFromBasePrice(plan.basePrice),\n    createdAt: plan.createdAt,\n    updatedAt: plan.updatedAt,\n    deletedAt: plan.deletedAt || undefined\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION ACTIONS\n// ============================================================================\n\nexport async function changePlan(\n  subscriptionId: number, \n  newPlanId: number, \n  billingInterval: BillingInterval = 'month'\n): Promise<Subscription> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const plan = await prisma.plan.findUnique({\n    where: { id: newPlanId }\n  });\n\n  if (!plan) {\n    throw new Error('Plan not found');\n  }\n\n  const convertedPlan = convertPrismaPlanToPlan(plan);\n  const amount = calculateSubscriptionPrice(convertedPlan, billingInterval);\n\n  // Calculate new period dates based on billing interval\n  const now = new Date();\n  const newPeriodStart = now;\n  \n  // Calculate period duration in days based on billing interval\n  const getPeriodDays = (interval: BillingInterval): number => {\n    switch (interval) {\n      case 'month': return 30;\n      case 'quarter': return 90;\n      case 'semiAnnual': return 180;\n      case 'year': return 365;\n      default: return 30;\n    }\n  };\n  \n  const periodDays = getPeriodDays(billingInterval);\n  const newPeriodEnd = new Date(now.getTime() + periodDays * 24 * 60 * 60 * 1000);\n\n  const updatedSubscription = await prisma.subscription.update({\n    where: { merchantId: subscription.merchantId },\n    data: {\n      planId: plan.id,\n      interval: billingInterval,\n      amount: amount,\n      currentPeriodStart: newPeriodStart,\n      currentPeriodEnd: newPeriodEnd,\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  // No need to update merchant - subscription.status is the single source of truth\n\n  return {\n    id: updatedSubscription.id,\n    merchantId: updatedSubscription.merchantId,\n    planId: updatedSubscription.planId,\n    status: updatedSubscription.status as SubscriptionStatus,\n    billingInterval: updatedSubscription.interval as BillingInterval,\n    currentPeriodStart: updatedSubscription.currentPeriodStart,\n    currentPeriodEnd: updatedSubscription.currentPeriodEnd,\n    amount: updatedSubscription.amount,\n    createdAt: updatedSubscription.createdAt,\n    updatedAt: updatedSubscription.updatedAt,\n    // Enhanced subscription period information\n    subscriptionPeriod: {\n      startDate: updatedSubscription.currentPeriodStart,\n      endDate: updatedSubscription.currentPeriodEnd,\n      duration: updatedSubscription.interval,\n      isActive: updatedSubscription.status === 'active',\n      daysRemaining: Math.ceil((updatedSubscription.currentPeriodEnd.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)),\n      nextBillingDate: updatedSubscription.currentPeriodEnd\n    },\n    merchant: updatedSubscription.merchant,\n    plan: convertPrismaPlanToPlan(updatedSubscription.plan)\n  };\n}\n\nexport async function pauseSubscription(subscriptionId: number): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: 'paused',\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    merchantId: subscription.merchantId,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    merchant: subscription.merchant,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\nexport async function resumeSubscription(subscriptionId: number): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: 'active',\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    merchantId: subscription.merchantId,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    merchant: subscription.merchant,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\nexport async function cancelSubscription(subscriptionId: number): Promise<{ success: boolean; message: string; data?: Subscription; statusCode?: number }> {\n  try {\n    const subscription = await prisma.subscription.update({\n      where: { id: subscriptionId },\n      data: {\n        status: 'cancelled',\n        updatedAt: new Date()\n      },\n      include: {\n        merchant: {\n          select: {\n      id: true,\n            name: true,\n            email: true,\n          }\n        },\n        plan: true\n      }\n    });\n\n    const result: Subscription = {\n      id: subscription.id,\n      merchantId: subscriptionId,\n      planId: subscription.planId,\n      status: subscription.status as SubscriptionStatus,\n      billingInterval: subscription.interval as BillingInterval,\n      currentPeriodStart: subscription.currentPeriodStart,\n      currentPeriodEnd: subscription.currentPeriodEnd,\n      amount: subscription.amount,\n      createdAt: subscription.createdAt,\n      updatedAt: subscription.updatedAt,\n      merchant: subscription.merchant,\n      plan: {\n        id: subscription.plan.id,\n        name: subscription.plan.name,\n        description: subscription.plan.description,\n        basePrice: subscription.plan.basePrice,\n        currency: subscription.plan.currency,\n        trialDays: subscription.plan.trialDays,\n        limits: JSON.parse(subscription.plan.limits as string) as PlanLimits,\n        features: JSON.parse(subscription.plan.features as string) as string[],\n        isActive: subscription.plan.isActive,\n        isPopular: subscription.plan.isPopular,\n        sortOrder: subscription.plan.sortOrder,\n        pricing: generatePricingFromBasePrice(subscription.plan.basePrice),\n        createdAt: subscription.plan.createdAt,\n        updatedAt: subscription.plan.updatedAt\n      }\n    };\n\n    return {\n      success: true,\n      message: 'Subscription cancelled successfully',\n      data: result\n    };\n  } catch (error) {\n    console.error('Error cancelling subscription:', error);\n    return {\n      success: false,\n      message: 'Failed to cancel subscription',\n      statusCode: 500\n    };\n  }\n}\n\n// ============================================================================\n// SUBSCRIPTION RENEWAL FUNCTIONS\n// ============================================================================\n\nexport async function getExpiredSubscriptions(): Promise<Subscription[]> {\n  const now = new Date();\n  \n  const subscriptions = await prisma.subscription.findMany({\n    where: {\n      currentPeriodEnd: {\n        lt: now\n      },\n      status: {\n        in: ['active', 'trial']\n      }\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    },\n    orderBy: { currentPeriodEnd: 'asc' }\n  });\n\n  return subscriptions.map((sub: any) => ({\n    id: sub.id,\n    merchantId: sub.merchantId,\n    planId: sub.planId,\n    status: sub.status as SubscriptionStatus,\n    billingInterval: sub.interval as BillingInterval,\n    currentPeriodStart: sub.currentPeriodStart,\n    currentPeriodEnd: sub.currentPeriodEnd,\n    amount: sub.amount,\n    createdAt: sub.createdAt,\n    updatedAt: sub.updatedAt,\n    merchant: sub.merchant,\n    plan: convertPrismaPlanToPlan(sub.plan)\n  }));\n}\n\nexport async function getSubscriptionById(id: number): Promise<Subscription | null> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  if (!subscription) return null;\n\n  return {\n    id: subscription.id,\n    merchantId: subscription.merchantId,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    merchant: subscription.merchant,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\nexport async function updateSubscription(\n  subscriptionId: number, \n  data: Partial<{\n    status: SubscriptionStatus;\n    currentPeriodStart: Date;\n    currentPeriodEnd: Date;\n    amount: number;\n  }>\n): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      ...data,\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    merchantId: subscription.merchantId,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    merchant: subscription.merchant,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION PAYMENT FUNCTIONS\n// ============================================================================\n\nexport interface SubscriptionPaymentCreateInput {\n  subscriptionId: number;\n  amount: number;\n  currency: string;\n  method: string;\n  status: string;\n  transactionId: string;\n  description?: string;\n  failureReason?: string;\n}\n\nexport interface SubscriptionPayment {\n  id: number;\n  subscriptionId: number;\n  amount: number;\n  currency: string;\n  method: string;\n  status: string;\n  transactionId: string;\n  description?: string;\n  failureReason?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport async function createSubscriptionPayment(data: SubscriptionPaymentCreateInput): Promise<SubscriptionPayment> {\n  // Find subscription by id\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: data.subscriptionId },\n    select: { id: true }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const payment = await prisma.payment.create({\n    data: {\n      subscriptionId: subscription.id,\n      amount: data.amount,\n      currency: data.currency,\n      method: data.method,\n      type: 'SUBSCRIPTION',\n      status: data.status,\n      transactionId: data.transactionId,\n      description: data.description,\n      failureReason: data.failureReason\n    }\n  });\n\n  return {\n    id: payment.id,\n    subscriptionId: data.subscriptionId,\n    amount: payment.amount,\n    currency: payment.currency,\n    method: payment.method,\n    status: payment.status,\n    transactionId: payment.transactionId || '',\n    description: payment.description || undefined,\n    failureReason: payment.failureReason || undefined,\n    createdAt: payment.createdAt,\n    updatedAt: payment.updatedAt\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION PAYMENT HISTORY\n// ============================================================================\n\n/**\n * Get payment history for a subscription\n * @param subscriptionId - Subscription ID\n * @param filters - Optional filters for payments\n * @returns Payment history with pagination\n */\nexport async function getSubscriptionPaymentHistory(\n  subscriptionId: number,\n  filters?: {\n    status?: string;\n    method?: string;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n    offset?: number;\n  }\n): Promise<{\n  payments: SubscriptionPayment[];\n  total: number;\n  hasMore: boolean;\n}> {\n  const where: any = {\n    subscriptionId,\n    type: 'SUBSCRIPTION'\n  };\n\n  // Apply filters\n  if (filters?.status) {\n    where.status = filters.status.toUpperCase();\n  }\n\n  if (filters?.method) {\n    where.method = filters.method.toUpperCase();\n  }\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {};\n    if (filters.startDate) where.createdAt.gte = filters.startDate;\n    if (filters.endDate) where.createdAt.lte = filters.endDate;\n  }\n\n  const limit = filters?.limit || 20;\n  const offset = filters?.offset || 0;\n\n  // Get total count and payments\n  const [total, payments] = await Promise.all([\n    prisma.payment.count({ where }),\n    prisma.payment.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset\n    })\n  ]);\n\n  const hasMore = offset + limit < total;\n\n  return {\n    payments: payments.map(p => ({\n      id: p.id,\n      subscriptionId: subscriptionId,\n      amount: p.amount,\n      currency: p.currency,\n      method: p.method,\n      status: p.status,\n      transactionId: p.transactionId || '',\n      description: p.description || undefined,\n      failureReason: p.failureReason || undefined,\n      createdAt: p.createdAt,\n      updatedAt: p.updatedAt\n    })),\n    total,\n    hasMore\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION RENEWAL\n// ============================================================================\n\n/**\n * Renew subscription for another month with payment\n * @param subscriptionId - Subscription ID\n * @param paymentData - Payment information\n * @returns Updated subscription and payment record\n */\nexport async function renewSubscription(\n  subscriptionId: number,\n  paymentData: {\n    method: 'STRIPE' | 'TRANSFER';\n    transactionId: string;\n    reference?: string;\n    description?: string;\n  }\n): Promise<{\n  subscription: Subscription;\n  payment: SubscriptionPayment;\n}> {\n  // 1. Get subscription with merchant\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId },\n    include: {\n      merchant: true,\n      plan: true\n    }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  // 2. Validate subscription can be renewed\n  if (subscription.status === 'cancelled') {\n    throw new Error('Cannot renew cancelled subscription');\n  }\n\n  // 3. Calculate new period (extend by 1 month)\n  const newPeriodStart = subscription.currentPeriodEnd;\n  const newPeriodEnd = calculatePeriodEnd(newPeriodStart, 'month');\n\n  // 4. Use database transaction to ensure atomicity\n  const result = await prisma.$transaction(async (tx) => {\n    // Create payment record\n    const payment = await tx.payment.create({\n      data: {\n        subscriptionId: subscription.id,\n        merchantId: subscriptionId,\n        amount: subscription.amount,\n        currency: subscription.currency,\n        method: paymentData.method,\n        type: 'SUBSCRIPTION',\n        status: paymentData.method === 'STRIPE' ? 'COMPLETED' : 'PENDING',\n        transactionId: paymentData.transactionId,\n        reference: paymentData.reference,\n        description: paymentData.description || `Monthly subscription renewal - ${new Date().toLocaleDateString()}`,\n        processedAt: paymentData.method === 'STRIPE' ? new Date() : null\n      }\n    });\n\n    // Update subscription period\n    const updatedSubscription = await tx.subscription.update({\n      where: { merchantId: subscription.merchantId },\n      data: {\n        currentPeriodStart: newPeriodStart,\n        currentPeriodEnd: newPeriodEnd,\n        status: 'active',\n        updatedAt: new Date()\n      },\n      include: {\n        merchant: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          }\n        },\n        plan: true\n      }\n    });\n\n    // Update merchant status\n    await tx.merchant.update({\n      where: { id: subscription.merchantId },\n      data: {\n        // subscriptionStatus removed - use subscription.status instead\n        lastActiveAt: new Date()\n      }\n    });\n\n    return { updatedSubscription, payment };\n  });\n\n  // 5. Return formatted response\n  return {\n    subscription: {\n      id: result.updatedSubscription.id,\n      merchantId: result.updatedSubscription.merchantId,\n      planId: result.updatedSubscription.planId,\n      status: result.updatedSubscription.status as SubscriptionStatus,\n      billingInterval: result.updatedSubscription.interval as BillingInterval,\n      currentPeriodStart: result.updatedSubscription.currentPeriodStart,\n      currentPeriodEnd: result.updatedSubscription.currentPeriodEnd,\n      amount: result.updatedSubscription.amount,\n      createdAt: result.updatedSubscription.createdAt,\n      updatedAt: result.updatedSubscription.updatedAt,\n      merchant: result.updatedSubscription.merchant,\n      plan: convertPrismaPlanToPlan(result.updatedSubscription.plan)\n    },\n    payment: {\n      id: result.payment.id,\n      subscriptionId: subscriptionId,\n      amount: result.payment.amount,\n      currency: result.payment.currency,\n      method: result.payment.method,\n      status: result.payment.status,\n      transactionId: result.payment.transactionId || '',\n      description: result.payment.description || undefined,\n      createdAt: result.payment.createdAt,\n      updatedAt: result.payment.updatedAt\n    }\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedSubscriptions = {\n  /**\n   * Find subscription by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.subscription.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Find subscription by merchant ID (simplified API)\n   */\n  findByMerchantId: async (merchantId: number) => {\n    return await prisma.subscription.findFirst({\n      where: { \n        merchantId,\n        status: { not: 'CANCELLED' }\n      },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new subscription (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.subscription.create({\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Update subscription (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.subscription.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Delete subscription (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.subscription.update({\n      where: { id },\n      data: { \n        status: 'CANCELLED',\n        canceledAt: new Date()\n      }\n    });\n  },\n\n  /**\n   * Search subscriptions with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.planId) where.planId = whereFilters.planId;\n    if (whereFilters.isActive !== undefined) {\n      if (whereFilters.isActive) {\n        where.status = { not: 'CANCELLED' };\n      } else {\n        where.status = 'CANCELLED';\n      }\n    }\n    if (whereFilters.status) where.status = whereFilters.status;\n    \n    // Date range filters\n    if (whereFilters.startDate || whereFilters.endDate) {\n      where.createdAt = {};\n      if (whereFilters.startDate) where.createdAt.gte = whereFilters.startDate;\n      if (whereFilters.endDate) where.createdAt.lte = whereFilters.endDate;\n    }\n\n    const [subscriptions, total] = await Promise.all([\n      prisma.subscription.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          plan: { select: { id: true, name: true } },\n          payments: {\n            orderBy: { createdAt: 'desc' },\n            take: 3\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit\n      }),\n      prisma.subscription.count({ where })\n    ]);\n\n    return {\n      data: subscriptions,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  /**\n   * Get expired subscriptions (simplified API)\n   */\n  getExpired: async () => {\n    const now = new Date();\n    \n    return await prisma.subscription.findMany({\n      where: {\n        status: { not: 'CANCELLED' },\n        OR: [\n          { \n            status: 'TRIAL',\n            trialEnd: { lt: now }\n          },\n          {\n            status: 'ACTIVE',\n            currentPeriodEnd: { lt: now }\n          }\n        ]\n      },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } }\n      },\n      orderBy: { currentPeriodEnd: 'asc' }\n    });\n  }\n};","import { prisma } from './client';\n\n/**\n * Create a subscription activity log\n */\nexport async function createActivity(data: {\n  subscriptionId: number;\n  type: string;\n  description: string;\n  reason?: string;\n  metadata?: any;\n  performedBy?: number;\n}) {\n  const { metadata, ...rest } = data;\n  \n  return await prisma.subscriptionActivity.create({\n    data: {\n      ...rest,\n      metadata: metadata ? JSON.stringify(metadata) : null\n    }\n  });\n}\n\n/**\n * Get activities for a subscription\n */\nexport async function getActivitiesBySubscriptionId(\n  subscriptionId: number,\n  options: { limit?: number; offset?: number } = {}\n) {\n  const { limit = 50, offset = 0 } = options;\n  \n  const [activities, total] = await Promise.all([\n    prisma.subscriptionActivity.findMany({\n      where: { subscriptionId },\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            role: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset\n    }),\n    prisma.subscriptionActivity.count({ where: { subscriptionId } })\n  ]);\n\n  // Parse metadata JSON\n  return {\n    activities: activities.map(activity => ({\n      ...activity,\n      metadata: activity.metadata ? JSON.parse(activity.metadata) : null\n    })),\n    total\n  };\n}\n\n/**\n * Simplified subscription activity operations\n */\nexport const simplifiedSubscriptionActivities = {\n  /**\n   * Create activity (simplified API)\n   */\n  create: createActivity,\n\n  /**\n   * Get activities by subscription ID\n   */\n  getBySubscriptionId: getActivitiesBySubscriptionId\n};\n\n","// ============================================================================\n// SIMPLIFIED MERCHANT OPERATIONS\n// ============================================================================\n// Consistent with other simplified database operations\n\nimport { prisma } from './client';\nimport type { SimpleFilters, SimpleResponse } from './index';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface MerchantFilters extends SimpleFilters {\n  businessType?: string;\n  // subscriptionStatus removed - use subscription.status instead\n  planId?: number;\n  isActive?: boolean;\n}\n\nexport interface MerchantCreateData {\n  name: string;\n  email: string;\n  phone?: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  businessType?: string;\n  pricingType?: string;\n  taxId?: string;\n  website?: string;\n  description?: string;\n  currency?: string; // Currency code (USD, VND), defaults to USD\n  pricingConfig?: string;\n  planId?: number;\n  // subscriptionStatus removed - use subscription.status instead\n}\n\nexport interface MerchantUpdateData extends Partial<MerchantCreateData> {\n  totalRevenue?: number;\n  lastActiveAt?: Date;\n  isActive?: boolean;\n}\n\n// ============================================================================\n// MERCHANT OPERATIONS\n// ============================================================================\n\n/**\n * Find merchant by ID\n */\nexport async function findById(id: number) {\n  return await prisma.merchant.findUnique({\n    where: { id },\n    include: {\n      // Plan removed - use subscription.plan instead (single source of truth)\n      subscription: {\n        include: {\n          plan: true\n        }\n      },\n      outlets: {\n        select: {\n          id: true,\n          name: true,\n          isActive: true\n        }\n      },\n      _count: {\n        select: {\n          outlets: true,\n          users: true,\n          products: true,\n          customers: true\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find merchant by email\n */\nexport async function findByEmail(email: string) {\n  return await prisma.merchant.findUnique({\n    where: { email },\n    include: {\n      Plan: true,\n      subscription: true\n    }\n  });\n}\n\n/**\n * Search merchants with filtering and pagination\n */\nexport async function search(filters: MerchantFilters): Promise<SimpleResponse<any>> {\n  const {\n    page = 1,\n    limit = 20,\n    search,\n    businessType,\n    planId,\n    isActive\n  } = filters;\n\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {};\n\n  if (search) {\n    where.OR = [\n      { name: { contains: search, mode: 'insensitive' } },\n      { email: { contains: search, mode: 'insensitive' } },\n      { businessType: { contains: search, mode: 'insensitive' } }\n    ];\n  }\n\n  if (businessType) {\n    where.businessType = businessType;\n  }\n\n  // subscriptionStatus filter removed - use subscription.status instead\n  // if (subscriptionStatus) {\n  //   where.subscription = {\n  //     status: subscriptionStatus\n  //   };\n  // }\n\n  if (planId !== undefined) {\n    where.planId = planId;\n  }\n\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  }\n\n  // Execute query\n  const [merchants, total] = await Promise.all([\n    prisma.merchant.findMany({\n      where,\n      include: {\n        subscription: {\n          select: {\n            id: true,\n            status: true,\n            currentPeriodStart: true,\n            currentPeriodEnd: true,\n            trialStart: true,\n            trialEnd: true,\n            amount: true,\n            currency: true,\n            interval: true,\n            period: true,\n            discount: true,\n            savings: true,\n            cancelAtPeriodEnd: true,\n            canceledAt: true,\n            cancelReason: true,\n            plan: {\n              select: {\n                id: true,\n                name: true,\n                description: true,\n                basePrice: true,\n                currency: true,\n                trialDays: true\n              }\n            }\n          }\n        },\n        _count: {\n          select: {\n            outlets: true,\n            users: true,\n            products: true,\n            customers: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      skip,\n      take: limit\n    }),\n    prisma.merchant.count({ where })\n  ]);\n\n  return {\n    data: merchants,\n    total,\n    page,\n    limit,\n    hasMore: skip + limit < total\n  };\n}\n\n/**\n * Create new merchant\n */\nexport async function create(data: MerchantCreateData) {\n  return await prisma.merchant.create({\n    data: {\n      ...data,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    },\n    include: {\n      Plan: true,\n      subscription: true\n    }\n  });\n}\n\n/**\n * Update merchant\n */\nexport async function update(id: number, data: MerchantUpdateData) {\n  return await prisma.merchant.update({\n    where: { id },\n    data: {\n      ...data,\n      updatedAt: new Date()\n    },\n    include: {\n      Plan: true,\n      subscription: true\n    }\n  });\n}\n\n/**\n * Delete merchant (soft delete)\n */\nexport async function remove(id: number) {\n  return await prisma.merchant.update({\n    where: { id },\n    data: {\n      isActive: false,\n      updatedAt: new Date()\n    }\n  });\n}\n\n/**\n * Get merchant statistics\n */\nexport async function getStats(id: number) {\n  const merchant = await prisma.merchant.findUnique({\n    where: { id },\n    include: {\n        _count: {\n          select: {\n            outlets: true,\n            users: true,\n            products: true,\n            customers: true\n          }\n        }\n    }\n  });\n\n  if (!merchant) {\n    return null;\n  }\n\n  // Get revenue from orders\n  const revenueResult = await prisma.order.aggregate({\n    where: {\n      outlet: {\n        merchantId: id\n      },\n      status: { in: ['COMPLETED', 'RETURNED'] }\n    },\n    _sum: {\n      totalAmount: true\n    }\n  });\n\n  return {\n    totalOutlets: merchant._count.outlets,\n    totalUsers: merchant._count.users,\n    totalProducts: merchant._count.products,\n    totalCustomers: merchant._count.customers,\n    totalOrders: 0, // Will be calculated separately\n    totalRevenue: revenueResult._sum.totalAmount || 0\n  };\n}\n\n/**\n * Count merchants with optional where clause\n */\nexport async function count(options?: { where?: any }) {\n  const where = options?.where || {};\n  return await prisma.merchant.count({ where });\n}\n\n/**\n * Check for duplicate merchant by email or phone\n */\nexport async function checkDuplicate(email?: string, phone?: string, excludeId?: number) {\n  if (!email && !phone) {\n    return null;\n  }\n\n  const conditions = [];\n  \n  if (email) {\n    conditions.push({ email });\n  }\n  \n  if (phone) {\n    conditions.push({ phone });\n  }\n\n  const where: any = {\n    OR: conditions\n  };\n\n  // Exclude specific merchant ID (for update operations)\n  if (excludeId) {\n    where.id = { not: excludeId };\n  }\n\n  return await prisma.merchant.findFirst({ where });\n}\n\n// ============================================================================\n// EXPORT SIMPLIFIED INTERFACE\n// ============================================================================\n\nexport const simplifiedMerchants = {\n  findById,\n  findByEmail,\n  search,\n  create,\n  update,\n  remove,\n  getStats,\n  count,\n  checkDuplicate\n};","/**\n * Order Number Generator & Configuration\n * \n * Provides robust, concurrent-safe order number generation for rental shop orders.\n * Supports multiple formats, handles race conditions, and includes centralized configuration.\n */\n\nimport { prisma } from './index';\n\n// ============================================================================\n// TYPES & INTERFACES\n// ============================================================================\n\nexport type OrderNumberFormat = 'sequential' | 'date-based' | 'random' | 'random-numeric' | 'hybrid' | 'compact-numeric';\n\nexport interface OrderNumberConfig {\n  format: OrderNumberFormat;\n  outletId: number;\n  prefix?: string;\n  includeDate?: boolean;\n  sequenceLength?: number;\n  randomLength?: number;\n  numericOnly?: boolean;\n}\n\nexport interface OrderNumberResult {\n  orderNumber: string;\n  sequence: number;\n  generatedAt: Date;\n}\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\n/**\n * Default order number format for new orders\n * \n * Available formats:\n * - 'sequential': ORD-{outletId}-{sequence} (e.g., ORD-001-0001)\n * - 'date-based': ORD-{outletId}-{date}-{sequence} (e.g., ORD-001-20250115-0001)\n * - 'random': ORD-{outletId}-{random} (e.g., ORD-001-A7B9C2)\n * - 'random-numeric': ORD-{outletId}-{random} (e.g., ORD-001-123456)\n * - 'hybrid': ORD-{outletId}-{date}-{random} (e.g., ORD-001-20250115-A7B9)\n * - 'compact-numeric': ORD{outletId}{random} (e.g., ORD00112345)\n */\nexport const ORDER_NUMBER_CONFIG = {\n  // Primary format for all new orders\n  format: 'compact-numeric' as OrderNumberFormat,\n  \n  // Prefix for all order numbers\n  prefix: 'ORD',\n  \n  // Sequence number padding (how many digits)\n  sequenceLength: 4,\n  \n  // Random string length (for random and hybrid formats)\n  randomLength: 6,\n  \n  // Whether to include date in order numbers (for date-based and hybrid)\n  includeDate: true,\n  \n  // Maximum retry attempts for collision resolution\n  maxRetries: 5,\n  \n  // Retry delay in milliseconds (exponential backoff)\n  retryDelay: 10,\n} as const;\n\n/**\n * Format-specific configurations\n */\nexport const FORMAT_CONFIGS = {\n  sequential: {\n    description: 'Sequential numbering per outlet',\n    example: 'ORD-001-0001',\n    pros: ['Outlet identification', 'Easy tracking', 'Human readable'],\n    cons: ['Business intelligence leakage', 'Race conditions possible'],\n    bestFor: 'Small to medium businesses with low concurrency'\n  },\n  \n  'date-based': {\n    description: 'Date-based with daily sequence reset',\n    example: 'ORD-001-20250115-0001',\n    pros: ['Daily organization', 'Better security', 'Easy daily reporting'],\n    cons: ['Longer numbers', 'Still somewhat predictable'],\n    bestFor: 'Medium businesses with daily operations focus'\n  },\n  \n  random: {\n    description: 'Random alphanumeric strings for security',\n    example: 'ORD-001-A7B9C2',\n    pros: ['Maximum security', 'No race conditions', 'Unpredictable'],\n    cons: ['No sequence tracking', 'Harder to manage', 'No business insights'],\n    bestFor: 'Large businesses prioritizing security'\n  },\n  \n  'random-numeric': {\n    description: 'Random numeric strings for security',\n    example: 'ORD-001-123456',\n    pros: ['Maximum security', 'No race conditions', 'Numbers only', 'Unpredictable'],\n    cons: ['No sequence tracking', 'Harder to manage', 'No business insights'],\n    bestFor: 'Businesses needing numeric-only random order numbers'\n  },\n  \n  'compact-numeric': {\n    description: 'Compact format with outlet ID and 5-digit random number',\n    example: 'ORD00112345',\n    pros: ['Compact format', 'Outlet identification', 'Numbers only', 'Short length', 'Easy to read'],\n    cons: ['No sequence tracking', 'Limited randomness (5 digits)'],\n    bestFor: 'Businesses wanting compact, numeric-only order numbers'\n  },\n  \n  hybrid: {\n    description: 'Combines outlet, date, and random elements',\n    example: 'ORD-001-20250115-A7B9',\n    pros: ['Balanced security', 'Outlet identification', 'Date organization'],\n    cons: ['Longer numbers', 'More complex'],\n    bestFor: 'Large businesses needing both security and organization'\n  }\n} as const;\n\n// ============================================================================\n// CONFIGURATION FUNCTIONS\n// ============================================================================\n\n/**\n * Get the current order number configuration\n */\nexport function getOrderNumberConfig() {\n  return ORDER_NUMBER_CONFIG;\n}\n\n/**\n * Update order number configuration (for testing or admin purposes)\n */\nexport function updateOrderNumberConfig(updates: Partial<typeof ORDER_NUMBER_CONFIG>) {\n  Object.assign(ORDER_NUMBER_CONFIG, updates);\n}\n\n/**\n * Get format information for display purposes\n */\nexport function getFormatInfo(format: OrderNumberFormat) {\n  return FORMAT_CONFIGS[format];\n}\n\n/**\n * Get all available formats with their information\n */\nexport function getAllFormats() {\n  return Object.entries(FORMAT_CONFIGS).map(([key, value]) => ({\n    format: key as OrderNumberFormat,\n    ...value\n  }));\n}\n\n/**\n * Validate order number format configuration\n */\nexport function validateOrderNumberConfig(config: typeof ORDER_NUMBER_CONFIG): string[] {\n  const errors: string[] = [];\n  \n  if (!config.prefix || config.prefix.length === 0) {\n    errors.push('Prefix cannot be empty');\n  }\n  \n  if (config.sequenceLength < 1 || config.sequenceLength > 10) {\n    errors.push('Sequence length must be between 1 and 10');\n  }\n  \n  if (config.randomLength < 4 || config.randomLength > 20) {\n    errors.push('Random length must be between 4 and 20');\n  }\n  \n  if (config.maxRetries < 1 || config.maxRetries > 20) {\n    errors.push('Max retries must be between 1 and 20');\n  }\n  \n  if (config.retryDelay < 1 || config.retryDelay > 1000) {\n    errors.push('Retry delay must be between 1 and 1000 milliseconds');\n  }\n  \n  return errors;\n}\n\n/**\n * Get recommended format based on business characteristics\n */\nexport function getRecommendedFormat(businessSize: 'small' | 'medium' | 'large', \n                                   concurrencyLevel: 'low' | 'medium' | 'high',\n                                   securityPriority: 'low' | 'medium' | 'high'): OrderNumberFormat {\n  // Small business with low concurrency and low security needs\n  if (businessSize === 'small' && concurrencyLevel === 'low' && securityPriority === 'low') {\n    return 'compact-numeric';\n  }\n  \n  // Medium business or higher security needs\n  if (businessSize === 'medium' || securityPriority === 'medium') {\n    return 'date-based';\n  }\n  \n  // High concurrency or high security needs\n  if (concurrencyLevel === 'high' || securityPriority === 'high') {\n    return 'random-numeric';\n  }\n  \n  // Large business with balanced needs\n  if (businessSize === 'large') {\n    return 'hybrid';\n  }\n  \n  // Default fallback - compact numeric for easy use\n  return 'compact-numeric';\n}\n\n// ============================================================================\n// ORDER NUMBER GENERATION\n// ============================================================================\n\n/**\n * Generate order number with specified format\n */\nexport async function generateOrderNumber(\n  config: OrderNumberConfig\n): Promise<OrderNumberResult> {\n  const {\n    format = 'sequential',\n    outletId,\n    prefix = 'ORD',\n    includeDate = false,\n    sequenceLength = 4,\n    randomLength = 6,\n    numericOnly = false\n  } = config;\n\n  // Validate outlet exists\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true, name: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  const outletIdStr = outlet.id.toString().padStart(3, '0');\n  const generatedAt = new Date();\n\n  switch (format) {\n    case 'sequential':\n      return await generateSequentialNumber(outletIdStr, prefix, sequenceLength);\n    \n    case 'date-based':\n      return await generateDateBasedNumber(outletIdStr, prefix, sequenceLength, generatedAt);\n    \n    case 'random':\n      return await generateRandomNumber(outletIdStr, prefix, randomLength, false);\n    \n    case 'random-numeric':\n      return await generateRandomNumber(outletIdStr, prefix, randomLength, true);\n    \n    case 'compact-numeric':\n      return await generateCompactNumericNumber(outletIdStr, prefix);\n    \n    case 'hybrid':\n      return await generateHybridNumber(outletIdStr, prefix, sequenceLength, generatedAt, numericOnly);\n    \n    default:\n      throw new Error(`Unsupported order number format: ${format}`);\n  }\n}\n\n/**\n * Generate sequential order number: ORD-{outletId}-{sequence}\n * Uses atomic counter to prevent race conditions\n */\nasync function generateSequentialNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number\n): Promise<OrderNumberResult> {\n  const maxRetries = 5;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Use atomic increment with retry logic\n      const result = await prisma.$transaction(async (tx: any) => {\n        // Get current sequence for this outlet\n        const lastOrder = await tx.order.findFirst({\n          where: { \n            orderNumber: { startsWith: `${prefix}-${outletIdStr}-` }\n          },\n          orderBy: { createdAt: 'desc' },\n          select: { orderNumber: true, createdAt: true }\n        });\n\n        let nextSequence = 1;\n        \n        if (lastOrder) {\n          // Extract sequence from last order number\n          const parts = lastOrder.orderNumber.split('-');\n          const lastSequence = parseInt(parts[parts.length - 1]) || 0;\n          nextSequence = lastSequence + 1;\n        }\n\n        const orderNumber = `${prefix}-${outletIdStr}-${nextSequence.toString().padStart(sequenceLength, '0')}`;\n\n        // Check for uniqueness (double-check)\n        const existingOrder = await tx.order.findUnique({\n          where: { orderNumber },\n          select: { id: true }\n        });\n\n        if (existingOrder) {\n          throw new Error('Order number collision detected');\n        }\n\n        return {\n          orderNumber,\n          sequence: nextSequence,\n          generatedAt: new Date()\n        };\n      });\n\n      return result;\n    } catch (error) {\n      retryCount++;\n      if (retryCount >= maxRetries) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        throw new Error(`Failed to generate sequential order number after ${maxRetries} retries: ${errorMessage}`);\n      }\n      \n      // Wait before retry (exponential backoff)\n      await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 10));\n    }\n  }\n\n  throw new Error('Maximum retries exceeded');\n}\n\n/**\n * Generate date-based order number: ORD-{outletId}-{date}-{sequence}\n * Resets sequence daily for better organization\n */\nasync function generateDateBasedNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number,\n  generatedAt: Date\n): Promise<OrderNumberResult> {\n  const dateStr = generatedAt.toISOString().split('T')[0].replace(/-/g, '');\n  \n  const result = await prisma.$transaction(async (tx: any) => {\n    // Get last order for this outlet on this date\n    const lastOrder = await tx.order.findFirst({\n      where: { \n        orderNumber: { startsWith: `${prefix}-${outletIdStr}-${dateStr}-` }\n      },\n      orderBy: { createdAt: 'desc' },\n      select: { orderNumber: true }\n    });\n\n    let nextSequence = 1;\n    \n    if (lastOrder) {\n      const parts = lastOrder.orderNumber.split('-');\n      const lastSequence = parseInt(parts[parts.length - 1]) || 0;\n      nextSequence = lastSequence + 1;\n    }\n\n    const orderNumber = `${prefix}-${outletIdStr}-${dateStr}-${nextSequence.toString().padStart(sequenceLength, '0')}`;\n\n    // Check for uniqueness\n    const existingOrder = await tx.order.findUnique({\n      where: { orderNumber },\n      select: { id: true }\n    });\n\n    if (existingOrder) {\n      throw new Error('Order number collision detected');\n    }\n\n    return {\n      orderNumber,\n      sequence: nextSequence,\n      generatedAt\n    };\n  });\n\n  return result;\n}\n\n/**\n * Generate random order number: ORD-{outletId}-{random}\n * Uses crypto-secure random generation\n */\nasync function generateRandomNumber(\n  outletIdStr: string,\n  prefix: string,\n  randomLength: number,\n  numericOnly: boolean = false\n): Promise<OrderNumberResult> {\n  const maxRetries = 10;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Generate crypto-secure random string\n      const randomStr = generateRandomString(randomLength, numericOnly);\n      const orderNumber = `${prefix}-${outletIdStr}-${randomStr}`;\n\n      // Check for uniqueness\n      const existingOrder = await prisma.order.findUnique({\n        where: { orderNumber },\n        select: { id: true }\n      });\n\n      if (!existingOrder) {\n        return {\n          orderNumber,\n          sequence: 0, // No sequence for random\n          generatedAt: new Date()\n        };\n      }\n\n      retryCount++;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to generate random order number: ${errorMessage}`);\n    }\n  }\n\n  throw new Error(`Failed to generate unique random order number after ${maxRetries} attempts`);\n}\n\n/**\n * Generate compact numeric order number: ORD{outletId}{random}\n * Format: ORD00112345 (no hyphens, 5-digit random number)\n */\nasync function generateCompactNumericNumber(\n  outletIdStr: string,\n  prefix: string\n): Promise<OrderNumberResult> {\n  const maxRetries = 10;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Generate 5-digit random number\n      const randomStr = generateRandomString(5, true); // 5 digits, numeric only\n      const orderNumber = `${prefix}${outletIdStr}${randomStr}`;\n\n      // Check for uniqueness\n      const existingOrder = await prisma.order.findUnique({\n        where: { orderNumber },\n        select: { id: true }\n      });\n\n      if (!existingOrder) {\n        return {\n          orderNumber,\n          sequence: 0, // No sequence for compact numeric\n          generatedAt: new Date()\n        };\n      }\n\n      retryCount++;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to generate compact numeric order number: ${errorMessage}`);\n    }\n  }\n\n  throw new Error(`Failed to generate unique compact numeric order number after ${maxRetries} attempts`);\n}\n\n/**\n * Generate hybrid order number: ORD-{outletId}-{date}-{random}\n * Combines outlet, date, and random for optimal security and organization\n */\nasync function generateHybridNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number,\n  generatedAt: Date,\n  numericOnly: boolean = false\n): Promise<OrderNumberResult> {\n  const dateStr = generatedAt.toISOString().split('T')[0].replace(/-/g, '');\n  const randomStr = generateRandomString(4, numericOnly); // Shorter random part\n  \n  const orderNumber = `${prefix}-${outletIdStr}-${dateStr}-${randomStr}`;\n\n  // Check for uniqueness\n  const existingOrder = await prisma.order.findUnique({\n    where: { orderNumber },\n    select: { id: true }\n  });\n\n  if (existingOrder) {\n    // If collision, try with different random string\n    return generateHybridNumber(outletIdStr, prefix, sequenceLength, generatedAt, numericOnly);\n  }\n\n  return {\n    orderNumber,\n    sequence: 0, // No sequence for hybrid\n    generatedAt\n  };\n}\n\n/**\n * Generate crypto-secure random string\n */\nfunction generateRandomString(length: number, numericOnly: boolean = false): string {\n  const chars = numericOnly ? '0123456789' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  const randomBytes = new Uint8Array(length);\n  \n  if (typeof window !== 'undefined' && window.crypto) {\n    // Browser environment\n    window.crypto.getRandomValues(randomBytes);\n  } else {\n    // Node.js environment\n    const crypto = require('crypto');\n    const randomBytesNode = crypto.randomBytes(length);\n    randomBytes.set(randomBytesNode);\n  }\n  \n  return Array.from(randomBytes, byte => chars[byte % chars.length]).join('');\n}\n\n// ============================================================================\n// VALIDATION & PARSING\n// ============================================================================\n\n/**\n * Validate order number format\n */\nexport function validateOrderNumber(orderNumber: string): boolean {\n  const patterns = [\n    /^ORD-\\d{3}-\\d{4}$/, // Sequential: ORD-001-0001\n    /^ORD-\\d{3}-\\d{8}-\\d{4}$/, // Date-based: ORD-001-20250115-0001\n    /^ORD-\\d{3}-[A-Z0-9]{6}$/, // Random: ORD-001-A7B9C2\n    /^ORD-\\d{3}-\\d{6}$/, // Random-numeric: ORD-001-123456\n    /^ORD-\\d{3}-\\d{8}-[A-Z0-9]{4}$/, // Hybrid: ORD-001-20250115-A7B9\n    /^ORD\\d{3}\\d{5}$/ // Compact-numeric: ORD00112345\n  ];\n  \n  return patterns.some(pattern => pattern.test(orderNumber));\n}\n\n/**\n * Parse order number to extract components\n */\nexport function parseOrderNumber(orderNumber: string): {\n  prefix: string;\n  outletId: number;\n  date?: string;\n  sequence?: number;\n  random?: string;\n  format: OrderNumberFormat;\n} | null {\n  if (!validateOrderNumber(orderNumber)) {\n    return null;\n  }\n\n  // Check for compact-numeric format first (no hyphens)\n  if (/^ORD\\d{3}\\d{5}$/.test(orderNumber)) {\n    const outletId = parseInt(orderNumber.substring(3, 6));\n    const random = orderNumber.substring(6);\n    \n    return {\n      prefix: 'ORD',\n      outletId,\n      random,\n      format: 'compact-numeric'\n    };\n  }\n\n  const parts = orderNumber.split('-');\n  \n  if (parts.length === 3) {\n    // Sequential or Random format\n    const sequence = parseInt(parts[2]);\n    const isNumeric = /^\\d+$/.test(parts[2]);\n    \n    return {\n      prefix: parts[0],\n      outletId: parseInt(parts[1]),\n      sequence: isNumeric ? sequence : undefined,\n      random: !isNumeric ? parts[2] : undefined,\n      format: isNumeric ? 'sequential' : 'random'\n    };\n  }\n  \n  if (parts.length === 4) {\n    // Date-based or Hybrid format\n    const sequence = parseInt(parts[3]);\n    const isNumeric = /^\\d+$/.test(parts[3]);\n    \n    return {\n      prefix: parts[0],\n      outletId: parseInt(parts[1]),\n      date: parts[2],\n      sequence: isNumeric ? sequence : undefined,\n      random: !isNumeric ? parts[3] : undefined,\n      format: isNumeric ? 'date-based' : 'hybrid'\n    };\n  }\n  \n  return null;\n}\n\n// ============================================================================\n// STATISTICS & UTILITIES\n// ============================================================================\n\n/**\n * Get order statistics for an outlet\n */\nexport async function getOutletOrderStats(outletId: number): Promise<{\n  totalOrders: number;\n  todayOrders: number;\n  lastOrderNumber?: string;\n  lastOrderDate?: Date;\n}> {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const tomorrow = new Date(today);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n\n  const [totalOrders, todayOrders, lastOrder] = await Promise.all([\n    prisma.order.count({\n      where: { outletId: outlet.id }\n    }),\n    prisma.order.count({\n      where: { \n        outletId: outlet.id,\n        createdAt: {\n          gte: today,\n          lt: tomorrow\n        }\n      }\n    }),\n    prisma.order.findFirst({\n      where: { outletId: outlet.id },\n      orderBy: { createdAt: 'desc' },\n      select: { orderNumber: true, createdAt: true }\n    })\n  ]);\n\n  return {\n    totalOrders,\n    todayOrders,\n    lastOrderNumber: lastOrder?.orderNumber,\n    lastOrderDate: lastOrder?.createdAt\n  };\n}\n\n/**\n * Quick order number generation with default settings\n */\nexport async function createOrderNumber(outletId: number): Promise<string> {\n  const result = await generateOrderNumber({\n    format: 'sequential',\n    outletId,\n    prefix: 'ORD',\n    sequenceLength: 4\n  });\n  \n  return result.orderNumber;\n}\n\n/**\n * Generate order number with specific format\n */\nexport async function createOrderNumberWithFormat(\n  outletId: number, \n  format: OrderNumberFormat\n): Promise<OrderNumberResult> {\n  const config: OrderNumberConfig = {\n    format,\n    outletId,\n    prefix: 'ORD',\n    sequenceLength: 4,\n    randomLength: 6,\n    includeDate: true\n  };\n  \n  return await generateOrderNumber(config);\n}\n\n/**\n * Generate multiple order numbers for testing\n */\nexport async function generateTestOrderNumbers(\n  outletId: number, \n  count: number, \n  format: OrderNumberFormat = 'sequential'\n): Promise<string[]> {\n  const orderNumbers: string[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const result = await createOrderNumberWithFormat(outletId, format);\n    orderNumbers.push(result.orderNumber);\n  }\n  \n  return orderNumbers;\n}\n\n/**\n * Analyze order number\n */\nexport function analyzeOrderNumber(orderNumber: string) {\n  const isValid = validateOrderNumber(orderNumber);\n  const parsed = parseOrderNumber(orderNumber);\n  \n  return {\n    orderNumber,\n    isValid,\n    parsed,\n    format: parsed?.format || 'unknown',\n    outletId: parsed?.outletId,\n    sequence: parsed?.sequence,\n    date: parsed?.date,\n    random: parsed?.random\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedOrderNumbers = {\n  /**\n   * Get outlet order stats (simplified API)\n   */\n  getOutletStats: async (outletId: number) => {\n    return await getOutletOrderStats(outletId);\n  },\n\n  /**\n   * Create order number with format (simplified API)\n   */\n  createWithFormat: async (outletId: number, format: OrderNumberFormat) => {\n    return await createOrderNumberWithFormat(outletId, format);\n  },\n\n  /**\n   * Generate multiple order numbers (simplified API)\n   */\n  generateMultiple: async (outletId: number, count: number, format: OrderNumberFormat = 'sequential') => {\n    return await generateTestOrderNumbers(outletId, count, format);\n  },\n\n  /**\n   * Validate order number format (simplified API)\n   */\n  validateFormat: (orderNumber: string) => {\n    return validateOrderNumber(orderNumber);\n  },\n\n  /**\n   * Get format info (simplified API)\n   */\n  getFormatInfo: (format: OrderNumberFormat) => {\n    return getFormatInfo(format);\n  }\n};","// ============================================================================\n// CATEGORY FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains category functions that follow the simplified API pattern\n// - Input: id (number)\n// - Database: queries by id, uses numbers for relationships\n// - Return: includes id (number)\n\nimport { prisma } from './client';\n\n// ============================================================================\n// CATEGORY LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find category by ID (simplified API)\n */\nexport const findById = async (id: number) => {\n  return await prisma.category.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Find first category matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.category.findFirst({\n    where,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Find many categories matching criteria (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, select = {}, orderBy = { name: 'asc' }, take, skip } = options;\n  \n  return await prisma.category.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      ...select\n    },\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Create new category (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.category.create({\n    data,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Update category (simplified API)\n */\nexport const update = async (id: number, data: any) => {\n  return await prisma.category.update({\n    where: { id },\n    data,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Delete category (soft delete) (simplified API)\n */\nexport const deleteCategory = async (id: number) => {\n  return await prisma.category.update({\n    where: { id },\n    data: { isActive: false },\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Search categories with pagination (simplified API)\n */\nexport const search = async (filters: any) => {\n  const { page = 1, limit = 20, sortBy = 'name', sortOrder = 'asc', ...whereFilters } = filters;\n  const skip = (page - 1) * limit;\n\n  console.log('🔍 DB category.search - Received filters:', filters);\n\n  // Build where clause\n  const where: any = {};\n  \n  if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n  if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n  \n  // Text search by category name - accept both 'q' and 'search' parameters\n  const searchTerm = (whereFilters.q || whereFilters.search)?.trim();\n  console.log('🔍 DB category.search - searchTerm:', searchTerm, 'length:', searchTerm?.length);\n  \n  if (searchTerm && searchTerm.length > 0) {\n    where.name = { \n      contains: searchTerm, \n      mode: 'insensitive' \n    };\n    console.log('✅ DB category.search - Added name filter:', where.name);\n  } else {\n    console.log('⚠️ DB category.search - No search term, will return all categories');\n  }\n  \n  console.log('🔍 DB category.search - Final where clause:', JSON.stringify(where, null, 2));\n\n  // Build orderBy based on sortBy and sortOrder\n  const orderBy: any = {};\n  if (sortBy === 'name' || sortBy === 'createdAt' || sortBy === 'updatedAt') {\n    orderBy[sortBy] = sortOrder;\n  } else {\n    orderBy.name = 'asc'; // Default\n  }\n\n  const [categories, total] = await Promise.all([\n    prisma.category.findMany({\n      where,\n      select: {\n        id: true,\n        name: true,\n        description: true,\n        isActive: true,\n        isDefault: true,\n        createdAt: true,\n        updatedAt: true,\n        _count: {\n          select: {\n            products: true\n          }\n        }\n      },\n      orderBy,\n      skip,\n      take: limit\n    }),\n    prisma.category.count({ where })\n  ]);\n\n  console.log(`📊 db.categories.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, categories=${categories.length}`);\n\n  return {\n    data: categories,\n    total,\n    page,\n    limit,\n    hasMore: skip + limit < total,\n    totalPages: Math.ceil(total / limit)\n  };\n};\n\n/**\n * Get category statistics (simplified API)\n */\nexport const getStats = async (where: any = {}) => {\n  return await prisma.category.count({ where });\n};\n\n// ============================================================================\n// SIMPLIFIED CATEGORY API\n// ============================================================================\n\nexport const simplifiedCategories = {\n  findById,\n  findFirst,\n  findMany,\n  create,\n  update,\n  delete: deleteCategory,\n  search,\n  getStats\n};\n","// ============================================================================\n// AUDIT LOG FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains audit log functions that follow the simplified API pattern\n\nimport { prisma } from './client';\n\n// ============================================================================\n// AUDIT LOG LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find audit logs with filtering (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, include = {}, orderBy = { createdAt: 'desc' }, take, skip } = options;\n  \n  return await prisma.auditLog.findMany({\n    where,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      },\n      ...include\n    },\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Get audit log statistics (simplified API)\n */\nexport const getStats = async (where: any = {}) => {\n  return await prisma.auditLog.count({ where });\n};\n\n/**\n * Find first audit log matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.auditLog.findFirst({\n    where,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      }\n    }\n  });\n};\n\n/**\n * Create audit log (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.auditLog.create({\n    data,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      }\n    }\n  });\n};\n\n// ============================================================================\n// SIMPLIFIED AUDIT LOGS API\n// ============================================================================\n\nexport const simplifiedAuditLogs = {\n  findMany,\n  findFirst,\n  create,\n  getStats\n};\n","// ============================================================================\n// ORDER ITEM FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains order item functions that follow the simplified API pattern\n\nimport { prisma } from './client';\n\n// ============================================================================\n// ORDER ITEM LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find order items with filtering (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, include = {}, orderBy = { createdAt: 'desc' }, take, skip } = options;\n  \n  return await prisma.orderItem.findMany({\n    where,\n    include,\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Group by order items (simplified API)\n */\nexport const groupBy = async (options: any) => {\n  const { by, where = {}, _count = {}, _sum = {}, _avg = {}, orderBy, take } = options;\n  \n  // Build the groupBy options object\n  const groupByOptions: any = {\n    by,\n    where,\n    orderBy,\n    take\n  };\n  \n  // Only add aggregation options if they have content\n  if (Object.keys(_count).length > 0) {\n    groupByOptions._count = _count;\n  }\n  \n  if (Object.keys(_sum).length > 0) {\n    groupByOptions._sum = _sum;\n  }\n  \n  if (Object.keys(_avg).length > 0) {\n    groupByOptions._avg = _avg;\n  }\n  \n  return await prisma.orderItem.groupBy(groupByOptions);\n};\n\n/**\n * Get order item statistics (simplified API)\n */\nexport const getStats = async (where: any = {}) => {\n  return await prisma.orderItem.count({ where });\n};\n\n/**\n * Find first order item matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.orderItem.findFirst({\n    where,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Create order item (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.orderItem.create({\n    data,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Update order item (simplified API)\n */\nexport const update = async (id: number, data: any) => {\n  return await prisma.orderItem.update({\n    where: { id },\n    data,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Delete order item (simplified API)\n */\nexport const deleteOrderItem = async (id: number) => {\n  return await prisma.orderItem.delete({\n    where: { id }\n  });\n};\n\n// ============================================================================\n// SIMPLIFIED ORDER ITEMS API\n// ============================================================================\n\nexport const simplifiedOrderItems = {\n  findMany,\n  findFirst,\n  create,\n  update,\n  delete: deleteOrderItem,\n  getStats,\n  groupBy\n};\n","import { prisma } from './client';\nimport { randomBytes } from 'crypto';\n\n/**\n * Generate a unique session ID\n */\nexport function generateSessionId(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Create a new session for a user and invalidate all previous sessions\n * This implements \"single session\" behavior - only the latest login is valid\n */\nexport async function createUserSession(\n  userId: number,\n  ipAddress?: string,\n  userAgent?: string\n) {\n  const sessionId = generateSessionId();\n  const expiresAt = new Date();\n  expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiry\n\n  // Start a transaction to ensure atomicity\n  return await prisma.$transaction(async (tx) => {\n    // 1. Invalidate ALL previous sessions for this user\n    await tx.userSession.updateMany({\n      where: {\n        userId,\n        isActive: true,\n      },\n      data: {\n        isActive: false,\n        invalidatedAt: new Date(),\n      },\n    });\n\n    // 2. Create new session\n    const session = await tx.userSession.create({\n      data: {\n        userId,\n        sessionId,\n        ipAddress,\n        userAgent,\n        expiresAt,\n        isActive: true,\n      },\n    });\n\n    return session;\n  });\n}\n\n/**\n * Validate a session by sessionId\n * Returns true if session is valid (active and not expired)\n */\nexport async function validateSession(sessionId: string): Promise<boolean> {\n  if (!sessionId) {\n    return false;\n  }\n\n  const session = await prisma.userSession.findUnique({\n    where: { sessionId },\n  });\n\n  if (!session) {\n    return false;\n  }\n\n  // Check if session is active\n  if (!session.isActive) {\n    return false;\n  }\n\n  // Check if session is expired\n  if (session.expiresAt < new Date()) {\n    // Auto-invalidate expired session\n    await prisma.userSession.update({\n      where: { id: session.id },\n      data: {\n        isActive: false,\n        invalidatedAt: new Date(),\n      },\n    });\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Invalidate a specific session (for logout)\n */\nexport async function invalidateSession(sessionId: string): Promise<void> {\n  await prisma.userSession.updateMany({\n    where: {\n      sessionId,\n      isActive: true,\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Invalidate all sessions for a user\n */\nexport async function invalidateAllUserSessions(userId: number): Promise<void> {\n  await prisma.userSession.updateMany({\n    where: {\n      userId,\n      isActive: true,\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Get active sessions for a user\n */\nexport async function getUserActiveSessions(userId: number) {\n  return await prisma.userSession.findMany({\n    where: {\n      userId,\n      isActive: true,\n      expiresAt: {\n        gt: new Date(),\n      },\n    },\n    orderBy: {\n      createdAt: 'desc',\n    },\n  });\n}\n\n/**\n * Clean up expired sessions (can be run periodically)\n */\nexport async function cleanupExpiredSessions(): Promise<number> {\n  const result = await prisma.userSession.updateMany({\n    where: {\n      isActive: true,\n      expiresAt: {\n        lt: new Date(),\n      },\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n\n  return result.count;\n}\n\nexport const sessions = {\n  generateSessionId,\n  createUserSession,\n  validateSession,\n  invalidateSession,\n  invalidateAllUserSessions,\n  getUserActiveSessions,\n  cleanupExpiredSessions,\n};\n\n","/**\n * Comprehensive Audit Logging System\n * \n * This module provides a complete audit logging solution that tracks:\n * - Who made changes (user, role, context)\n * - What was changed (entity, fields, values)\n * - When changes occurred (timestamp, session)\n * - Where changes came from (IP, user agent)\n * - Why changes were made (business context)\n */\n\nimport { PrismaClient } from '@prisma/client';\n\n// Types for audit logging\nexport interface AuditContext {\n  userId?: number;\n  userEmail?: string;\n  userRole?: string;\n  merchantId?: number;\n  outletId?: number;\n  ipAddress?: string;\n  userAgent?: string;\n  sessionId?: string;\n  requestId?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface AuditLogData {\n  action: 'CREATE' | 'UPDATE' | 'DELETE' | 'LOGIN' | 'LOGOUT' | 'VIEW' | 'EXPORT' | 'IMPORT' | 'CUSTOM';\n  entityType: string;\n  entityId: string;\n  entityName?: string;\n  oldValues?: Record<string, any>;\n  newValues?: Record<string, any>;\n  changes?: Record<string, { old: any; new: any }>;\n  severity?: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL';\n  category?: 'GENERAL' | 'SECURITY' | 'BUSINESS' | 'SYSTEM' | 'COMPLIANCE';\n  description?: string;\n  context: AuditContext;\n}\n\nexport interface AuditLogFilter {\n  action?: string;\n  entityType?: string;\n  entityId?: string;\n  userId?: number;\n  merchantId?: number;\n  outletId?: number;\n  severity?: string;\n  category?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  offset?: number;\n}\n\n// Audit logger class\nexport class AuditLogger {\n  private prisma: PrismaClient;\n  private idCounter: number = 0;\n\n  constructor(prisma: PrismaClient) {\n    this.prisma = prisma;\n  }\n\n  // Get next public ID\n  private async getNextPublicId(): Promise<number> {\n    // Temporarily disabled - AuditLog model not in schema\n    return 1;\n  }\n\n  // Main logging method\n  async log(data: AuditLogData): Promise<void> {\n    try {\n      console.log('🔍 AuditLogger.log - Starting audit log creation...');\n      const id = await this.getNextPublicId();\n      console.log('🔍 AuditLogger.log - Got id:', id);\n      \n      // Validate foreign key IDs to prevent constraint violations\n      const validatedUserId = await this.validateUserId(data.context.userId);\n      const validatedMerchantId = await this.validateMerchantId(data.context.merchantId);\n      const validatedOutletId = await this.validateOutletId(data.context.outletId);\n      \n      console.log('🔍 AuditLogger.log - About to create audit log with data:', {\n        id,\n        action: data.action,\n        entityType: data.entityType,\n        entityId: data.entityId,\n        userId: validatedUserId,\n        merchantId: validatedMerchantId,\n        outletId: validatedOutletId\n      });\n      \n      // Temporarily disabled - AuditLog model not in schema\n      console.log('🔍 Audit log would be created:', {\n        id,\n        action: data.action,\n        entityType: data.entityType,\n        entityId: data.entityId\n      });\n      console.log('✅ AuditLogger.log - Audit log created successfully');\n    } catch (error) {\n      // Don't throw errors from audit logging to avoid breaking main operations\n      console.error('❌ AuditLogger.log - Audit logging failed:', error);\n      console.error('❌ AuditLogger.log - Error details:', error instanceof Error ? error.message : String(error));\n      console.error('❌ AuditLogger.log - Error stack:', error instanceof Error ? error.stack : undefined);\n    }\n  }\n\n  // Validate foreign key IDs to prevent constraint violations\n  private async validateUserId(userId?: number): Promise<number | null> {\n    if (!userId) return null;\n    \n    try {\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        select: { id: true }\n      });\n      return user ? userId : null;\n    } catch (error) {\n      console.warn('⚠️ AuditLogger - Failed to validate userId:', userId, error);\n      return null;\n    }\n  }\n\n  private async validateMerchantId(merchantId?: number): Promise<number | null> {\n    if (!merchantId) return null;\n    \n    try {\n      const merchant = await this.prisma.merchant.findUnique({\n        where: { id: merchantId },\n        select: { id: true }\n      });\n      return merchant ? merchantId : null;\n    } catch (error) {\n      console.warn('⚠️ AuditLogger - Failed to validate merchantId:', merchantId, error);\n      return null;\n    }\n  }\n\n  private async validateOutletId(outletId?: number): Promise<number | null> {\n    if (!outletId) return null;\n    \n    try {\n      const outlet = await this.prisma.outlet.findUnique({\n        where: { id: outletId },\n        select: { id: true }\n      });\n      return outlet ? outletId : null;\n    } catch (error) {\n      console.warn('⚠️ AuditLogger - Failed to validate outletId:', outletId, error);\n      return null;\n    }\n  }\n\n  // Convenience methods for common operations\n  async logCreate(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    newValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'CREATE',\n      entityType,\n      entityId,\n      entityName,\n      newValues,\n      description: description || `Created ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logUpdate(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    oldValues: Record<string, any>,\n    newValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    const changes = this.calculateChanges(oldValues, newValues);\n    \n    await this.log({\n      action: 'UPDATE',\n      entityType,\n      entityId,\n      entityName,\n      oldValues,\n      newValues,\n      changes,\n      description: description || `Updated ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logDelete(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    oldValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'DELETE',\n      entityType,\n      entityId,\n      entityName,\n      oldValues,\n      description: description || `Deleted ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logLogin(\n    userId: number,\n    userEmail: string,\n    userRole: string,\n    context: AuditContext,\n    success: boolean = true\n  ): Promise<void> {\n    await this.log({\n      action: 'LOGIN',\n      entityType: 'User',\n      entityId: userId.toString(),\n      entityName: userEmail,\n      newValues: { success, timestamp: new Date().toISOString() },\n      severity: success ? 'INFO' : 'WARNING',\n      category: 'SECURITY',\n      description: success ? `User logged in: ${userEmail}` : `Failed login attempt: ${userEmail}`,\n      context\n    });\n  }\n\n  async logLogout(\n    userId: number,\n    userEmail: string,\n    context: AuditContext\n  ): Promise<void> {\n    await this.log({\n      action: 'LOGOUT',\n      entityType: 'User',\n      entityId: userId.toString(),\n      entityName: userEmail,\n      category: 'SECURITY',\n      description: `User logged out: ${userEmail}`,\n      context\n    });\n  }\n\n  async logSecurityEvent(\n    event: string,\n    entityType: string,\n    entityId: string,\n    context: AuditContext,\n    severity: 'WARNING' | 'ERROR' | 'CRITICAL' = 'WARNING',\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'CUSTOM',\n      entityType,\n      entityId,\n      severity,\n      category: 'SECURITY',\n      description: description || `Security event: ${event}`,\n      context\n    });\n  }\n\n  // Calculate changes between old and new values\n  private calculateChanges(oldValues: Record<string, any>, newValues: Record<string, any>): Record<string, { old: any; new: any }> {\n    const changes: Record<string, { old: any; new: any }> = {};\n    \n    // Check for changed fields\n    const allKeys = new Set([...Object.keys(oldValues), ...Object.keys(newValues)]);\n    \n    for (const key of Array.from(allKeys)) {\n      const oldValue = oldValues[key];\n      const newValue = newValues[key];\n      \n      if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n        changes[key] = { old: oldValue, new: newValue };\n      }\n    }\n    \n    return changes;\n  }\n\n  // Query audit logs\n  async getAuditLogs(filter: AuditLogFilter = {}): Promise<{\n    logs: any[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const where: any = {};\n    \n    if (filter.action) where.action = filter.action;\n    if (filter.entityType) where.entityType = filter.entityType;\n    if (filter.entityId) where.entityId = filter.entityId;\n    if (filter.userId) where.userId = filter.userId;\n    if (filter.merchantId) where.merchantId = filter.merchantId;\n    if (filter.outletId) where.outletId = filter.outletId;\n    if (filter.severity) where.severity = filter.severity;\n    if (filter.category) where.category = filter.category;\n    \n    if (filter.startDate || filter.endDate) {\n      where.createdAt = {};\n      if (filter.startDate) where.createdAt.gte = filter.startDate;\n      if (filter.endDate) where.createdAt.lte = filter.endDate;\n    }\n\n    const limit = filter.limit || 50;\n    const offset = filter.offset || 0;\n\n    // Temporarily disabled - AuditLog model not in schema\n    const logs: any[] = [];\n    const total = 0;\n\n    // Transform logs to include parsed JSON fields\n    const transformedLogs = logs.map(log => ({\n      id: log.id,\n      action: log.action,\n      entityType: log.entityType,\n      entityId: log.entityId,\n      entityName: log.entityName,\n      user: log.user ? {\n        id: log.user.id,\n        email: log.user.email,\n        name: `${log.user.firstName} ${log.user.lastName}`,\n        role: log.user.role\n      } : null,\n      merchant: log.merchant ? {\n        id: log.merchant.id,\n        name: log.merchant.name\n      } : null,\n      outlet: log.outlet ? {\n        id: log.outlet.id,\n        name: log.outlet.name\n      } : null,\n      oldValues: log.oldValues ? JSON.parse(log.oldValues) : null,\n      newValues: log.newValues ? JSON.parse(log.newValues) : null,\n      changes: log.changes ? JSON.parse(log.changes) : null,\n      ipAddress: log.ipAddress,\n      userAgent: log.userAgent,\n      sessionId: log.sessionId,\n      requestId: log.requestId,\n      metadata: log.metadata ? JSON.parse(log.metadata) : null,\n      severity: log.severity,\n      category: log.category,\n      description: log.description,\n      createdAt: log.createdAt\n    }));\n\n    return {\n      logs: transformedLogs,\n      total,\n      hasMore: offset + limit < total\n    };\n  }\n\n  // Get audit statistics\n  async getAuditStats(filter: Partial<AuditLogFilter> = {}): Promise<{\n    totalLogs: number;\n    logsByAction: Record<string, number>;\n    logsByEntity: Record<string, number>;\n    logsBySeverity: Record<string, number>;\n    logsByCategory: Record<string, number>;\n    recentActivity: number; // Last 24 hours\n  }> {\n    const where: any = {};\n    \n    if (filter.merchantId) where.merchantId = filter.merchantId;\n    if (filter.outletId) where.outletId = filter.outletId;\n    if (filter.startDate || filter.endDate) {\n      where.createdAt = {};\n      if (filter.startDate) where.createdAt.gte = filter.startDate;\n      if (filter.endDate) where.createdAt.lte = filter.endDate;\n    }\n\n    // Temporarily disabled - AuditLog model not in schema\n    const totalLogs = 0;\n    const actionStats: any[] = [];\n    const entityStats: any[] = [];\n    const severityStats: any[] = [];\n    const categoryStats: any[] = [];\n    const recentActivity = 0;\n\n    return {\n      totalLogs,\n      logsByAction: actionStats.reduce((acc, item) => {\n        acc[item.action] = item._count.action;\n        return acc;\n      }, {} as Record<string, number>),\n      logsByEntity: entityStats.reduce((acc, item) => {\n        acc[item.entityType] = item._count.entityType;\n        return acc;\n      }, {} as Record<string, number>),\n      logsBySeverity: severityStats.reduce((acc, item) => {\n        acc[item.severity] = item._count.severity;\n        return acc;\n      }, {} as Record<string, number>),\n      logsByCategory: categoryStats.reduce((acc, item) => {\n        acc[item.category] = item._count.category;\n        return acc;\n      }, {} as Record<string, number>),\n      recentActivity\n    };\n  }\n}\n\n// Create singleton instance\nlet auditLogger: AuditLogger | null = null;\n\nexport function getAuditLogger(prisma?: PrismaClient): AuditLogger {\n  if (!auditLogger) {\n    if (!prisma) {\n      throw new Error('Prisma client is required for audit logging');\n    }\n    auditLogger = new AuditLogger(prisma);\n  }\n  return auditLogger;\n}\n\n// Helper function to extract audit context from request\nexport function extractAuditContext(request: Request, user?: any): AuditContext {\n  const headers = request.headers;\n  \n  return {\n    userId: user?.id,\n    userEmail: user?.email,\n    userRole: user?.role,\n    merchantId: user?.merchantId,\n    outletId: user?.outletId,\n    ipAddress: headers.get('x-forwarded-for') || headers.get('x-real-ip') || 'unknown',\n    userAgent: headers.get('user-agent') || 'unknown',\n    sessionId: headers.get('x-session-id') || undefined,\n    requestId: headers.get('x-request-id') || undefined,\n    metadata: {\n      method: request.method,\n      url: request.url,\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n","// ============================================================================\n// SMART REGISTRATION - HANDLES ALL USER ROLES\n// ============================================================================\n\nimport { prisma } from './client';\nimport { createUser } from './user';\nimport { createSubscription } from './subscription';\nimport { hashPassword } from '@rentalshop/auth';\nimport type { UserCreateInput } from '@rentalshop/types';\n\nexport interface RegistrationInput {\n  email: string;\n  password: string;\n  name: string;\n  phone?: string;\n  role?: 'CLIENT' | 'SHOP_OWNER' | 'ADMIN' | 'MERCHANT' | 'OUTLET_ADMIN' | 'OUTLET_STAFF';\n  // For merchant registration\n  businessName?: string;\n  outletName?: string;\n  // Business configuration (locked after registration)\n  businessType?: 'RENTAL' | 'SALE' | 'MIXED';\n  pricingType?: 'FIXED' | 'DYNAMIC' | 'DURATION_BASED';\n  // Address fields for merchant registration\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  // For outlet staff/admin registration\n  merchantCode?: string;\n  outletCode?: string;\n}\n\nexport interface RegistrationResult {\n  success: boolean;\n  user: {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    role: string;\n    merchant?: {\n      id: number;\n      name: string;\n    };\n    outlet?: {\n      id: number;\n      name: string;\n    };\n  };\n  token: string;\n  message: string;\n}\n\n/**\n * Smart registration that handles all user roles\n * Based on role and provided data, creates appropriate account structure\n */\nexport async function registerUser(\n  data: RegistrationInput\n): Promise<RegistrationResult> {\n  try {\n    // Start transaction to ensure all operations succeed or fail together\n    const result = await prisma.$transaction(async (tx: any) => {\n      // 1. Check if user email already exists\n      const existingUser = await tx.user.findUnique({\n        where: { email: data.email }\n      });\n\n      if (existingUser) {\n        throw new Error('User with this email already exists');\n      }\n\n      // Determine registration type based on role and data\n      const registrationType = determineRegistrationType(data);\n\n      if (registrationType === 'MERCHANT') {\n        return await registerMerchant(tx, data);\n      } else if (registrationType === 'OUTLET_ADMIN' || registrationType === 'OUTLET_STAFF') {\n        return await registerOutletUser(tx, data);\n      } else {\n        return await registerBasicUser(tx, data);\n      }\n    });\n\n    return result;\n  } catch (error: any) {\n    console.error('Registration error:', error);\n    throw new Error(error.message || 'Registration failed');\n  }\n}\n\n/**\n * Determine registration type based on input data\n */\nfunction determineRegistrationType(data: RegistrationInput): 'MERCHANT' | 'OUTLET_ADMIN' | 'OUTLET_STAFF' | 'BASIC' {\n  // If role is explicitly set, use it\n  if (data.role === 'MERCHANT') {\n    return 'MERCHANT';\n  }\n  if (data.role === 'OUTLET_ADMIN' || data.role === 'OUTLET_STAFF') {\n    return data.role;\n  }\n\n  // If businessName is provided, assume merchant registration\n  if (data.businessName) {\n    return 'MERCHANT';\n  }\n\n  // If merchantCode is provided, assume outlet user registration\n  if (data.merchantCode) {\n    return 'OUTLET_STAFF'; // Default to staff, can be upgraded to admin\n  }\n\n  // Default to basic user registration\n  return 'BASIC';\n}\n\n/**\n * Register merchant with auto-created default outlet\n */\nasync function registerMerchant(tx: any, data: RegistrationInput) {\n  // 1. Check if merchant email already exists\n  const existingMerchant = await tx.merchant.findUnique({\n    where: { email: data.email }\n  });\n\n  if (existingMerchant) {\n    throw new Error('Merchant with this email already exists');\n  }\n\n  // 2. Get or create trial plan (modern SaaS pattern)\n  let trialPlan = await tx.plan.findFirst({\n    where: { \n      name: 'Trial',\n      isActive: true \n    }\n  });\n\n  if (!trialPlan) {\n    // Auto-create trial plan if none exists (modern SaaS pattern)\n    console.log('Creating trial plan automatically...');\n    \n    trialPlan = await tx.plan.create({\n      data: {\n        name: 'Trial',\n        description: 'Free trial plan for new merchants to test the platform',\n        basePrice: 0, // Free\n        currency: 'USD',\n        trialDays: 14,\n        limits: JSON.stringify({\n          outlets: 1,\n          users: 2,\n          products: 25,\n          customers: 50\n        }),\n        features: JSON.stringify([\n          'Basic inventory management',\n          'Customer management',\n          'Order processing (limited)',\n          'Basic reporting',\n          'Email support',\n          'Mobile app access',\n          '14-day free trial'\n        ]),\n        isActive: true,\n        isPopular: false,\n        sortOrder: 0 // Show first\n      }\n    });\n    console.log('✅ Trial plan created automatically');\n  }\n\n  // 3. Generate merchant id\n  const lastMerchant = await tx.merchant.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const merchantId = (lastMerchant?.id || 0) + 1;\n\n  // 4. Create merchant\n  const merchant = await tx.merchant.create({\n    data: {\n      id: merchantId,\n      name: data.businessName || `${data.name}'s Business`,\n      email: data.email,\n      phone: data.phone,\n      address: data.address,\n      city: data.city,\n      state: data.state,\n      zipCode: data.zipCode,\n      country: data.country,\n      isActive: true\n      // subscriptionStatus removed - will be set in subscription.status\n    }\n  });\n\n  // 5. Create default outlet with merchant information FIRST\n  const lastOutlet = await tx.outlet.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const outletId = (lastOutlet?.id || 0) + 1;\n\n  const outlet = await tx.outlet.create({\n    data: {\n      id: outletId,\n      name: data.outletName || 'Main Store',\n      // Always use merchant's information as primary source, with user input as fallback\n      address: merchant.address || data.address || 'Address to be updated',\n      phone: merchant.phone || data.phone,\n      city: merchant.city || data.city,\n      state: merchant.state || data.state,\n      zipCode: merchant.zipCode || data.zipCode,\n      country: merchant.country || data.country,\n      description: 'Default outlet created during registration',\n      merchantId: merchant.id,\n      isActive: true,\n      isDefault: true\n    }\n  });\n\n  // 6. Create default category for merchant\n  const lastCategory = await tx.category.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const categoryId = (lastCategory?.id || 0) + 1;\n\n  const defaultCategory = await tx.category.create({\n    data: {\n      id: categoryId,\n      name: 'General',\n      description: 'Default category for general products',\n      merchantId: merchant.id,\n      isActive: true\n    }\n  });\n\n  // 7. Create merchant user with outlet assignment\n  const hashedPassword = await hashPassword(data.password);\n  \n  const lastUser = await tx.user.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const userId = (lastUser?.id || 0) + 1;\n\n  const user = await tx.user.create({\n    data: {\n      id: userId,\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: 'MERCHANT',\n      merchantId: merchant.id,\n      outletId: outletId, // Assign default outlet to merchant user\n      isActive: true\n    }\n  });\n\n  // 8. Create trial subscription\n  const subscriptionStartDate = new Date();\n  const endDate = new Date(subscriptionStartDate.getTime() + (trialPlan.trialDays * 24 * 60 * 60 * 1000));\n  \n  const lastSubscription = await tx.subscription.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const subscriptionId = (lastSubscription?.id || 0) + 1;\n\n  const subscription = await tx.subscription.create({\n    data: {\n      id: subscriptionId,\n      merchantId: merchant.id,\n      planId: trialPlan.id,\n      status: 'trial',\n      amount: 0, // Free trial\n      currency: 'USD',\n      interval: 'month', // Default to monthly for trial\n      intervalCount: 1, // 1 month intervals\n      currentPeriodStart: subscriptionStartDate,\n      currentPeriodEnd: endDate,\n      trialStart: subscriptionStartDate,\n      trialEnd: endDate,\n      cancelAtPeriodEnd: false\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n      merchant: {\n        id: merchant.id,\n        name: merchant.name\n      },\n      outlet: {\n        id: outlet.id,\n        name: outlet.name\n      }\n    },\n    token: '', // Will be generated by auth service\n    message: 'Merchant account created successfully with default outlet'\n  };\n}\n\n/**\n * Register merchant with trial plan (wrapper function for API)\n */\nexport async function registerMerchantWithTrial(data: any) {\n  // Transform API data to RegistrationInput format\n  const registrationData: RegistrationInput = {\n    email: data.userEmail,\n    password: data.userPassword,\n    name: `${data.userFirstName} ${data.userLastName}`,\n    phone: data.userPhone,\n    role: 'MERCHANT',\n    businessName: data.merchantName,\n    outletName: data.outletName,\n    address: data.outletAddress\n  };\n\n  const result = await registerUser(registrationData);\n  \n  if (!result.success) {\n    throw new Error(result.message);\n  }\n\n  // Transform result to match expected API format\n  return {\n    merchant: {\n      id: result.user.merchant?.id,\n      name: result.user.merchant?.name,\n      email: result.user.email\n    },\n    user: {\n      id: result.user.id,\n      email: result.user.email,\n      firstName: result.user.firstName,\n      lastName: result.user.lastName,\n      role: result.user.role\n    },\n    outlet: {\n      id: result.user.outlet?.id,\n      name: result.user.outlet?.name\n    },\n    subscription: {\n      planName: 'Trial',\n      trialEnd: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000) // 14 days from now\n    }\n  };\n}\n\n/**\n * Register outlet admin/staff with merchant/outlet lookup\n */\nasync function registerOutletUser(tx: any, data: RegistrationInput) {\n  if (!data.merchantCode) {\n    throw new Error('Merchant code is required for outlet user registration');\n  }\n\n  // 1. Find merchant by code (assuming merchantCode is the merchant's id)\n  const merchant = await tx.merchant.findUnique({\n    where: { id: parseInt(data.merchantCode) }\n  });\n\n  if (!merchant) {\n    throw new Error('Invalid merchant code. Please check with your manager.');\n  }\n\n  // 2. Find outlet if outletCode provided\n  let outlet = null;\n  if (data.outletCode) {\n    outlet = await tx.outlet.findUnique({\n      where: { \n        id: parseInt(data.outletCode),\n        merchantId: merchant.id \n      }\n    });\n\n    if (!outlet) {\n      throw new Error('Invalid outlet code. Please check with your manager.');\n    }\n  } else {\n    // Find default outlet for this merchant\n    outlet = await tx.outlet.findFirst({\n      where: { \n        merchantId: merchant.id,\n        isDefault: true \n      }\n    });\n\n    if (!outlet) {\n      // Create a default outlet if none exists\n      const lastOutlet = await tx.outlet.findFirst({\n        orderBy: { id: 'desc' }\n      });\n      const outletId = (lastOutlet?.id || 0) + 1;\n\n      outlet = await tx.outlet.create({\n        data: {\n          id: outletId,\n          name: `${merchant.name} - Main Store`,\n          address: merchant.address || 'Address to be updated',\n          phone: merchant.phone,\n          city: merchant.city,\n          state: merchant.state,\n          zipCode: merchant.zipCode,\n          country: merchant.country,\n          description: 'Default outlet for staff',\n          merchantId: merchant.id,\n          isActive: true,\n          isDefault: true\n        }\n      });\n    }\n  }\n\n  // 3. Create outlet user\n  const hashedPassword = await hashPassword(data.password);\n  \n  const lastUser = await tx.user.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const userId = (lastUser?.id || 0) + 1;\n\n  const user = await tx.user.create({\n    data: {\n      id: userId,\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: data.role || 'OUTLET_STAFF',\n      merchantId: merchant.id,\n      outletId: outlet.id,\n      isActive: true\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n      merchant: {\n        id: merchant.id,\n        name: merchant.name\n      },\n      outlet: {\n        id: outlet.id,\n        name: outlet.name\n      }\n    },\n    token: '', // Will be generated by auth service\n    message: `${data.role === 'OUTLET_ADMIN' ? 'Outlet admin' : 'Staff'} account created successfully`\n  };\n}\n\n/**\n * Register basic user (CLIENT, SHOP_OWNER, ADMIN)\n */\nasync function registerBasicUser(tx: any, data: RegistrationInput) {\n  const hashedPassword = await hashPassword(data.password);\n  \n  const lastUser = await tx.user.findFirst({\n    orderBy: { id: 'desc' }\n  });\n  const userId = (lastUser?.id || 0) + 1;\n\n  const user = await tx.user.create({\n    data: {\n      id: userId,\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: data.role || 'CLIENT',\n      isActive: true\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n    },\n    token: '', // Will be generated by auth service\n    message: 'User account created successfully'\n  };\n}\n","// ============================================================================\n// SIMPLIFIED DATABASE PACKAGE EXPORTS - NEW VERSION\n// ============================================================================\n// This is the new, simplified version that replaces the complex dual ID system\n// Goal: Reduce from 139 exports to ~10 simple functions\n\nimport { prisma } from './client';\nimport { simplifiedUsers } from './user';\nimport { simplifiedCustomers } from './customer';\nimport { simplifiedProducts } from './product';\nimport { simplifiedOrders } from './order';\nimport { simplifiedPayments } from './payment';\nimport { simplifiedOutlets } from './outlet';\nimport { simplifiedPlans } from './plan';\nimport { simplifiedSubscriptions } from './subscription';\nimport { simplifiedSubscriptionActivities } from './subscription-activity';\nimport { simplifiedMerchants } from './merchant';\nimport { simplifiedOrderNumbers } from './order-number-generator';\nimport { simplifiedCategories } from './category';\nimport { simplifiedAuditLogs } from './audit-logs';\nimport { simplifiedOrderItems } from './order-items';\nimport { sessions } from './sessions';\n\n// Optimized order functions (temporarily disabled due to type issues)\n// export { \n//   searchOrdersOptimized, \n//   searchOrdersWithCursor, \n//   getOrderDetailsOptimized, \n//   getOrderSummary \n// } from './order-optimized';\n\n// Database client\nexport { prisma };\n\n// ============================================================================\n// TYPES FOR SIMPLIFIED API\n// ============================================================================\n\nexport interface SimpleFilters {\n  merchantId?: number;\n  outletId?: number;\n  isActive?: boolean;\n  search?: string;\n  page?: number;\n  limit?: number;\n}\n\nexport interface SimpleResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  hasMore: boolean;\n}\n\n// ============================================================================\n// SIMPLIFIED DATABASE API\n// ============================================================================\n\n/**\n * Simplified database operations\n * Replaces the complex dual ID system with simple, consistent operations\n */\nconst db = {\n  // ============================================================================\n  // PRISMA CLIENT (for transactions)\n  // ============================================================================\n  prisma,\n\n  // ============================================================================\n  // USER OPERATIONS\n  // ============================================================================\n  users: simplifiedUsers,\n\n  // ============================================================================\n  // CUSTOMER OPERATIONS\n  // ============================================================================\n  customers: simplifiedCustomers,\n\n  // ============================================================================\n  // PRODUCT OPERATIONS\n  // ============================================================================\n  products: simplifiedProducts,\n\n  // ============================================================================\n  // ORDER OPERATIONS\n  // ============================================================================\n  orders: simplifiedOrders,\n\n  // ============================================================================\n  // PAYMENT OPERATIONS\n  // ============================================================================\n  payments: simplifiedPayments,\n\n  // ============================================================================\n  // OUTLET OPERATIONS\n  // ============================================================================\n  outlets: simplifiedOutlets,\n\n  // ============================================================================\n  // MERCHANT OPERATIONS\n  // ============================================================================\n  merchants: simplifiedMerchants,\n\n  // ============================================================================\n  // PLAN OPERATIONS\n  // ============================================================================\n  plans: simplifiedPlans,\n\n  // ============================================================================\n  // CATEGORY OPERATIONS\n  // ============================================================================\n  categories: simplifiedCategories,\n\n  // ============================================================================\n  // AUDIT LOG OPERATIONS\n  // ============================================================================\n  auditLogs: simplifiedAuditLogs,\n\n  // ============================================================================\n  // ORDER ITEM OPERATIONS\n  // ============================================================================\n  orderItems: simplifiedOrderItems,\n\n  // ============================================================================\n  // SUBSCRIPTION OPERATIONS\n  // ============================================================================\n  subscriptions: simplifiedSubscriptions,\n\n  // ============================================================================\n  // ORDER NUMBER OPERATIONS\n  // ============================================================================\n  orderNumbers: simplifiedOrderNumbers,\n\n  // ============================================================================\n  // OUTLET STOCK OPERATIONS\n  // ============================================================================\n  outletStock: {\n    /**\n     * Aggregate outlet stock statistics\n     */\n    aggregate: async (options: any) => {\n      return await prisma.outletStock.aggregate(options);\n    }\n  },\n\n  // ============================================================================\n  // SUBSCRIPTION ACTIVITY OPERATIONS\n  // ============================================================================\n  subscriptionActivities: simplifiedSubscriptionActivities,\n\n  // ============================================================================\n  // SESSION OPERATIONS (Single Session Enforcement)\n  // ============================================================================\n  sessions\n};\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check database connection health\n */\nconst checkDatabaseConnection = async () => {\n  try {\n    await prisma.$queryRaw`SELECT 1`;\n    return { status: 'connected' };\n  } catch (error) {\n    return { status: 'disconnected', error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n};\n\n/**\n * Generate next order number (simplified)\n */\nconst generateOrderNumber = async (outletId: number): Promise<string> => {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Get the count of orders for this outlet\n  const orderCount = await prisma.order.count({\n    where: { outletId }\n  });\n\n  const sequence = (orderCount + 1).toString().padStart(4, '0');\n  return `ORD-${outletId.toString().padStart(3, '0')}-${sequence}`;\n};\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport { db, checkDatabaseConnection, generateOrderNumber };\n\n// Export payment functions\nexport { simplifiedPayments } from './payment';\n\n// Export subscription activity functions\nexport { simplifiedSubscriptionActivities } from './subscription-activity';\n\n// Legacy exports for backward compatibility\nexport { getSubscriptionByMerchantId, createSubscriptionPayment, updateSubscription, getExpiredSubscriptions, getSubscriptionById } from './subscription';\nexport { AuditLogger, getAuditLogger, extractAuditContext } from './audit';\nexport type { AuditContext } from './audit';\nexport { getOutletOrderStats, createOrderNumberWithFormat } from './order-number-generator';\nexport type { OrderNumberFormat } from './order-number-generator';\nexport { searchOrders } from './order'; // Legacy order search function\n\n// Registration functions\nexport { registerUser, registerMerchantWithTrial } from './registration';\nexport type { RegistrationInput, RegistrationResult } from './registration';\n\n// ============================================================================\n// MIGRATION GUIDE\n// ============================================================================\n/*\nOLD WAY (139 exports):\nimport { \n  findOutletByPublicId, \n  convertOutletPublicIdToDatabaseId,\n  getCustomerByPublicId as getCustomerById,\n  getOutletByPublicId as getOutletById,\n  // ... 135 more exports\n} from '@rentalshop/database';\n\nNEW WAY (3 main exports):\nimport { db, prisma, checkDatabaseConnection } from '@rentalshop/database';\n\n// Usage examples:\nconst user = await db.users.findById(123);\nconst users = await db.users.search({ merchantId: 1, page: 1, limit: 20 });\nconst product = await db.products.findByBarcode('123456789');\nconst orders = await db.orders.search({ outletId: 1, status: 'ACTIVE' });\n\nBENEFITS:\n✅ 93% reduction in exports (139 → 10)\n✅ Consistent API across all entities\n✅ No more dual ID complexity\n✅ Better TypeScript support\n✅ Easier to maintain and debug\n✅ Better performance with optimized queries\n*/\n"],"mappings":"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","names":["findById","search","randomBytes","count","count","findById","create","update","search","getStats","findMany","getStats","findFirst","create","findMany","getStats","findFirst","create","update","prisma","generateOrderNumber"]}