{"version":3,"sources":["../src/client.ts","../../constants/src/pagination.ts","../../constants/src/search.ts","../../constants/src/validation.ts","../../constants/src/ui.ts","../../constants/src/business.ts","../../constants/src/environment.ts","../../constants/src/api.ts","../../constants/src/colors.ts","../../constants/src/status.ts","../../constants/src/orders.ts","../../constants/src/subscription.ts","../../constants/src/pricing.ts","../../constants/src/countries.ts","../../constants/src/currency.ts","../../constants/src/index.ts","../src/product.ts","../src/index.ts","../src/user.ts","../src/customer.ts","../src/order.ts","../src/payment.ts","../src/outlet.ts","../src/plan.ts","../src/subscription.ts","../src/subscription-activity.ts","../src/merchant.ts","../src/order-number-generator.ts","../src/category.ts","../src/audit-logs.ts","../src/order-items.ts","../src/sessions.ts","../src/sync.ts","../src/audit.ts","../src/registration.ts","../src/email-verification.ts","../src/password-reset.ts","../src/query-builder.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\n// Global Prisma client instance for singleton pattern\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\n// Create Prisma Client instance\nfunction createPrismaClient(): PrismaClient {\n  return new PrismaClient({\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n  });\n}\n\n// Export Prisma client instance with singleton pattern\nexport const prisma = globalForPrisma.prisma ?? createPrismaClient();\n\n// Store in global for development hot reload\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma;\n} ","/**\n * Pagination and List Constants\n * \n * These constants define limits for various list operations across the application\n */\n\nexport const PAGINATION = {\n  // Search and List Limits\n  SEARCH_LIMIT: 20,\n  DEFAULT_PAGE_SIZE: 25,\n  MAX_PAGE_SIZE: 20,\n  \n  // Dashboard Limits\n  DASHBOARD_ITEMS: 10,\n  RECENT_ORDERS: 5,\n  TOP_PRODUCTS: 8,\n  TOP_CUSTOMERS: 6,\n  \n  // Mobile Limits\n  MOBILE_SEARCH_LIMIT: 15,\n  MOBILE_PAGE_SIZE: 20,\n  \n  // API Limits\n  API_MAX_LIMIT: 1000,\n  API_DEFAULT_LIMIT: 50,\n} as const;\n\n// Type for pagination values\nexport type PaginationValue = typeof PAGINATION[keyof typeof PAGINATION];\n","/**\n * Search and Query Constants\n * \n * These constants define search behavior and query limits\n */\n\nexport const SEARCH = {\n  // Debounce and Timing\n  DEBOUNCE_MS: 300,\n  MIN_QUERY_LENGTH: 2,\n  MAX_QUERY_LENGTH: 100,\n  \n  // Suggestion and Results\n  SUGGESTION_LIMIT: 5,\n  MAX_SEARCH_RESULTS: 1000,\n  \n  // Auto-complete\n  AUTOCOMPLETE_DELAY: 200,\n  AUTOCOMPLETE_MIN_CHARS: 1,\n  \n  // Search Types\n  PRODUCT_SEARCH: 'product',\n  CUSTOMER_SEARCH: 'customer',\n  ORDER_SEARCH: 'order',\n} as const;\n\n// Type for search values\nexport type SearchValue = typeof SEARCH[keyof typeof SEARCH];\n","/**\n * Validation and Business Rule Constants\n * \n * These constants define validation rules and business logic limits\n */\n\nexport const VALIDATION = {\n  // Rental Rules\n  MIN_RENTAL_DAYS: 1,\n  MAX_RENTAL_DAYS: 365,\n  \n  // Stock and Inventory\n  LOW_STOCK_THRESHOLD: 2,\n  CRITICAL_STOCK_THRESHOLD: 0,\n  MAX_STOCK_QUANTITY: 9999,\n  \n  // User Input\n  MIN_PASSWORD_LENGTH: 8,\n  MAX_PASSWORD_LENGTH: 128,\n  MIN_NAME_LENGTH: 1,\n  MAX_NAME_LENGTH: 100,\n  MAX_PHONE_LENGTH: 20,\n  MAX_EMAIL_LENGTH: 255,\n  \n  // Order Rules\n  MIN_ORDER_AMOUNT: 0.01,\n  MAX_ORDER_AMOUNT: 999999.99,\n  MAX_ORDER_ITEMS: 50,\n  \n  // Financial\n  MIN_DEPOSIT_AMOUNT: 0,\n  MAX_DEPOSIT_AMOUNT: 99999.99,\n  MIN_DISCOUNT_AMOUNT: 0,\n  MAX_DISCOUNT_PERCENTAGE: 100,\n  \n  // File Uploads\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/webp'],\n} as const;\n\n// Type for validation values\nexport type ValidationValue = typeof VALIDATION[keyof typeof VALIDATION];\n","/**\n * UI and User Experience Constants\n * \n * These constants define UI behavior, animations, and user experience settings\n */\n\nexport const UI = {\n  // Animation and Timing\n  ANIMATION_DURATION: 200,\n  TRANSITION_DURATION: 150,\n  HOVER_DELAY: 100,\n  \n  // Toast and Notifications\n  TOAST_DURATION: 5000,\n  TOAST_DURATION_LONG: 10000,\n  TOAST_DURATION_SHORT: 3000,\n  \n  // Loading States\n  LOADING_DELAY: 1000,\n  SKELETON_DURATION: 1500,\n  \n  // Debounce and Throttle\n  DEBOUNCE_DELAY: 300,\n  THROTTLE_DELAY: 100,\n  \n  // Scroll and Pagination\n  INFINITE_SCROLL_THRESHOLD: 100,\n  SCROLL_TO_TOP_THRESHOLD: 500,\n  \n  // Breakpoints (in pixels)\n  BREAKPOINTS: {\n    MOBILE: 768,\n    TABLET: 1024,\n    DESKTOP: 1280,\n    LARGE_DESKTOP: 1536,\n  },\n  \n  // Z-Index Layers\n  Z_INDEX: {\n    DROPDOWN: 1000,\n    MODAL: 2000,\n    TOOLTIP: 3000,\n    TOAST: 4000,\n    OVERLAY: 5000,\n  },\n} as const;\n\n// Type for UI values\nexport type UIValue = typeof UI[keyof typeof UI];\n","/**\n * Business Logic Constants\n * \n * These constants define business rules, defaults, and operational values\n */\n\nexport const BUSINESS = {\n  // Order Defaults\n  DEFAULT_QUANTITY: 1,\n  DEFAULT_DEPOSIT: 0,\n  DEFAULT_DISCOUNT: 0,\n  DEFAULT_TAX_RATE: 0,\n  \n  // Order Limits\n  MAX_ORDER_ITEMS: 50,\n  MIN_ORDER_AMOUNT: 0.01,\n  MAX_ORDER_AMOUNT: 999999.99,\n  \n  // Rental Rules\n  MIN_RENTAL_DAYS: 1,\n  MAX_RENTAL_DAYS: 365,\n  \n  // Customer Defaults\n  DEFAULT_CUSTOMER_TYPE: 'WALK_IN',\n  DEFAULT_CUSTOMER_STATUS: 'ACTIVE',\n  \n  // Product Defaults\n  DEFAULT_PRODUCT_STATUS: 'ACTIVE',\n  DEFAULT_PRODUCT_CATEGORY: 'UNCATEGORIZED',\n  \n  // Rental Defaults\n  DEFAULT_RENTAL_PERIOD: 1, // days\n  DEFAULT_LATE_FEE_RATE: 0.1, // 10% per day\n  DEFAULT_DAMAGE_FEE: 0,\n  \n  // Payment Defaults\n  DEFAULT_PAYMENT_METHOD: 'CASH',\n  DEFAULT_PAYMENT_STATUS: 'PENDING',\n  \n  // Outlet Defaults\n  DEFAULT_OUTLET_STATUS: 'ACTIVE',\n  DEFAULT_OUTLET_TYPE: 'RETAIL',\n  \n  // User Defaults\n  DEFAULT_USER_STATUS: 'ACTIVE',\n  DEFAULT_USER_ROLE: 'OUTLET_STAFF',\n  \n  // Notification Defaults\n  DEFAULT_NOTIFICATION_TYPE: 'INFO',\n  DEFAULT_NOTIFICATION_PRIORITY: 'NORMAL',\n  \n  // Rental Shop Specific\n  DEFAULT_PICKUP_TIME: '09:00',\n  DEFAULT_RETURN_TIME: '17:00',\n  BUSINESS_HOURS: {\n    OPEN: '08:00',\n    CLOSE: '18:00',\n    BREAK_START: '12:00',\n    BREAK_END: '13:00',\n  },\n  \n  // Inventory Management\n  LOW_STOCK_WARNING: 5,\n  CRITICAL_STOCK_WARNING: 2,\n  AUTO_REORDER_THRESHOLD: 3,\n  \n  // Customer Management\n  MAX_CUSTOMER_ORDERS: 100,\n  CUSTOMER_CREDIT_LIMIT: 1000,\n  LOYALTY_POINTS_RATE: 0.01, // 1 point per $1 spent\n  \n  // Order Processing\n  ORDER_PREPARATION_TIME: 30, // minutes\n  PICKUP_GRACE_PERIOD: 15, // minutes\n  RETURN_GRACE_PERIOD: 30, // minutes\n  \n  // Financial Rules\n  MIN_DEPOSIT_PERCENTAGE: 0.1, // 10% of order value\n  MAX_DEPOSIT_PERCENTAGE: 0.5, // 50% of order value\n  LATE_FEE_CAP: 100, // Maximum late fee per order\n  DAMAGE_FEE_CAP: 500, // Maximum damage fee per item\n} as const;\n\n// Type for business values\nexport type BusinessValue = typeof BUSINESS[keyof typeof BUSINESS];\n","/**\n * Environment-Specific Constants\n * \n * These constants can vary based on the environment (development, staging, production)\n */\n\nexport const ENVIRONMENT = {\n  // API Configuration\n  API_TIMEOUT: process.env.NODE_ENV === 'production' ? 10000 : 30000,\n  API_RETRY_ATTEMPTS: process.env.NODE_ENV === 'production' ? 3 : 1,\n  \n  // Search and Pagination (Production vs Development)\n  SEARCH_LIMIT: process.env.NODE_ENV === 'production' ? 50 : 20,\n  DASHBOARD_ITEMS: process.env.NODE_ENV === 'production' ? 20 : 10,\n  \n  // Caching\n  CACHE_TTL: process.env.NODE_ENV === 'production' ? 300 : 60, // seconds\n  CACHE_MAX_SIZE: process.env.NODE_ENV === 'production' ? 1000 : 100,\n  \n  // Logging\n  LOG_LEVEL: process.env.NODE_ENV === 'production' ? 'error' : 'debug',\n  LOG_RETENTION: process.env.NODE_ENV === 'production' ? 30 : 7, // days\n  \n  // Performance\n  DEBOUNCE_DELAY: process.env.NODE_ENV === 'production' ? 500 : 300,\n  THROTTLE_DELAY: process.env.NODE_ENV === 'production' ? 200 : 100,\n  \n  // Security\n  SESSION_TIMEOUT: process.env.NODE_ENV === 'production' ? 3600 : 7200, // seconds\n  MAX_LOGIN_ATTEMPTS: process.env.NODE_ENV === 'production' ? 5 : 10,\n  \n  // Feature Flags\n  ENABLE_ANALYTICS: process.env.NODE_ENV === 'production',\n  ENABLE_DEBUG_MODE: process.env.NODE_ENV !== 'production',\n  ENABLE_PERFORMANCE_MONITORING: process.env.NODE_ENV === 'production',\n} as const;\n\n// Type for environment values\nexport type EnvironmentValue = typeof ENVIRONMENT[keyof typeof ENVIRONMENT];\n","/**\n * API and Network Constants\n * \n * These constants define API behavior, endpoints, and network settings\n */\n\nexport const API = {\n  // HTTP Status Codes\n  STATUS: {\n    OK: 200,\n    CREATED: 201,\n    NO_CONTENT: 204,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402, // For subscription errors (expired, paused, etc.)\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    CONFLICT: 409,\n    UNPROCESSABLE_ENTITY: 422,\n    INTERNAL_SERVER_ERROR: 500,\n    SERVICE_UNAVAILABLE: 503,\n  },\n  \n  // HTTP Methods\n  METHODS: {\n    GET: 'GET',\n    POST: 'POST',\n    PUT: 'PUT',\n    PATCH: 'PATCH',\n    DELETE: 'DELETE',\n  },\n  \n  // Content Types\n  CONTENT_TYPES: {\n    JSON: 'application/json',\n    FORM_DATA: 'multipart/form-data',\n    TEXT: 'text/plain',\n    HTML: 'text/html',\n  },\n  \n  // Headers\n  HEADERS: {\n    AUTHORIZATION: 'Authorization',\n    CONTENT_TYPE: 'Content-Type',\n    ACCEPT: 'Accept',\n    USER_AGENT: 'User-Agent',\n    CACHE_CONTROL: 'Cache-Control',\n  },\n  \n  // Rate Limiting\n  RATE_LIMITS: {\n    REQUESTS_PER_MINUTE: 60,\n    REQUESTS_PER_HOUR: 1000,\n    BURST_LIMIT: 10,\n  },\n  \n  // Timeouts\n  TIMEOUTS: {\n    CONNECT: 5000,\n    READ: 30000,\n    WRITE: 30000,\n    IDLE: 60000,\n  },\n  \n  // Retry Configuration\n  RETRY: {\n    MAX_ATTEMPTS: 3,\n    INITIAL_DELAY: 1000,\n    MAX_DELAY: 10000,\n    BACKOFF_MULTIPLIER: 2,\n  },\n  \n  // Cache Headers\n  CACHE: {\n    NO_CACHE: 'no-cache',\n    NO_STORE: 'no-store',\n    MUST_REVALIDATE: 'must-revalidate',\n    PRIVATE: 'private',\n    PUBLIC: 'public',\n  },\n  \n  // Error Codes\n  ERROR_CODES: {\n    NETWORK_ERROR: 'NETWORK_ERROR',\n    TIMEOUT_ERROR: 'TIMEOUT_ERROR',\n    VALIDATION_ERROR: 'VALIDATION_ERROR',\n    AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',\n    AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',\n    SUBSCRIPTION_ERROR: 'SUBSCRIPTION_ERROR',\n    NOT_FOUND_ERROR: 'NOT_FOUND_ERROR',\n    CONFLICT_ERROR: 'CONFLICT_ERROR',\n    SERVER_ERROR: 'SERVER_ERROR',\n  },\n} as const;\n\n// Type for API values\nexport type ApiValue = typeof API[keyof typeof API];\n","// ============================================================================\n// CENTRALIZED COLOR SYSTEM - OCEAN BLUE THEME\n// ============================================================================\n// This file defines all colors used across the rental shop system.\n// Use these constants for consistent theming throughout the application.\n\n// ============================================================================\n// BRAND COLORS - Green Theme\n// ============================================================================\nexport const BRAND_COLORS = {\n  primary: '#22C55E',       // Green 500 - primary green\n  secondary: '#4ADE80',     // Green 400 - lighter green\n  dark: '#15803D',          // Green 700 - deep green\n  light: '#86EFAC',         // Green 300 - light green\n  lightest: '#DCFCE7',      // Green 100 - very light green background\n} as const;\n\n// ============================================================================\n// ACTION COLORS\n// ============================================================================\nexport const ACTION_COLORS = {\n  primary: '#22C55E',       // Green 500 (same as brand primary)\n  success: '#10B981',       // Emerald green\n  danger: '#EF4444',        // Red\n  warning: '#F59E0B',       // Amber\n  info: '#3B82F6',          // Blue 500\n} as const;\n\n// ============================================================================\n// TEXT COLORS\n// ============================================================================\nexport const TEXT_COLORS = {\n  primary: '#1E293B',       // Slate 800 - main text\n  secondary: '#64748B',     // Slate 500 - secondary text\n  tertiary: '#94A3B8',      // Slate 400 - tertiary text\n  inverted: '#FFFFFF',      // White text\n  muted: '#CBD5E1',         // Slate 300 - muted text\n} as const;\n\n// ============================================================================\n// BACKGROUND COLORS\n// ============================================================================\nexport const BACKGROUND_COLORS = {\n  primary: '#F8FAFC',       // Slate 50 - main background\n  secondary: '#F1F5F9',     // Slate 100 - secondary background\n  tertiary: '#E2E8F0',      // Slate 200 - tertiary background\n  card: '#FFFFFF',          // White - card background\n  dark: '#0F172A',          // Slate 900 - dark background\n} as const;\n\n// ============================================================================\n// NAVIGATION COLORS\n// ============================================================================\nexport const NAVIGATION_COLORS = {\n  background: '#0F172A',    // Dark slate\n  backgroundHover: '#1E293B', // Slate 800\n  text: '#FFFFFF',          // White\n  textActive: '#86EFAC',    // Green 300 - light green\n  textHover: '#DCFCE7',     // Green 100 - very light green\n  border: '#334155',        // Slate 700\n  icon: '#94A3B8',          // Slate 400\n  iconActive: '#22C55E',    // Green 500\n} as const;\n\n// ============================================================================\n// BORDER COLORS\n// ============================================================================\nexport const BORDER_COLORS = {\n  default: '#E2E8F0',       // Slate 200\n  light: '#F1F5F9',         // Slate 100\n  dark: '#CBD5E1',          // Slate 300\n  focus: '#22C55E',         // Green 500\n} as const;\n\n// ============================================================================\n// ORDER STATUS COLORS - Colorful Theme (4-Color)\n// ============================================================================\n// Each status has its own distinct color for better visual distinction\n// Blue (RESERVED), Orange (PICKUPED), Green (RETURNED/COMPLETED), Red (CANCELLED)\n// RETURNED and COMPLETED both use Green as they are both \"completed states\"\nexport const ORDER_STATUS_COLORS = {\n  RESERVED: {\n    bg: 'bg-blue-50',         // Blue 50 - light blue background\n    text: 'text-blue-700',    // Blue 700 - text color\n    border: 'border-blue-200', // Blue 200 - border\n    hex: '#3B82F6',          // Blue 500 - primary color\n    buttonBg: '#3B82F6',     // Blue 500 - button background\n    buttonHover: '#2563EB',  // Blue 600 - button hover\n    buttonText: '#FFFFFF',   // White - button text\n    className: 'bg-blue-50 text-blue-700 border-blue-200', // Full className for badges\n  },\n  PICKUPED: {\n    bg: 'bg-orange-50',       // Orange 50 - light orange background\n    text: 'text-orange-700',  // Orange 700 - text color\n    border: 'border-orange-200', // Orange 200 - border\n    hex: '#F97316',          // Orange 500 - primary color\n    buttonBg: '#F97316',     // Orange 500 - button background\n    buttonHover: '#EA580C',  // Orange 600 - button hover\n    buttonText: '#FFFFFF',   // White - button text\n    className: 'bg-orange-50 text-orange-700 border-orange-200', // Full className for badges\n  },\n  RETURNED: {\n    bg: 'bg-green-50',        // Green 50 - light green background\n    text: 'text-green-700',  // Green 700 - text color\n    border: 'border-green-200', // Green 200 - border\n    hex: '#22C55E',          // Green 500 - primary color\n    buttonBg: '#22C55E',     // Green 500 - button background\n    buttonHover: '#16A34A',  // Green 600 - button hover\n    buttonText: '#FFFFFF',   // White - button text\n    className: 'bg-green-50 text-green-700 border-green-200', // Full className for badges\n  },\n  COMPLETED: {\n    bg: 'bg-green-50',       // Green 50 - light green background (same as RETURNED for consistency)\n    text: 'text-green-700',  // Green 700 - text color\n    border: 'border-green-200', // Green 200 - border\n    hex: '#22C55E',          // Green 500 - primary color\n    buttonBg: '#22C55E',     // Green 500 - button background\n    buttonHover: '#16A34A',  // Green 600 - button hover\n    buttonText: '#FFFFFF',   // White - button text\n    className: 'bg-green-50 text-green-700 border-green-200', // Full className for badges\n  },\n  CANCELLED: {\n    bg: 'bg-red-50',         // Red 50 - light red background\n    text: 'text-red-700',   // Red 700 - text color\n    border: 'border-red-200', // Red 200 - border\n    hex: '#EF4444',          // Red 500 - primary color\n    buttonBg: '#EF4444',     // Red 500 - button background\n    buttonHover: '#DC2626',  // Red 600 - button hover\n    buttonText: '#FFFFFF',   // White - button text\n    className: 'bg-red-50 text-red-700 border-red-200', // Full className for badges\n  },\n} as const;\n\n// ============================================================================\n// ORDER TYPE COLORS - Ocean Blue Theme\n// ============================================================================\nexport const ORDER_TYPE_COLORS = {\n  RENT: {\n    bg: '#DBEAFE',          // Blue 100 - badge background\n    text: '#1E40AF',        // Blue 800 - badge text\n    hex: '#3B82F6',         // Blue 500 - primary color\n    buttonBg: '#3B82F6',    // Blue 500 - button background\n    buttonHover: '#2563EB', // Blue 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  SALE: {\n    bg: '#D1FAE5',          // Emerald 100 - badge background\n    text: '#065F46',        // Emerald 800 - badge text\n    hex: '#10B981',         // Emerald 500 - primary color\n    buttonBg: '#10B981',    // Emerald 500 - button background\n    buttonHover: '#059669', // Emerald 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n} as const;\n\n// ============================================================================\n// SUBSCRIPTION STATUS COLORS\n// ============================================================================\nexport const SUBSCRIPTION_STATUS_COLORS = {\n  TRIAL: {\n    bg: '#DCFCE7',          // Green 100 - badge background\n    text: '#15803D',        // Green 700 - badge text\n    hex: '#22C55E',         // Green 500 - primary color\n    buttonBg: '#22C55E',    // Green 500 - button background\n    buttonHover: '#16A34A', // Green 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  ACTIVE: {\n    bg: '#D1FAE5',          // Emerald 100 - badge background\n    text: '#065F46',        // Emerald 800 - badge text\n    hex: '#10B981',         // Emerald 500 - primary color\n    buttonBg: '#10B981',    // Emerald 500 - button background\n    buttonHover: '#059669', // Emerald 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  PAST_DUE: {\n    bg: '#FEF3C7',          // Amber 100 - badge background\n    text: '#92400E',        // Amber 900 - badge text\n    hex: '#F59E0B',         // Amber 500 - primary color\n    buttonBg: '#F59E0B',    // Amber 500 - button background\n    buttonHover: '#D97706', // Amber 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  CANCELLED: {\n    bg: '#FEE2E2',          // Red 100 - badge background\n    text: '#991B1B',        // Red 800 - badge text\n    hex: '#EF4444',         // Red 500 - primary color\n    buttonBg: '#EF4444',    // Red 500 - button background\n    buttonHover: '#DC2626', // Red 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  PAUSED: {\n    bg: '#F3E8FF',          // Purple 100 - badge background\n    text: '#6B21A8',        // Purple 800 - badge text\n    hex: '#A855F7',         // Purple 500 - primary color\n    buttonBg: '#A855F7',    // Purple 500 - button background\n    buttonHover: '#9333EA', // Purple 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  EXPIRED: {\n    bg: '#F1F5F9',          // Slate 100 - badge background\n    text: '#475569',        // Slate 600 - badge text\n    hex: '#64748B',         // Slate 500 - primary color\n    buttonBg: '#64748B',    // Slate 500 - button background\n    buttonHover: '#475569', // Slate 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n} as const;\n\n// ============================================================================\n// PAYMENT STATUS COLORS\n// ============================================================================\nexport const PAYMENT_STATUS_COLORS = {\n  PENDING: {\n    bg: '#FEF3C7',          // Amber 100 - badge background\n    text: '#92400E',        // Amber 900 - badge text\n    hex: '#F59E0B',         // Amber 500 - primary color\n    buttonBg: '#F59E0B',    // Amber 500 - button background\n    buttonHover: '#D97706', // Amber 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  COMPLETED: {\n    bg: '#D1FAE5',          // Emerald 100 - badge background\n    text: '#065F46',        // Emerald 800 - badge text\n    hex: '#10B981',         // Emerald 500 - primary color\n    buttonBg: '#10B981',    // Emerald 500 - button background\n    buttonHover: '#059669', // Emerald 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  FAILED: {\n    bg: '#FEE2E2',          // Red 100 - badge background\n    text: '#991B1B',        // Red 800 - badge text\n    hex: '#EF4444',         // Red 500 - primary color\n    buttonBg: '#EF4444',    // Red 500 - button background\n    buttonHover: '#DC2626', // Red 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  REFUNDED: {\n    bg: '#DBEAFE',          // Blue 100 - badge background\n    text: '#1E40AF',        // Blue 800 - badge text\n    hex: '#3B82F6',         // Blue 500 - primary color (keep blue for refunded)\n    buttonBg: '#3B82F6',    // Blue 500 - button background\n    buttonHover: '#2563EB', // Blue 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  CANCELLED: {\n    bg: '#F1F5F9',          // Slate 100 - badge background\n    text: '#475569',        // Slate 600 - badge text\n    hex: '#64748B',         // Slate 500 - primary color\n    buttonBg: '#64748B',    // Slate 500 - button background\n    buttonHover: '#475569', // Slate 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n} as const;\n\n// ============================================================================\n// ENTITY STATUS COLORS\n// ============================================================================\nexport const ENTITY_STATUS_COLORS = {\n  ACTIVE: {\n    bg: '#D1FAE5',          // Emerald 100 - badge background\n    text: '#065F46',        // Emerald 800 - badge text\n    hex: '#10B981',         // Emerald 500 - primary color\n    buttonBg: '#10B981',    // Emerald 500 - button background\n    buttonHover: '#059669', // Emerald 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  INACTIVE: {\n    bg: '#F1F5F9',          // Slate 100 - badge background\n    text: '#475569',        // Slate 600 - badge text\n    hex: '#64748B',         // Slate 500 - primary color\n    buttonBg: '#64748B',    // Slate 500 - button background\n    buttonHover: '#475569', // Slate 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n} as const;\n\n// ============================================================================\n// PRODUCT AVAILABILITY COLORS\n// ============================================================================\nexport const PRODUCT_AVAILABILITY_COLORS = {\n  AVAILABLE: {\n    bg: '#D1FAE5',          // Emerald 100 - badge background\n    text: '#065F46',        // Emerald 800 - badge text\n    hex: '#10B981',         // Emerald 500 - primary color\n    buttonBg: '#10B981',    // Emerald 500 - button background\n    buttonHover: '#059669', // Emerald 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  OUT_OF_STOCK: {\n    bg: '#FEE2E2',          // Red 100 - badge background\n    text: '#991B1B',        // Red 800 - badge text\n    hex: '#EF4444',         // Red 500 - primary color\n    buttonBg: '#EF4444',    // Red 500 - button background\n    buttonHover: '#DC2626', // Red 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  UNAVAILABLE: {\n    bg: '#F1F5F9',          // Slate 100 - badge background\n    text: '#475569',        // Slate 600 - badge text\n    hex: '#64748B',         // Slate 500 - primary color\n    buttonBg: '#64748B',    // Slate 500 - button background\n    buttonHover: '#475569', // Slate 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n  DATE_CONFLICT: {\n    bg: '#FEF3C7',          // Amber 100 - badge background\n    text: '#92400E',        // Amber 900 - badge text\n    hex: '#F59E0B',         // Amber 500 - primary color\n    buttonBg: '#F59E0B',    // Amber 500 - button background\n    buttonHover: '#D97706', // Amber 600 - button hover\n    buttonText: '#FFFFFF',  // White - button text\n  },\n} as const;\n\n// ============================================================================\n// BUTTON VARIANT COLORS\n// ============================================================================\nexport const BUTTON_COLORS = {\n  primary: {\n    bg: '#22C55E',          // Green 500\n    bgHover: '#16A34A',     // Green 600\n    text: '#FFFFFF',        // White\n  },\n  secondary: {\n    bg: '#F1F5F9',          // Slate 100\n    bgHover: '#E2E8F0',     // Slate 200\n    text: '#1E293B',        // Slate 800\n  },\n  success: {\n    bg: '#10B981',          // Emerald\n    bgHover: '#059669',     // Darker emerald\n    text: '#FFFFFF',        // White\n  },\n  danger: {\n    bg: '#EF4444',          // Red\n    bgHover: '#DC2626',     // Darker red\n    text: '#FFFFFF',        // White\n  },\n  warning: {\n    bg: '#F59E0B',          // Amber\n    bgHover: '#D97706',     // Darker amber\n    text: '#FFFFFF',        // White\n  },\n  outline: {\n    bg: 'transparent',\n    bgHover: '#F8FAFC',     // Slate 50\n    text: '#334155',        // Slate 700\n    border: '#CBD5E1',      // Slate 300\n  },\n  ghost: {\n    bg: 'transparent',\n    bgHover: '#F1F5F9',     // Slate 100\n    text: '#1E293B',        // Slate 800\n  },\n} as const;\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Get Tailwind class string for order status\n */\nexport function getOrderStatusClass(status: keyof typeof ORDER_STATUS_COLORS): string {\n  const colors = ORDER_STATUS_COLORS[status];\n  if (!colors) return 'bg-gray-50 text-gray-600 border border-gray-200';\n  \n  const bgClass = getBgClass(colors.bg);\n  const textClass = getTextClass(colors.text);\n  const borderClass = colors.border ? getBorderClass(colors.border) : '';\n  return `${bgClass} ${textClass} ${borderClass}`.trim();\n}\n\n/**\n * Get Tailwind class string for order type\n */\nexport function getOrderTypeClass(type: keyof typeof ORDER_TYPE_COLORS): string {\n  const colors = ORDER_TYPE_COLORS[type];\n  if (!colors) return 'bg-slate-100 text-slate-800';\n  \n  const bgClass = getBgClass(colors.bg);\n  const textClass = getTextClass(colors.text);\n  return `${bgClass} ${textClass}`;\n}\n\n/**\n * Convert hex color to Tailwind background class\n */\nfunction getBgClass(hex: string): string {\n  const colorMap: Record<string, string> = {\n    // New lighter backgrounds (50)\n    '#EFF6FF': 'bg-blue-50',\n    '#FFF7ED': 'bg-orange-50',\n    '#F0FDF4': 'bg-green-50',\n    '#FEF2F2': 'bg-red-50',\n    // Old backgrounds (100) - kept for backward compatibility\n    '#DBEAFE': 'bg-blue-100',\n    '#FEF3C7': 'bg-amber-100',\n    '#D1FAE5': 'bg-emerald-100',\n    '#E0E7FF': 'bg-indigo-100',\n    '#FEE2E2': 'bg-red-100',\n    '#E0F2FE': 'bg-sky-100',\n    '#F3E8FF': 'bg-purple-100',\n    '#F1F5F9': 'bg-slate-100',\n  };\n  return colorMap[hex] || 'bg-gray-50';\n}\n\n/**\n * Convert hex color to Tailwind text class\n */\nfunction getTextClass(hex: string): string {\n  const colorMap: Record<string, string> = {\n    // New text colors (700) - better contrast\n    '#1D4ED8': 'text-blue-700',\n    '#C2410C': 'text-orange-700',\n    '#15803D': 'text-green-700',\n    '#B91C1C': 'text-red-700',\n    // Old text colors - kept for backward compatibility\n    '#1E40AF': 'text-blue-800',\n    '#92400E': 'text-amber-900',\n    '#065F46': 'text-emerald-800',\n    '#3730A3': 'text-indigo-800',\n    '#991B1B': 'text-red-800',\n    '#0369A1': 'text-sky-700',\n    '#6B21A8': 'text-purple-800',\n    '#475569': 'text-slate-600',\n  };\n  return colorMap[hex] || 'text-gray-700';\n}\n\n/**\n * Convert hex color to Tailwind border class\n */\nfunction getBorderClass(hex: string): string {\n  const colorMap: Record<string, string> = {\n    '#BFDBFE': 'border border-blue-200',\n    '#FED7AA': 'border border-orange-200',\n    '#BBF7D0': 'border border-green-200',\n    '#FECACA': 'border border-red-200',\n  };\n  return colorMap[hex] || 'border border-gray-200';\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Get order status color className from ORDER_STATUS_COLORS\n * Returns the full className string (bg + text + border) for badges\n */\nexport function getOrderStatusClassName(status: string): string {\n  const statusKey = status.toUpperCase() as keyof typeof ORDER_STATUS_COLORS;\n  const colors = ORDER_STATUS_COLORS[statusKey];\n  \n  if (colors && colors.className) {\n    return colors.className;\n  }\n  \n  // Fallback to default gray\n  return 'bg-gray-50 text-gray-600 border-gray-200';\n}\n\n/**\n * Get order status color object from ORDER_STATUS_COLORS\n * Returns the full color object with all properties\n */\nexport function getOrderStatusColors(status: string) {\n  const statusKey = status.toUpperCase() as keyof typeof ORDER_STATUS_COLORS;\n  return ORDER_STATUS_COLORS[statusKey] || ORDER_STATUS_COLORS.CANCELLED;\n}\n\n// ============================================================================\n// TYPE EXPORTS\n// ============================================================================\nexport type BrandColor = keyof typeof BRAND_COLORS;\nexport type ActionColor = keyof typeof ACTION_COLORS;\nexport type TextColor = keyof typeof TEXT_COLORS;\nexport type BackgroundColor = keyof typeof BACKGROUND_COLORS;\nexport type NavigationColor = keyof typeof NAVIGATION_COLORS;\nexport type BorderColor = keyof typeof BORDER_COLORS;\nexport type ButtonVariant = keyof typeof BUTTON_COLORS;\n\n","// ============================================================================\n// CENTRALIZED STATUS CONSTANTS\n// ============================================================================\n// This file centralizes all status definitions used across the rental shop system.\n// All status-related constants should be defined here and imported where needed.\n\n// ============================================================================\n// SUBSCRIPTION STATUSES\n// ============================================================================\nexport const SUBSCRIPTION_STATUS = {\n  TRIAL: 'TRIAL',\n  ACTIVE: 'ACTIVE',\n  PAST_DUE: 'PAST_DUE',\n  CANCELLED: 'CANCELLED',\n  PAUSED: 'PAUSED',\n  EXPIRED: 'EXPIRED'\n} as const;\n\nexport type SubscriptionStatus = typeof SUBSCRIPTION_STATUS[keyof typeof SUBSCRIPTION_STATUS];\n\n// ============================================================================\n// ORDER STATUSES\n// ============================================================================\nexport const ORDER_STATUS = {\n  // RENT order statuses\n  RESERVED: 'RESERVED',   // New order, scheduled for pickup\n  PICKUPED: 'PICKUPED',   // Currently being rented\n  RETURNED: 'RETURNED',   // Rental completed\n  \n  // SALE order statuses\n  COMPLETED: 'COMPLETED', // Sale finalized\n  \n  // Common statuses\n  CANCELLED: 'CANCELLED'  // Order cancelled (applies to both types)\n} as const;\n\nexport type OrderStatus = typeof ORDER_STATUS[keyof typeof ORDER_STATUS];\n\n// ============================================================================\n// PAYMENT STATUSES\n// ============================================================================\nexport const PAYMENT_STATUS = {\n  PENDING: 'PENDING',     // Payment initiated but not confirmed\n  COMPLETED: 'COMPLETED', // Payment fully processed and confirmed\n  FAILED: 'FAILED',       // Payment processing failed\n  REFUNDED: 'REFUNDED',   // Payment was refunded\n  CANCELLED: 'CANCELLED'  // Payment was cancelled before processing\n} as const;\n\nexport type PaymentStatus = typeof PAYMENT_STATUS[keyof typeof PAYMENT_STATUS];\n\n// ============================================================================\n// PAYMENT METHODS\n// ============================================================================\nexport const PAYMENT_METHOD = {\n  STRIPE: 'STRIPE',\n  TRANSFER: 'TRANSFER',\n  MANUAL: 'MANUAL',\n  CASH: 'CASH',\n  CHECK: 'CHECK',\n  PAYPAL: 'PAYPAL'\n} as const;\n\nexport type PaymentMethod = typeof PAYMENT_METHOD[keyof typeof PAYMENT_METHOD];\n\n// ============================================================================\n// PAYMENT TYPES\n// ============================================================================\nexport const PAYMENT_TYPE = {\n  ORDER_PAYMENT: 'ORDER_PAYMENT',\n  SUBSCRIPTION_PAYMENT: 'SUBSCRIPTION_PAYMENT',\n  PLAN_CHANGE: 'PLAN_CHANGE',\n  PLAN_EXTENSION: 'PLAN_EXTENSION'\n} as const;\n\nexport type PaymentType = typeof PAYMENT_TYPE[keyof typeof PAYMENT_TYPE];\n\n// ============================================================================\n// ORDER TYPES\n// ============================================================================\nexport const ORDER_TYPE = {\n  RENT: 'RENT',\n  SALE: 'SALE'\n} as const;\n\nexport type OrderType = typeof ORDER_TYPE[keyof typeof ORDER_TYPE];\n\n// ============================================================================\n// USER ROLES\n// ============================================================================\nexport const USER_ROLE = {\n  ADMIN: 'ADMIN',                    // System Administrator\n  MERCHANT: 'MERCHANT',              // Business Owner\n  OUTLET_ADMIN: 'OUTLET_ADMIN',      // Outlet Manager\n  OUTLET_STAFF: 'OUTLET_STAFF'       // Outlet Employee\n} as const;\n\nexport type UserRole = typeof USER_ROLE[keyof typeof USER_ROLE];\n\n// ============================================================================\n// ENTITY STATUSES (Active/Inactive)\n// ============================================================================\nexport const ENTITY_STATUS = {\n  ACTIVE: 'active',\n  INACTIVE: 'inactive'\n} as const;\n\nexport type EntityStatus = typeof ENTITY_STATUS[keyof typeof ENTITY_STATUS];\n\n// ============================================================================\n// MERCHANT STATUSES\n// ============================================================================\nexport const MERCHANT_STATUS = {\n  ACTIVE: 'ACTIVE',\n  INACTIVE: 'INACTIVE',\n  TRIAL: 'TRIAL',\n  EXPIRED: 'EXPIRED'\n} as const;\n\nexport type MerchantStatus = typeof MERCHANT_STATUS[keyof typeof MERCHANT_STATUS];\n\n// ============================================================================\n// PRODUCT AVAILABILITY STATUSES\n// ============================================================================\nexport const PRODUCT_AVAILABILITY_STATUS = {\n  AVAILABLE: 'available',\n  OUT_OF_STOCK: 'out-of-stock',\n  UNAVAILABLE: 'unavailable',\n  DATE_CONFLICT: 'date-conflict'\n} as const;\n\nexport type ProductAvailabilityStatus = typeof PRODUCT_AVAILABILITY_STATUS[keyof typeof PRODUCT_AVAILABILITY_STATUS];\n\n// ============================================================================\n// BILLING INTERVALS\n// ============================================================================\nexport const BILLING_INTERVAL = {\n  MONTHLY: 'monthly',\n  QUARTERLY: 'quarterly',\n  SEMI_ANNUAL: 'semi_annual',\n  ANNUAL: 'annual'\n} as const;\n\nexport type BillingInterval = typeof BILLING_INTERVAL[keyof typeof BILLING_INTERVAL];\n\n// ============================================================================\n// AUDIT LOG ACTIONS\n// ============================================================================\nexport const AUDIT_ACTION = {\n  CREATE: 'CREATE',\n  UPDATE: 'UPDATE',\n  DELETE: 'DELETE',\n  LOGIN: 'LOGIN',\n  LOGOUT: 'LOGOUT',\n  VIEW: 'VIEW',\n  EXPORT: 'EXPORT',\n  IMPORT: 'IMPORT',\n  CANCEL: 'CANCEL',\n  APPROVE: 'APPROVE',\n  REJECT: 'REJECT'\n} as const;\n\nexport type AuditAction = typeof AUDIT_ACTION[keyof typeof AUDIT_ACTION];\n\n// ============================================================================\n// AUDIT LOG ENTITY TYPES\n// ============================================================================\nexport const AUDIT_ENTITY_TYPE = {\n  USER: 'USER',\n  MERCHANT: 'MERCHANT',\n  OUTLET: 'OUTLET',\n  CUSTOMER: 'CUSTOMER',\n  PRODUCT: 'PRODUCT',\n  ORDER: 'ORDER',\n  PAYMENT: 'PAYMENT',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  PLAN: 'PLAN',\n  CATEGORY: 'CATEGORY'\n} as const;\n\nexport type AuditEntityType = typeof AUDIT_ENTITY_TYPE[keyof typeof AUDIT_ENTITY_TYPE];\n\n// ============================================================================\n// STATUS VALIDATION HELPERS\n// ============================================================================\n\n/**\n * Check if a subscription status is active (trial or active)\n */\nexport function isSubscriptionActive(status: SubscriptionStatus): boolean {\n  return status === SUBSCRIPTION_STATUS.TRIAL || status === SUBSCRIPTION_STATUS.ACTIVE;\n}\n\n/**\n * Type guard to validate if a string is a valid SubscriptionStatus\n * Useful for runtime validation when receiving data from API\n */\nexport function isValidSubscriptionStatus(value: string): value is SubscriptionStatus {\n  const validStatuses = Object.values(SUBSCRIPTION_STATUS);\n  return validStatuses.includes(value.toUpperCase() as SubscriptionStatus);\n}\n\n/**\n * Normalize a string to SubscriptionStatus enum value\n * Returns the enum value if valid, or null if invalid\n */\nexport function normalizeSubscriptionStatus(value: string | null | undefined): SubscriptionStatus | null {\n  if (!value) return null;\n  const normalized = value.toUpperCase();\n  return isValidSubscriptionStatus(normalized) ? normalized : null;\n}\n\n/**\n * Check if an order status is completed (returned for rent, completed for sale)\n */\nexport function isOrderCompleted(status: OrderStatus, orderType: OrderType): boolean {\n  if (orderType === ORDER_TYPE.RENT) {\n    return status === ORDER_STATUS.RETURNED;\n  }\n  return status === ORDER_STATUS.COMPLETED;\n}\n\n/**\n * Check if a payment status is successful\n */\nexport function isPaymentSuccessful(status: PaymentStatus): boolean {\n  return status === PAYMENT_STATUS.COMPLETED;\n}\n\n/**\n * Check if a payment status is pending\n */\nexport function isPaymentPending(status: PaymentStatus): boolean {\n  return status === PAYMENT_STATUS.PENDING;\n}\n\n/**\n * Check if a payment status is failed\n */\nexport function isPaymentFailed(status: PaymentStatus): boolean {\n  return status === PAYMENT_STATUS.FAILED;\n}\n\n/**\n * Check if an entity is active\n */\nexport function isEntityActive(status: EntityStatus): boolean {\n  return status === ENTITY_STATUS.ACTIVE;\n}\n\n// ============================================================================\n// STATUS DISPLAY HELPERS\n// ============================================================================\n\n/**\n * Get human-readable status label\n */\nexport function getStatusLabel(status: string, type: 'subscription' | 'order' | 'payment' | 'entity' | 'availability'): string {\n  switch (type) {\n    case 'subscription':\n      return status.charAt(0).toUpperCase() + status.slice(1).replace('_', ' ');\n    case 'order':\n      return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();\n    case 'payment':\n      return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();\n    case 'entity':\n      return status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();\n    case 'availability':\n      return status.replace('-', ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n    default:\n      return status;\n  }\n}\n\n/**\n * Get status color class for UI components - Ocean Blue Theme\n */\nexport function getStatusColor(status: string, type: 'subscription' | 'order' | 'payment' | 'entity' | 'availability'): string {\n  switch (type) {\n    case 'subscription':\n      switch (status) {\n        case SUBSCRIPTION_STATUS.TRIAL:\n          return 'text-green-700 bg-green-100';\n        case SUBSCRIPTION_STATUS.ACTIVE:\n          return 'text-emerald-800 bg-emerald-100';\n        case SUBSCRIPTION_STATUS.PAST_DUE:\n          return 'text-amber-900 bg-amber-100';\n        case SUBSCRIPTION_STATUS.CANCELLED:\n          return 'text-red-800 bg-red-100';\n        case SUBSCRIPTION_STATUS.EXPIRED:\n          return 'text-slate-600 bg-slate-100';\n        case SUBSCRIPTION_STATUS.PAUSED:\n          return 'text-purple-800 bg-purple-100';\n        default:\n          return 'text-slate-600 bg-slate-100';\n      }\n    case 'order':\n      switch (status) {\n        case ORDER_STATUS.RESERVED:\n          return 'bg-blue-50 text-blue-700 border border-blue-200';\n        case ORDER_STATUS.PICKUPED:\n          return 'bg-orange-50 text-orange-700 border border-orange-200';\n        case ORDER_STATUS.RETURNED:\n          return 'bg-green-50 text-green-700 border border-green-200';\n        case ORDER_STATUS.COMPLETED:\n          return 'bg-green-50 text-green-700 border border-green-200';\n        case ORDER_STATUS.CANCELLED:\n          return 'bg-red-50 text-red-700 border border-red-200';\n        default:\n          return 'bg-gray-50 text-gray-600 border border-gray-200';\n      }\n    case 'payment':\n      switch (status) {\n        case PAYMENT_STATUS.PENDING:\n          return 'text-amber-900 bg-amber-100';\n        case PAYMENT_STATUS.COMPLETED:\n          return 'text-emerald-800 bg-emerald-100';\n        case PAYMENT_STATUS.FAILED:\n          return 'text-red-800 bg-red-100';\n        case PAYMENT_STATUS.REFUNDED:\n          return 'text-blue-800 bg-blue-100';\n        case PAYMENT_STATUS.CANCELLED:\n          return 'text-slate-600 bg-slate-100';\n        default:\n          return 'text-slate-600 bg-slate-100';\n      }\n    case 'entity':\n      switch (status) {\n        case ENTITY_STATUS.ACTIVE:\n          return 'text-emerald-800 bg-emerald-100';\n        case ENTITY_STATUS.INACTIVE:\n          return 'text-slate-600 bg-slate-100';\n        default:\n          return 'text-slate-600 bg-slate-100';\n      }\n    case 'availability':\n      switch (status) {\n        case PRODUCT_AVAILABILITY_STATUS.AVAILABLE:\n          return 'text-emerald-800 bg-emerald-100';\n        case PRODUCT_AVAILABILITY_STATUS.OUT_OF_STOCK:\n          return 'text-red-800 bg-red-100';\n        case PRODUCT_AVAILABILITY_STATUS.UNAVAILABLE:\n          return 'text-slate-600 bg-slate-100';\n        case PRODUCT_AVAILABILITY_STATUS.DATE_CONFLICT:\n          return 'text-amber-900 bg-amber-100';\n        default:\n          return 'text-slate-600 bg-slate-100';\n      }\n    default:\n      return 'text-slate-600 bg-slate-100';\n  }\n}\n\n// ============================================================================\n// STATUS FILTER OPTIONS\n// ============================================================================\n\n/**\n * Get all status options for dropdowns/filters\n */\nexport function getStatusOptions(type: 'subscription' | 'order' | 'payment' | 'entity' | 'availability') {\n  switch (type) {\n    case 'subscription':\n      return Object.values(SUBSCRIPTION_STATUS).map(status => ({\n        value: status,\n        label: getStatusLabel(status, 'subscription')\n      }));\n    case 'order':\n      return Object.values(ORDER_STATUS).map(status => ({\n        value: status,\n        label: getStatusLabel(status, 'order')\n      }));\n    case 'payment':\n      return Object.values(PAYMENT_STATUS).map(status => ({\n        value: status,\n        label: getStatusLabel(status, 'payment')\n      }));\n    case 'entity':\n      return Object.values(ENTITY_STATUS).map(status => ({\n        value: status,\n        label: getStatusLabel(status, 'entity')\n      }));\n    case 'availability':\n      return Object.values(PRODUCT_AVAILABILITY_STATUS).map(status => ({\n        value: status,\n        label: getStatusLabel(status, 'availability')\n      }));\n    default:\n      return [];\n  }\n}\n","// ============================================================================\n// ORDER CONSTANTS\n// ============================================================================\n\nimport { ORDER_STATUS, OrderStatus } from './status';\nimport { ORDER_STATUS_COLORS as STATUS_COLORS, ORDER_TYPE_COLORS as TYPE_COLORS } from './colors';\n\n// Re-export from centralized status constants\nexport { ORDER_STATUS as ORDER_STATUSES } from './status';\nexport type { OrderStatus } from './status';\n\n// ============================================================================\n// ORDER TYPES\n// ============================================================================\nexport const ORDER_TYPES = {\n  RENT: 'RENT',\n  SALE: 'SALE'\n} as const;\n\nexport type OrderType = typeof ORDER_TYPES[keyof typeof ORDER_TYPES];\n\n// ============================================================================\n// ORDER STATUS COLORS - Minimal Text-Only (Option 5)\n// ============================================================================\n// Clean minimal design: text color only, no background\n// - Blue: RESERVED (pending/awaiting)\n// - Green: PICKUPED, RETURNED (active/completed)\n// - Gray: COMPLETED, CANCELLED (neutral/muted)\nexport const ORDER_STATUS_COLORS = {\n  RESERVED: 'text-blue-700 border border-blue-200',\n  PICKUPED: 'text-green-700 border border-green-200',\n  RETURNED: 'text-green-600 border border-green-200',\n  COMPLETED: 'text-gray-700 border border-gray-200',\n  CANCELLED: 'text-gray-500 border border-gray-200'\n} as const;\n\n// ============================================================================\n// ORDER TYPE COLORS - Ocean Blue Theme (Badge/Display)\n// ============================================================================\nexport const ORDER_TYPE_COLORS = {\n  RENT: 'bg-blue-100 text-blue-800',\n  SALE: 'bg-emerald-100 text-emerald-800'\n} as const;\n\n// ============================================================================\n// ORDER STATUS BUTTON COLORS - Ocean Blue Theme\n// ============================================================================\nexport const ORDER_STATUS_BUTTON_COLORS = {\n  RESERVED: STATUS_COLORS.RESERVED,\n  PICKUPED: STATUS_COLORS.PICKUPED,\n  RETURNED: STATUS_COLORS.RETURNED,\n  COMPLETED: STATUS_COLORS.COMPLETED,\n  CANCELLED: STATUS_COLORS.CANCELLED\n} as const;\n\n// ============================================================================\n// ORDER TYPE BUTTON COLORS - Ocean Blue Theme\n// ============================================================================\nexport const ORDER_TYPE_BUTTON_COLORS = {\n  RENT: TYPE_COLORS.RENT,\n  SALE: TYPE_COLORS.SALE\n} as const;\n\n// ============================================================================\n// ORDER STATUS ICONS\n// ============================================================================\nexport const ORDER_STATUS_ICONS = {\n  RESERVED: 'üìã',\n  PICKUPED: '‚è≥',\n  RETURNED: '‚úÖ',\n  COMPLETED: 'üéâ',\n  CANCELLED: '‚ùå'\n} as const;\n\n// ============================================================================\n// ORDER TYPE ICONS\n// ============================================================================\nexport const ORDER_TYPE_ICONS = {\n  RENT: 'üîÑ',\n  SALE: 'üí∞'\n} as const;\n\n// ============================================================================\n// ORDER STATUS LABELS (Vietnamese)\n// ============================================================================\nexport const ORDER_STATUS_LABELS = {\n  RESERVED: 'M·ªõi c·ªçc',\n  PICKUPED: 'ƒêang thu√™',\n  RETURNED: 'ƒê√£ tr·∫£',\n  COMPLETED: 'Ho√†n th√†nh',\n  CANCELLED: 'H·ªßy'\n} as const;\n\n// ============================================================================\n// ORDER TYPE LABELS (Vietnamese)\n// ============================================================================\nexport const ORDER_TYPE_LABELS = {\n  RENT: 'Thu√™',\n  SALE: 'B√°n'\n} as const;\n","// ============================================================================\n// SIMPLE SUBSCRIPTION CONFIGURATION\n// ============================================================================\n// Simple subscription model without complex pricing\n\nexport interface PlanLimits {\n  outlets: number;             // Maximum number of outlets allowed (-1 for unlimited)\n  users: number;               // Maximum number of users allowed (-1 for unlimited)\n  products: number;            // Maximum number of products allowed (-1 for unlimited)\n  customers: number;           // Maximum number of customers allowed (-1 for unlimited)\n  orders: number;              // Maximum number of orders allowed (-1 for unlimited)\n}\n\n// ============================================================================\n// INTERFACES\n// ============================================================================\n\nexport interface PlanFeature {\n  name: string;\n  description: string;\n  included: boolean;\n}\n\nexport interface PlanConfig {\n  id: string;\n  name: string;\n  description: string;\n  basePrice: number;\n  currency: string;\n  limits: PlanLimits;\n  features: PlanFeature[];\n  platform: 'mobile' | 'mobile+web';  // Platform access level\n  publicProductCheck: boolean;         // Can share product links publicly\n  isPopular: boolean;\n  isActive: boolean;\n  sortOrder: number;\n  color: string;\n  badge?: string;\n  upgradeFrom?: string[];      // Plans that can upgrade to this one\n  downgradeTo?: string[];      // Plans that this can downgrade to\n}\n\n// ============================================================================\n// BILLING CYCLES\n// ============================================================================\n\nexport const BILLING_CYCLES = {\n  MONTHLY: {\n    id: 'monthly',\n    name: 'Monthly',\n    duration: 1,\n    unit: 'month',\n    discount: 0\n  },\n  QUARTERLY: {\n    id: 'quarterly',\n    name: 'Quarterly',\n    duration: 3,\n    unit: 'months',\n    discount: 0 // 0% discount\n  },\n  SEMI_ANNUAL: {\n    id: 'semi_annual',\n    name: 'Semi-Annual',\n    duration: 6,\n    unit: 'months',\n    discount: 0.05 // 5% discount\n  },\n  ANNUAL: {\n    id: 'annual',\n    name: 'Annual',\n    duration: 12,\n    unit: 'months',\n    discount: 0.10 // 10% discount\n  }\n};\n\n// Array format for form components (synchronized with BILLING_CYCLES object)\nexport const BILLING_CYCLES_ARRAY = [\n  {\n    value: 'monthly' as const,\n    label: BILLING_CYCLES.MONTHLY.name,\n    months: BILLING_CYCLES.MONTHLY.duration,\n    discount: BILLING_CYCLES.MONTHLY.discount * 100, // Convert to percentage\n    description: 'Pay monthly, cancel anytime'\n  },\n  {\n    value: 'quarterly' as const,\n    label: BILLING_CYCLES.QUARTERLY.name,\n    months: BILLING_CYCLES.QUARTERLY.duration,\n    discount: BILLING_CYCLES.QUARTERLY.discount * 100, // Convert to percentage\n    description: `Save ${BILLING_CYCLES.QUARTERLY.discount * 100}% with quarterly billing`\n  },\n  {\n    value: 'semi_annual' as const,\n    label: BILLING_CYCLES.SEMI_ANNUAL.name,\n    months: BILLING_CYCLES.SEMI_ANNUAL.duration,\n    discount: BILLING_CYCLES.SEMI_ANNUAL.discount * 100, // Convert to percentage\n    description: `Save ${BILLING_CYCLES.SEMI_ANNUAL.discount * 100}% with semi-annual billing`\n  },\n  {\n    value: 'annual' as const,\n    label: BILLING_CYCLES.ANNUAL.name,\n    months: BILLING_CYCLES.ANNUAL.duration,\n    discount: BILLING_CYCLES.ANNUAL.discount * 100, // Convert to percentage\n    description: `Save ${BILLING_CYCLES.ANNUAL.discount * 100}% with annual billing`\n  }\n];\n\n// ============================================================================\n// RENEWAL DURATIONS\n// ============================================================================\n\nexport const RENEWAL_DURATIONS = [\n  {\n    id: 'monthly',\n    name: 'Monthly',\n    months: 1,\n    duration: 1,\n    unit: 'month',\n    description: 'Renew every month',\n    isPopular: false\n  },\n  {\n    id: 'quarterly',\n    name: 'Quarterly',\n    months: 3,\n    duration: 3,\n    unit: 'months',\n    description: 'Save 5% with quarterly billing',\n    isPopular: false\n  },\n  {\n    id: 'semiannual',\n    name: '6 Months',\n    months: 6,\n    duration: 6,\n    unit: 'months',\n    description: 'Save 10% with 6-month billing',\n    isPopular: false\n  },\n  {\n    id: 'annual',\n    name: 'Annual',\n    months: 12,\n    duration: 12,\n    unit: 'months',\n    description: 'Save 20% with annual billing',\n    isPopular: true\n  }\n];\n\n// ============================================================================\n// TRIAL CONFIGURATION\n// ============================================================================\n\nexport const TRIAL_CONFIG = {\n  DEFAULT_TRIAL_DAYS: 14,\n  TRIAL_NOTIFICATIONS: {\n    DAYS_BEFORE_EXPIRY: [7, 3, 1] as readonly number[]\n  }\n};\n\n// ============================================================================\n// SUBSCRIPTION PLANS CONFIGURATION\n// ============================================================================\n\nexport const SUBSCRIPTION_PLANS: Record<string, PlanConfig> = {\n  TRIAL: {\n    id: 'trial',\n    name: 'Trial',\n    description: 'Free trial with starter plan limits',\n    basePrice: 0, // Free trial\n    currency: 'VND',\n    limits: {\n      outlets: 1,\n      users: 3,\n      products: 500,\n      customers: 2000,\n      orders: 2000\n    },\n    features: [\n      { name: 'Mobile app access', description: 'Access your business on mobile devices', included: true },\n      { name: 'Basic inventory management', description: 'Track products and stock levels', included: true },\n      { name: 'Customer management', description: 'Store customer information and history', included: true },\n      { name: 'Order processing', description: 'Create and manage rental orders', included: true },\n      { name: 'Basic reporting', description: 'View sales and rental reports', included: true },\n      { name: 'Public product catalog', description: 'Share product list publicly with customers', included: true },\n      { name: 'Product public check', description: 'Send public links to customers to view products and pricing', included: true }\n    ],\n    platform: 'mobile',\n    publicProductCheck: true,\n    isPopular: false,\n    isActive: true,\n    sortOrder: 0,\n    color: 'green',\n    badge: 'Free Trial',\n    upgradeFrom: [],\n    downgradeTo: ['basic']\n  },\n\n  BASIC: {\n    id: 'basic',\n    name: 'Basic',\n    description: 'Perfect for small rental businesses',\n    basePrice: 79000, // 79k VND\n    currency: 'VND',\n    limits: {\n      outlets: 1,\n      users: 3,\n      products: 500,\n      customers: 2000,\n      orders: 2000\n    },\n    features: [\n      { name: 'Mobile app access', description: 'Access your business on mobile devices', included: true },\n      { name: 'Basic inventory management', description: 'Track products and stock levels', included: true },\n      { name: 'Customer management', description: 'Store customer information and history', included: true },\n      { name: 'Order processing', description: 'Create and manage rental orders', included: true },\n      { name: 'Basic reporting', description: 'View sales and rental reports', included: true },\n      { name: 'Public product catalog', description: 'Share product list publicly with customers', included: true },\n      { name: 'Product public check', description: 'Send public links to customers to view products and pricing', included: true }\n    ],\n    platform: 'mobile',\n    publicProductCheck: true,\n    isPopular: false,\n    isActive: true,\n    sortOrder: 1,\n    color: 'blue',\n    upgradeFrom: [],\n    downgradeTo: []\n  },\n\n  PROFESSIONAL: {\n    id: 'professional',\n    name: 'Professional',\n    description: 'Ideal for growing rental businesses with web access',\n    basePrice: 199000, // 199k VND\n    currency: 'VND',\n    limits: {\n      outlets: 1,\n      users: 8,\n      products: 5000,\n      customers: 10000,\n      orders: 10000\n    },\n    features: [\n      { name: 'All Basic features', description: 'Includes all Basic plan features', included: true },\n      { name: 'Web dashboard access', description: 'Full web-based management interface', included: true },\n      { name: 'Advanced reporting & analytics', description: 'Detailed business insights and trends', included: true },\n      { name: 'Inventory forecasting', description: 'Predict demand and optimize stock levels', included: true },\n      { name: 'Online payments', description: 'Accept online payments and deposits', included: true },\n      { name: 'API integration', description: 'Connect with third-party tools', included: true },\n      { name: 'Team collaboration tools', description: 'Manage team permissions and workflows', included: true },\n      { name: 'Priority support', description: 'Fast response times for support', included: true }\n    ],\n    platform: 'mobile+web',\n    publicProductCheck: true,\n    isPopular: true,\n    isActive: true,\n    sortOrder: 2,\n    color: 'purple',\n    badge: 'Most Popular',\n    upgradeFrom: ['basic'],\n    downgradeTo: ['basic']\n  },\n\n  ENTERPRISE: {\n    id: 'enterprise',\n    name: 'Enterprise',\n    description: 'For large rental operations with multiple outlets',\n    basePrice: 399000, // 399k VND\n    currency: 'VND',\n    limits: {\n      outlets: 3,\n      users: 15,\n      products: 15000,\n      customers: 50000,\n      orders: 50000\n    },\n    features: [\n      { name: 'All Professional features', description: 'Includes all Professional plan features', included: true },\n      { name: 'Multiple outlets', description: 'Manage multiple rental locations', included: true },\n      { name: 'Advanced team management', description: 'Sophisticated user roles and permissions', included: true },\n      { name: 'Custom integrations', description: 'Tailored third-party integrations', included: true },\n      { name: 'Dedicated account manager', description: 'Personal support representative', included: true },\n      { name: 'Custom reporting', description: 'Tailored analytics and reporting', included: true },\n      { name: 'White-label solution', description: 'Brand the platform with your company identity', included: true },\n      { name: '24/7 phone support', description: 'Round-the-clock support via phone', included: true }\n    ],\n    platform: 'mobile+web',\n    publicProductCheck: true,\n    isPopular: false,\n    isActive: true,\n    sortOrder: 3,\n    color: 'gold',\n    badge: 'Premium',\n    upgradeFrom: ['basic', 'professional'],\n    downgradeTo: ['professional']\n  }\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Get plan configuration by ID\n */\nexport function getPlan(planId: string): PlanConfig | null {\n  const plan = SUBSCRIPTION_PLANS[planId.toUpperCase()];\n  return plan || null;\n}\n\n/**\n * Get all available plans\n */\nexport function getAllPlans(): PlanConfig[] {\n  return Object.values(SUBSCRIPTION_PLANS).sort((a, b) => a.sortOrder - b.sortOrder);\n}\n\n/**\n * Get active plans only\n */\nexport function getActivePlans(): PlanConfig[] {\n  return getAllPlans().filter(plan => plan.isActive);\n}\n\n/**\n * Get plan limits by plan ID\n */\nexport function getPlanLimits(planId: string): PlanLimits | null {\n  const plan = getPlan(planId);\n  return plan ? plan.limits : null;\n}\n\n/**\n * Check if plan has web access\n */\nexport function hasWebAccess(planId: string): boolean {\n  const plan = getPlan(planId);\n  return plan ? plan.platform === 'mobile+web' : false;\n}\n\n/**\n * Check if plan has mobile access\n */\nexport function hasMobileAccess(planId: string): boolean {\n  const plan = getPlan(planId);\n  return plan ? plan.platform === 'mobile' || plan.platform === 'mobile+web' : false;\n}\n\n/**\n * Check if plan has public product check feature\n */\nexport function hasProductPublicCheck(planId: string): boolean {\n  const plan = getPlan(planId);\n  return plan ? plan.publicProductCheck : false;\n}\n\n/**\n * Get plan platform\n */\nexport function getPlanPlatform(planId: string): 'mobile' | 'mobile+web' | null {\n  const plan = getPlan(planId);\n  return plan ? plan.platform : null;\n}\n\n/**\n * Check if plan is unlimited for a specific entity type\n */\nexport function isUnlimitedPlan(planId: string, entityType: keyof PlanLimits): boolean {\n  const limits = getPlanLimits(planId);\n  if (!limits) return false;\n  return limits[entityType] === -1;\n}\n\n/**\n * Get trial notification days\n */\nexport function getTrialNotificationDays(): readonly number[] {\n  return TRIAL_CONFIG.TRIAL_NOTIFICATIONS.DAYS_BEFORE_EXPIRY;\n}\n\n/**\n * Get default trial days\n */\nexport function getDefaultTrialDays(): number {\n  return TRIAL_CONFIG.DEFAULT_TRIAL_DAYS;\n}\n\n/**\n * Get plan comparison data for display\n */\nexport function getPlanComparison() {\n  const plans = getActivePlans();\n  \n  return {\n    plans: plans.map(plan => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      badge: plan.badge,\n      color: plan.color\n    })),\n    features: [\n      { name: 'Mobile App', basic: true, professional: true, enterprise: true },\n      { name: 'Web Dashboard', basic: false, professional: true, enterprise: true },\n      { name: 'Products', basic: '500', professional: '5,000', enterprise: '15,000' },\n      { name: 'Customers', basic: '2,000', professional: '10,000', enterprise: '50,000' },\n      { name: 'Users', basic: '3', professional: '8', enterprise: '15' },\n      { name: 'Outlets', basic: '1', professional: '1', enterprise: '3' },\n      { name: 'Orders', basic: '2,000', professional: '10,000', enterprise: '50,000' },\n      { name: 'Product Public Check', basic: true, professional: true, enterprise: true },\n      { name: 'Advanced Analytics', basic: false, professional: true, enterprise: true },\n      { name: 'API Access', basic: false, professional: true, enterprise: true },\n      { name: 'Priority Support', basic: false, professional: true, enterprise: true },\n      { name: '24/7 Phone Support', basic: false, professional: false, enterprise: true }\n    ]\n  };\n}\n\n/**\n * Validate plan configuration\n */\nexport function validatePlanConfig(plan: PlanConfig): { isValid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  if (!plan.id || plan.id.trim() === '') {\n    errors.push('Plan ID is required');\n  }\n\n  if (!plan.name || plan.name.trim() === '') {\n    errors.push('Plan name is required');\n  }\n\n  if (plan.basePrice < 0) {\n    errors.push('Base price must be non-negative');\n  }\n\n  if (!plan.limits) {\n    errors.push('Plan limits are required');\n  } else {\n    if (plan.limits.outlets < -1) {\n      errors.push('Outlets limit must be -1 (unlimited) or positive');\n    }\n    if (plan.limits.users < -1) {\n      errors.push('Users limit must be -1 (unlimited) or positive');\n    }\n    if (plan.limits.products < -1) {\n      errors.push('Products limit must be -1 (unlimited) or positive');\n    }\n    if (plan.limits.customers < -1) {\n      errors.push('Customers limit must be -1 (unlimited) or positive');\n    }\n    if (plan.limits.orders < -1) {\n      errors.push('Orders limit must be -1 (unlimited) or positive');\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}","// ============================================================================\n// PRICING CONFIGURATION CONSTANTS\n// ============================================================================\n\n// Local type definitions to avoid circular dependency\nexport type BusinessType = 'CLOTHING' | 'VEHICLE' | 'EQUIPMENT' | 'GENERAL';\nexport type PricingType = 'FIXED' | 'HOURLY' | 'DAILY';\n\n// Type-safe constants for PricingType enum values\nexport const PRICING_TYPE = {\n  FIXED: 'FIXED' as const,\n  HOURLY: 'HOURLY' as const,\n  DAILY: 'DAILY' as const,\n} as const;\n\n// ============================================================================\n// BUSINESS TYPE & PRICING TYPE DESCRIPTIONS\n// ============================================================================\n\nexport interface BusinessTypeOption {\n  value: BusinessType;\n  label: string;\n  description: string;\n  icon: string;\n}\n\nexport interface PricingTypeOption {\n  value: PricingType;\n  label: string;\n  description: string;\n  icon: string;\n}\n\nexport const BUSINESS_TYPE_OPTIONS: BusinessTypeOption[] = [\n  {\n    value: 'GENERAL',\n    label: 'General Rental',\n    description: 'Mixed rental business with various product types',\n    icon: ''\n  },\n  {\n    value: 'CLOTHING',\n    label: 'Clothing & Fashion',\n    description: 'Rent or sell clothing, accessories, and fashion items',\n    icon: ''\n  },\n  {\n    value: 'VEHICLE',\n    label: 'Vehicle Rental',\n    description: 'Car, motorcycle, bicycle, and vehicle rental services',\n    icon: ''\n  },\n  {\n    value: 'EQUIPMENT',\n    label: 'Equipment Rental',\n    description: 'Tools, machinery, and equipment rental services',\n    icon: ''\n  }\n];\n\nexport const PRICING_TYPE_OPTIONS: PricingTypeOption[] = [\n  {\n    value: 'FIXED',\n    label: 'Fixed Price',\n    description: 'Same price regardless of rental duration',\n    icon: ''\n  },\n  {\n    value: 'HOURLY',\n    label: 'Hourly Pricing',\n    description: 'Price calculated per hour of rental',\n    icon: ''\n  },\n  {\n    value: 'DAILY',\n    label: 'Daily Pricing',\n    description: 'Price calculated per day of rental',\n    icon: ''\n  }\n];\n\nexport interface PricingBusinessRules {\n  requireRentalDates: boolean;\n  showPricingOptions: boolean;\n}\n\nexport interface PricingDurationLimits {\n  minDuration: number;\n  maxDuration: number;\n  defaultDuration: number;\n}\n\nexport interface MerchantPricingConfig {\n  businessType: BusinessType;\n  defaultPricingType: PricingType;\n  businessRules: PricingBusinessRules;\n  durationLimits: PricingDurationLimits;\n}\n\n// ============================================================================\n// BUSINESS TYPE DEFAULTS\n// ============================================================================\n\n/**\n * Default pricing configuration for each business type\n */\nexport const BUSINESS_TYPE_DEFAULTS: Record<BusinessType, MerchantPricingConfig> = {\n  CLOTHING: {\n    businessType: 'CLOTHING',\n    defaultPricingType: 'FIXED',\n    businessRules: {\n      requireRentalDates: false,\n      showPricingOptions: false\n    },\n    durationLimits: {\n      minDuration: 1,\n      maxDuration: 1,\n      defaultDuration: 1\n    }\n  },\n  \n  VEHICLE: {\n    businessType: 'VEHICLE',\n    defaultPricingType: 'HOURLY',\n    businessRules: {\n      requireRentalDates: true,\n      showPricingOptions: true\n    },\n    durationLimits: {\n      minDuration: 1,      // 1 hour\n      maxDuration: 168,    // 1 week (24*7)\n      defaultDuration: 4   // 4 hours\n    }\n  },\n  \n  EQUIPMENT: {\n    businessType: 'EQUIPMENT',\n    defaultPricingType: 'DAILY',\n    businessRules: {\n      requireRentalDates: true,\n      showPricingOptions: false\n    },\n    durationLimits: {\n      minDuration: 1,      // 1 day\n      maxDuration: 30,     // 30 days\n      defaultDuration: 3   // 3 days\n    }\n  },\n  \n  GENERAL: {\n    businessType: 'GENERAL',\n    defaultPricingType: 'FIXED',\n    businessRules: {\n      requireRentalDates: false,\n      showPricingOptions: false\n    },\n    durationLimits: {\n      minDuration: 1,\n      maxDuration: 1,\n      defaultDuration: 1\n    }\n  }\n};\n\n// ============================================================================\n// LABELS AND DESCRIPTIONS\n// ============================================================================\n\n/**\n * Human-readable labels for pricing types\n */\nexport const PRICING_TYPE_LABELS = {\n  FIXED: 'Fixed Price',\n  HOURLY: 'Hourly',\n  DAILY: 'Daily',\n} as const;\n\n/**\n * Human-readable labels for business types\n */\nexport const BUSINESS_TYPE_LABELS = {\n  CLOTHING: 'Clothing Rental',\n  VEHICLE: 'Vehicle Rental',\n  EQUIPMENT: 'Equipment Rental',\n  GENERAL: 'General Rental'\n} as const;\n\n/**\n * Descriptions for pricing types\n */\nexport const PRICING_TYPE_DESCRIPTIONS = {\n  FIXED: 'One price per rental (e.g., equipment rental)',\n  HOURLY: 'Price per hour (e.g., vehicles, tools)',\n  DAILY: 'Price per day (e.g., construction equipment)',\n} as const;\n\n/**\n * Descriptions for business types\n */\nexport const BUSINESS_TYPE_DESCRIPTIONS = {\n  CLOTHING: 'Dresses, suits, costumes, accessories',\n  VEHICLE: 'Cars, bikes, motorcycles',\n  EQUIPMENT: 'Tools, machinery, equipment',\n  GENERAL: 'Various items and services'\n} as const;\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get default pricing configuration for business type\n */\nexport function getDefaultPricingConfig(businessType: BusinessType): MerchantPricingConfig {\n  return BUSINESS_TYPE_DEFAULTS[businessType];\n}\n\n/**\n * Get pricing type label\n */\nexport function getPricingTypeLabel(pricingType: PricingType): string {\n  return PRICING_TYPE_LABELS[pricingType];\n}\n\n/**\n * Get business type label\n */\nexport function getBusinessTypeLabel(businessType: BusinessType): string {\n  return BUSINESS_TYPE_LABELS[businessType];\n}\n\n/**\n * Get pricing type description\n */\nexport function getPricingTypeDescription(pricingType: PricingType): string {\n  return PRICING_TYPE_DESCRIPTIONS[pricingType];\n}\n\n/**\n * Get business type description\n */\nexport function getBusinessTypeDescription(businessType: BusinessType): string {\n  return BUSINESS_TYPE_DESCRIPTIONS[businessType];\n}\n\n/**\n * Check if pricing type requires rental dates\n */\nexport function requiresRentalDates(pricingType: PricingType): boolean {\n  return pricingType !== 'FIXED';\n}\n\n/**\n * Get duration unit for pricing type\n */\nexport function getDurationUnit(pricingType: PricingType): string {\n  switch (pricingType) {\n    case 'HOURLY': return 'hour';\n    case 'DAILY': return 'day';\n    case 'FIXED': return 'rental';\n    default: return 'unit';\n  }\n}\n","// ============================================================================\n// COUNTRY CONSTANTS\n// ============================================================================\n\nexport interface Country {\n  code: string;\n  name: string;\n  flag: string;\n  currency: string;\n  phoneCode: string;\n}\n\nexport const COUNTRIES: Country[] = [\n  // North America\n  { code: 'US', name: 'United States', flag: 'üá∫üá∏', currency: 'USD', phoneCode: '+1' },\n  { code: 'CA', name: 'Canada', flag: 'üá®üá¶', currency: 'CAD', phoneCode: '+1' },\n  { code: 'MX', name: 'Mexico', flag: 'üá≤üáΩ', currency: 'MXN', phoneCode: '+52' },\n\n  // Europe\n  { code: 'GB', name: 'United Kingdom', flag: 'üá¨üáß', currency: 'GBP', phoneCode: '+44' },\n  { code: 'DE', name: 'Germany', flag: 'üá©üá™', currency: 'EUR', phoneCode: '+49' },\n  { code: 'FR', name: 'France', flag: 'üá´üá∑', currency: 'EUR', phoneCode: '+33' },\n  { code: 'IT', name: 'Italy', flag: 'üáÆüáπ', currency: 'EUR', phoneCode: '+39' },\n  { code: 'ES', name: 'Spain', flag: 'üá™üá∏', currency: 'EUR', phoneCode: '+34' },\n  { code: 'NL', name: 'Netherlands', flag: 'üá≥üá±', currency: 'EUR', phoneCode: '+31' },\n  { code: 'CH', name: 'Switzerland', flag: 'üá®üá≠', currency: 'CHF', phoneCode: '+41' },\n  { code: 'SE', name: 'Sweden', flag: 'üá∏üá™', currency: 'SEK', phoneCode: '+46' },\n  { code: 'NO', name: 'Norway', flag: 'üá≥üá¥', currency: 'NOK', phoneCode: '+47' },\n  { code: 'DK', name: 'Denmark', flag: 'üá©üá∞', currency: 'DKK', phoneCode: '+45' },\n  { code: 'FI', name: 'Finland', flag: 'üá´üáÆ', currency: 'EUR', phoneCode: '+358' },\n  { code: 'AT', name: 'Austria', flag: 'üá¶üáπ', currency: 'EUR', phoneCode: '+43' },\n  { code: 'BE', name: 'Belgium', flag: 'üáßüá™', currency: 'EUR', phoneCode: '+32' },\n  { code: 'IE', name: 'Ireland', flag: 'üáÆüá™', currency: 'EUR', phoneCode: '+353' },\n  { code: 'PT', name: 'Portugal', flag: 'üáµüáπ', currency: 'EUR', phoneCode: '+351' },\n\n  // Asia Pacific\n  { code: 'AU', name: 'Australia', flag: 'üá¶üá∫', currency: 'AUD', phoneCode: '+61' },\n  { code: 'NZ', name: 'New Zealand', flag: 'üá≥üáø', currency: 'NZD', phoneCode: '+64' },\n  { code: 'JP', name: 'Japan', flag: 'üáØüáµ', currency: 'JPY', phoneCode: '+81' },\n  { code: 'KR', name: 'South Korea', flag: 'üá∞üá∑', currency: 'KRW', phoneCode: '+82' },\n  { code: 'SG', name: 'Singapore', flag: 'üá∏üá¨', currency: 'SGD', phoneCode: '+65' },\n  { code: 'HK', name: 'Hong Kong', flag: 'üá≠üá∞', currency: 'HKD', phoneCode: '+852' },\n  { code: 'TW', name: 'Taiwan', flag: 'üáπüáº', currency: 'TWD', phoneCode: '+886' },\n  { code: 'MY', name: 'Malaysia', flag: 'üá≤üáæ', currency: 'MYR', phoneCode: '+60' },\n  { code: 'TH', name: 'Thailand', flag: 'üáπüá≠', currency: 'THB', phoneCode: '+66' },\n  { code: 'ID', name: 'Indonesia', flag: 'üáÆüá©', currency: 'IDR', phoneCode: '+62' },\n  { code: 'PH', name: 'Philippines', flag: 'üáµüá≠', currency: 'PHP', phoneCode: '+63' },\n  { code: 'VN', name: 'Vietnam', flag: 'üáªüá≥', currency: 'VND', phoneCode: '+84' },\n  { code: 'IN', name: 'India', flag: 'üáÆüá≥', currency: 'INR', phoneCode: '+91' },\n  { code: 'CN', name: 'China', flag: 'üá®üá≥', currency: 'CNY', phoneCode: '+86' },\n\n  // Middle East & Africa\n  { code: 'AE', name: 'United Arab Emirates', flag: 'üá¶üá™', currency: 'AED', phoneCode: '+971' },\n  { code: 'SA', name: 'Saudi Arabia', flag: 'üá∏üá¶', currency: 'SAR', phoneCode: '+966' },\n  { code: 'IL', name: 'Israel', flag: 'üáÆüá±', currency: 'ILS', phoneCode: '+972' },\n  { code: 'ZA', name: 'South Africa', flag: 'üáøüá¶', currency: 'ZAR', phoneCode: '+27' },\n  { code: 'EG', name: 'Egypt', flag: 'üá™üá¨', currency: 'EGP', phoneCode: '+20' },\n  { code: 'MA', name: 'Morocco', flag: 'üá≤üá¶', currency: 'MAD', phoneCode: '+212' },\n  { code: 'NG', name: 'Nigeria', flag: 'üá≥üá¨', currency: 'NGN', phoneCode: '+234' },\n  { code: 'KE', name: 'Kenya', flag: 'üá∞üá™', currency: 'KES', phoneCode: '+254' },\n\n  // South America\n  { code: 'BR', name: 'Brazil', flag: 'üáßüá∑', currency: 'BRL', phoneCode: '+55' },\n  { code: 'AR', name: 'Argentina', flag: 'üá¶üá∑', currency: 'ARS', phoneCode: '+54' },\n  { code: 'CL', name: 'Chile', flag: 'üá®üá±', currency: 'CLP', phoneCode: '+56' },\n  { code: 'CO', name: 'Colombia', flag: 'üá®üá¥', currency: 'COP', phoneCode: '+57' },\n  { code: 'PE', name: 'Peru', flag: 'üáµüá™', currency: 'PEN', phoneCode: '+51' },\n  { code: 'UY', name: 'Uruguay', flag: 'üá∫üáæ', currency: 'UYU', phoneCode: '+598' },\n\n  // Central America & Caribbean\n  { code: 'CR', name: 'Costa Rica', flag: 'üá®üá∑', currency: 'CRC', phoneCode: '+506' },\n  { code: 'PA', name: 'Panama', flag: 'üáµüá¶', currency: 'PAB', phoneCode: '+507' },\n  { code: 'GT', name: 'Guatemala', flag: 'üá¨üáπ', currency: 'GTQ', phoneCode: '+502' },\n  { code: 'CU', name: 'Cuba', flag: 'üá®üá∫', currency: 'CUP', phoneCode: '+53' },\n  { code: 'DO', name: 'Dominican Republic', flag: 'üá©üá¥', currency: 'DOP', phoneCode: '+1' },\n  { code: 'JM', name: 'Jamaica', flag: 'üáØüá≤', currency: 'JMD', phoneCode: '+1' },\n];\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get country by code\n */\nexport function getCountryByCode(code: string): Country | undefined {\n  return COUNTRIES.find(country => country.code === code);\n}\n\n/**\n * Get country by name\n */\nexport function getCountryByName(name: string): Country | undefined {\n  return COUNTRIES.find(country => country.name === name);\n}\n\n/**\n * Get all countries sorted by name\n */\nexport function getCountriesSorted(): Country[] {\n  return [...COUNTRIES].sort((a, b) => a.name.localeCompare(b.name));\n}\n\n/**\n * Get countries by region (for future use)\n */\nexport function getCountriesByRegion(region: string): Country[] {\n  const regions: Record<string, string[]> = {\n    'north-america': ['US', 'CA', 'MX'],\n    'europe': ['GB', 'DE', 'FR', 'IT', 'ES', 'NL', 'CH', 'SE', 'NO', 'DK', 'FI', 'AT', 'BE', 'IE', 'PT'],\n    'asia-pacific': ['AU', 'NZ', 'JP', 'KR', 'SG', 'HK', 'TW', 'MY', 'TH', 'ID', 'PH', 'VN', 'IN', 'CN'],\n    'middle-east-africa': ['AE', 'SA', 'IL', 'ZA', 'EG', 'MA', 'NG', 'KE'],\n    'south-america': ['BR', 'AR', 'CL', 'CO', 'PE', 'UY'],\n    'central-america-caribbean': ['CR', 'PA', 'GT', 'CU', 'DO', 'JM']\n  };\n\n  const countryCodes = regions[region] || [];\n  return COUNTRIES.filter(country => countryCodes.includes(country.code));\n}\n\n/**\n * Format country display name with flag\n */\nexport function formatCountryDisplay(country: Country): string {\n  return `${country.flag} ${country.name}`;\n}\n\n/**\n * Get default country (Vietnam)\n */\nexport function getDefaultCountry(): Country {\n  return COUNTRIES.find(country => country.code === 'VN') || COUNTRIES[0]; // Vietnam or fallback to first country\n}\n","/**\n * Currency Constants\n * \n * Centralized currency-related constants for the rental shop application.\n * Supports USD and VND currencies at the merchant level.\n */\n\n/**\n * Currency code type\n */\nexport type CurrencyCode = 'USD' | 'VND';\n\n/**\n * Supported currency codes\n */\nexport const SUPPORTED_CURRENCIES: readonly CurrencyCode[] = ['USD', 'VND'] as const;\n\n/**\n * Default currency for new merchants\n */\nexport const DEFAULT_CURRENCY: CurrencyCode = 'USD';\n\n/**\n * Currency symbols mapped to currency codes\n */\nexport const CURRENCY_SYMBOLS: Record<CurrencyCode, string> = {\n  USD: '$',\n  VND: 'ƒë',\n};\n\n/**\n * Currency names mapped to currency codes\n */\nexport const CURRENCY_NAMES: Record<CurrencyCode, string> = {\n  USD: 'US Dollar',\n  VND: 'Vietnamese Dong',\n};\n\n/**\n * Currency locales for formatting\n */\nexport const CURRENCY_LOCALES: Record<CurrencyCode, string> = {\n  USD: 'en-US',\n  VND: 'vi-VN',\n};\n\n/**\n * Currency decimal places\n */\nexport const CURRENCY_DECIMALS: Record<CurrencyCode, number> = {\n  USD: 2,\n  VND: 0,\n};\n\n/**\n * Symbol position (before or after amount)\n */\nexport const CURRENCY_SYMBOL_POSITION: Record<CurrencyCode, 'before' | 'after'> = {\n  USD: 'before',\n  VND: 'after',\n};\n\n/**\n * Exchange rates to USD (base currency)\n * Note: These are approximate rates for reference only\n * In production, fetch real-time rates from an API\n */\nexport const EXCHANGE_RATES: Record<CurrencyCode, number> = {\n  USD: 1,\n  VND: 24500,\n};\n\n/**\n * Currency configuration for easy access\n */\nexport interface CurrencyConfig {\n  code: CurrencyCode;\n  symbol: string;\n  name: string;\n  locale: string;\n  decimals: number;\n  symbolPosition: 'before' | 'after';\n  exchangeRate: number;\n}\n\n/**\n * Complete currency configurations\n */\nexport const CURRENCY_CONFIGS: Record<CurrencyCode, CurrencyConfig> = {\n  USD: {\n    code: 'USD',\n    symbol: CURRENCY_SYMBOLS.USD,\n    name: CURRENCY_NAMES.USD,\n    locale: CURRENCY_LOCALES.USD,\n    decimals: CURRENCY_DECIMALS.USD,\n    symbolPosition: CURRENCY_SYMBOL_POSITION.USD,\n    exchangeRate: EXCHANGE_RATES.USD,\n  },\n  VND: {\n    code: 'VND',\n    symbol: CURRENCY_SYMBOLS.VND,\n    name: CURRENCY_NAMES.VND,\n    locale: CURRENCY_LOCALES.VND,\n    decimals: CURRENCY_DECIMALS.VND,\n    symbolPosition: CURRENCY_SYMBOL_POSITION.VND,\n    exchangeRate: EXCHANGE_RATES.VND,\n  },\n};\n\n/**\n * Get currency configuration by code\n * @param code - Currency code\n * @returns Currency configuration\n */\nexport function getCurrencyConfig(code: CurrencyCode): CurrencyConfig {\n  return CURRENCY_CONFIGS[code];\n}\n\n/**\n * Check if a currency code is valid\n * @param code - Currency code to check\n * @returns True if valid, false otherwise\n */\nexport function isValidCurrency(code: string): code is CurrencyCode {\n  return SUPPORTED_CURRENCIES.includes(code as CurrencyCode);\n}\n\n/**\n * Get currency symbol\n * @param code - Currency code\n * @returns Currency symbol\n */\nexport function getCurrencySymbol(code: CurrencyCode): string {\n  return CURRENCY_SYMBOLS[code];\n}\n\n/**\n * Get currency name\n * @param code - Currency code\n * @returns Currency name\n */\nexport function getCurrencyName(code: CurrencyCode): string {\n  return CURRENCY_NAMES[code];\n}\n\n/**\n * Currency selection options for dropdowns\n */\nexport const CURRENCY_OPTIONS = SUPPORTED_CURRENCIES.map(code => ({\n  value: code,\n  label: `${CURRENCY_SYMBOLS[code]} ${code} - ${CURRENCY_NAMES[code]}`,\n  symbol: CURRENCY_SYMBOLS[code],\n  name: CURRENCY_NAMES[code],\n}));\n\n/**\n * Default currency settings\n */\nexport const DEFAULT_CURRENCY_SETTINGS = {\n  currentCurrency: DEFAULT_CURRENCY,\n  baseCurrency: DEFAULT_CURRENCY,\n  showSymbol: false,\n  showCode: false,\n};\n\n","/**\n * Centralized Constants for Rental Shop Monorepo\n * \n * This package provides all constants used across the application\n * to ensure consistency and maintainability.\n */\n\n// Import all constant modules\nimport { PAGINATION } from './pagination';\nimport { SEARCH } from './search';\nimport { VALIDATION } from './validation';\nimport { UI } from './ui';\nimport { BUSINESS } from './business';\nimport { ENVIRONMENT } from './environment';\nimport { API } from './api';\nimport * as ORDERS from './orders';\nimport * as STATUS from './status';\n\n// Export all constant modules\nexport * from './pagination';\nexport * from './search';\nexport * from './validation';\nexport * from './ui';\nexport * from './business';\nexport * from './environment';\nexport * from './api';\nexport * from './orders';\nexport * from './status';\nexport * from './subscription';\nexport * from './pricing';\nexport * from './countries';\nexport * from './currency';\n\n// Explicit exports for status constants\nexport { \n  SUBSCRIPTION_STATUS,\n  ORDER_STATUS,\n  PAYMENT_STATUS,\n  PAYMENT_METHOD,\n  PAYMENT_TYPE,\n  ORDER_TYPE,\n  USER_ROLE,\n  ENTITY_STATUS,\n  MERCHANT_STATUS,\n  PRODUCT_AVAILABILITY_STATUS,\n  BILLING_INTERVAL,\n  AUDIT_ACTION,\n  AUDIT_ENTITY_TYPE\n} from './status';\n\n// Export status types\nexport type {\n  SubscriptionStatus,\n  OrderStatus,\n  PaymentStatus,\n  PaymentMethod,\n  PaymentType,\n  OrderType,\n  UserRole,\n  EntityStatus,\n  MerchantStatus,\n  ProductAvailabilityStatus,\n  BillingInterval,\n  AuditAction,\n  AuditEntityType\n} from './status';\n\n// ============================================================================\n// COLOR SYSTEM EXPORTS\n// ============================================================================\nexport * from './colors';\nexport {\n  BRAND_COLORS,\n  ACTION_COLORS,\n  TEXT_COLORS,\n  BACKGROUND_COLORS,\n  NAVIGATION_COLORS,\n  BORDER_COLORS,\n  ORDER_STATUS_COLORS as ORDER_STATUS_COLOR_PALETTE,\n  ORDER_TYPE_COLORS as ORDER_TYPE_COLOR_PALETTE,\n  SUBSCRIPTION_STATUS_COLORS,\n  PAYMENT_STATUS_COLORS,\n  ENTITY_STATUS_COLORS,\n  PRODUCT_AVAILABILITY_COLORS,\n  BUTTON_COLORS,\n  getOrderStatusClass,\n  getOrderTypeClass,\n  getOrderStatusClassName,\n  getOrderStatusColors\n} from './colors';\n\n// Explicit exports for critical constants\nexport { \n  ORDER_STATUS_COLORS,\n  ORDER_TYPE_COLORS,\n  ORDER_STATUSES,\n  ORDER_TYPES,\n  ORDER_STATUS_LABELS,\n  ORDER_TYPE_LABELS\n} from './orders';\n\n\n// Explicit API export to fix import issues\nexport { API } from './api';\n\n// Convenience exports for easy access\nexport const CONSTANTS = {\n  PAGINATION,\n  SEARCH,\n  VALIDATION,\n  UI,\n  BUSINESS,\n  ENVIRONMENT,\n  API,\n  ORDERS,\n  STATUS,\n} as const;\n\n// Re-export the main constants object\nexport { CONSTANTS as default };\n\n// Re-export status functions directly\nexport { \n  getStatusColor,\n  getStatusLabel,\n  getStatusOptions,\n  isSubscriptionActive,\n  isOrderCompleted,\n  isPaymentSuccessful,\n  isPaymentPending,\n  isPaymentFailed,\n  isEntityActive,\n  isValidSubscriptionStatus,\n  normalizeSubscriptionStatus\n} from './status';\n\n// ============================================================================\n// PRICING CONFIGURATION\n// ============================================================================\nexport {\n  BUSINESS_TYPE_DEFAULTS,\n  PRICING_TYPE,\n  PRICING_TYPE_LABELS,\n  BUSINESS_TYPE_LABELS,\n  PRICING_TYPE_DESCRIPTIONS,\n  BUSINESS_TYPE_DESCRIPTIONS,\n  BUSINESS_TYPE_OPTIONS,\n  PRICING_TYPE_OPTIONS,\n  getDefaultPricingConfig,\n  getPricingTypeLabel,\n  getBusinessTypeLabel,\n  getPricingTypeDescription,\n  getBusinessTypeDescription,\n  requiresRentalDates,\n  getDurationUnit\n} from './pricing';\n\n// Export pricing types\nexport type {\n  BusinessType,\n  PricingType,\n  BusinessTypeOption,\n  PricingTypeOption,\n  PricingBusinessRules,\n  PricingDurationLimits,\n  MerchantPricingConfig\n} from './pricing';\n","// ============================================================================\n// NEW: CORRECT DUAL ID PRODUCT FUNCTIONS\n// ============================================================================\n// This file contains only the correct product functions that follow the dual ID system:\n// - Input: id (number)\n// - Database: queries by id, uses CUIDs for relationships\n// - Return: includes both id (CUID) and id (number)\n\nimport { prisma } from './client';\nimport type { ProductSearchFilter } from '@rentalshop/types';\nimport { ORDER_STATUS, ORDER_TYPE } from '@rentalshop/constants';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\n// ============================================================================\n// PRODUCT LOOKUP FUNCTIONS (BY PUBLIC ID)\n// ============================================================================\n\n/**\n * Get product by id (number) - follows dual ID system\n * SECURITY: Enforces merchant isolation to prevent cross-tenant access\n */\nexport async function getProductById(id: number, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.product.findFirst({\n    where: { \n      id,\n      merchantId: merchant.id // Use CUID for merchant isolation\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outletStock: {\n        select: {\n          id: true,\n          stock: true,\n          available: true,\n          renting: true,\n          outlet: {\n            select: {\n      id: true,\n              name: true,\n              address: true,\n            },\n          },\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get product by barcode - follows dual ID system\n * SECURITY: Enforces merchant isolation to prevent cross-tenant access\n */\nexport async function getProductByBarcode(barcode: string, merchantId: number) {\n  // Find merchant by id to get the CUID\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.product.findFirst({\n    where: { \n      barcode,\n      merchantId: merchant.id // Use CUID for merchant isolation\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// PRODUCT SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Build order by clause for product queries\n */\nfunction buildProductOrderByClause(sortBy?: string, sortOrder?: string): any {\n  const validSortFields = [\n    'createdAt', 'updatedAt', 'name', 'rentPrice', 'salePrice', 'totalStock'\n  ];\n  \n  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';\n  const order = sortOrder === 'asc' ? 'asc' : 'desc';\n  \n  return { [field as string]: order };\n}\n\n/**\n * Search products - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchProducts(filters: ProductSearchFilter) {\n  const {\n    merchantId,\n    outletId,\n    categoryId,\n    search,\n    q, // Add q parameter support\n    page = 1,\n    limit = 20,\n    offset, // Add offset support\n    isActive = true,\n    available,\n    minPrice,\n    maxPrice,\n    sortBy,\n    sortOrder\n  } = filters;\n\n  // Use offset if provided, otherwise calculate from page\n  const skip = offset !== undefined ? offset : (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {\n    isActive,\n  };\n\n  if (merchantId) {\n    // Find merchant by id\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: merchantId },\n      select: { id: true }\n    });\n    \n    if (merchant) {\n      where.merchantId = merchant.id; // Use CUID\n    }\n  }\n\n  if (categoryId) {\n    // Find category by id\n    const category = await prisma.category.findUnique({\n      where: { id: categoryId },\n      select: { id: true }\n    });\n    \n    if (category) {\n      where.categoryId = category.id; // Use CUID\n    }\n  }\n\n  // Handle search query - use 'q' parameter first, fallback to 'search' for backward compatibility\n  // Support both with and without Vietnamese diacritics\n  const searchQuery = q || search;\n  if (searchQuery) {\n    const searchTerm = searchQuery.trim();\n    // Normalize Vietnamese text to support search without diacritics\n    const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n    \n    // Search with both original and normalized terms to support diacritics-insensitive search\n    const searchConditions: any[] = [\n      { name: { contains: searchTerm, mode: 'insensitive' } },\n      { description: { contains: searchTerm, mode: 'insensitive' } },\n      { barcode: { equals: searchTerm } } // Barcode is usually exact match\n    ];\n    \n    // Add normalized search if different from original\n    if (normalizedTerm !== searchTerm) {\n      searchConditions.push(\n        { name: { contains: normalizedTerm, mode: 'insensitive' } },\n        { description: { contains: normalizedTerm, mode: 'insensitive' } }\n      );\n    }\n    \n    where.OR = searchConditions;\n  }\n\n  // If outletId is specified, only show products that have stock at that outlet\n  if (outletId) {\n    // Find outlet by id\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: outletId },\n      select: { id: true }\n    });\n    \n    if (outlet) {\n      where.outletStock = {\n        some: {\n          outletId: outlet.id, // Use CUID\n          stock: { gt: 0 }\n        }\n      };\n    }\n  }\n\n  // Add availability filter\n  if (available !== undefined) {\n    if (available) {\n      where.outletStock = {\n        some: {\n          available: { gt: 0 }\n        }\n      };\n    } else {\n      where.outletStock = {\n        none: {\n          available: { gt: 0 }\n        }\n      };\n    }\n  }\n\n  // Add price range filters\n  if (minPrice !== undefined || maxPrice !== undefined) {\n    where.rentPrice = {};\n    if (minPrice !== undefined) where.rentPrice.gte = minPrice;\n    if (maxPrice !== undefined) where.rentPrice.lte = maxPrice;\n  }\n\n  const [products, total] = await Promise.all([\n    prisma.product.findMany({\n      where,\n      select: {\n      id: true,\n        name: true,\n        description: true,\n        barcode: true,\n        totalStock: true,\n        rentPrice: true,\n        salePrice: true,\n        deposit: true,\n        images: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true,\n        category: {\n          select: {\n      id: true,\n            name: true\n          }\n        },\n        merchant: {\n          select: {\n      id: true,\n            name: true\n          }\n        },\n        outletStock: {\n          select: {\n            id: true,\n            stock: true,\n            available: true,\n            renting: true,\n            outlet: {\n              select: {\n      id: true,\n                name: true,\n                address: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: buildProductOrderByClause(sortBy, sortOrder),\n      take: limit,\n      skip: skip\n    }),\n    prisma.product.count({ where })\n  ]);\n\n  // Transform to match expected types\n  const transformedProducts = products.map((product: any) => ({\n    id: product.id, // Return id (number) for external use\n    name: product.name,\n    description: product.description,\n    barcode: product.barcode,\n    totalStock: product.totalStock,\n    rentPrice: product.rentPrice,\n    salePrice: product.salePrice,\n    deposit: product.deposit,\n    images: product.images,\n    isActive: product.isActive,\n    createdAt: product.createdAt,\n    updatedAt: product.updatedAt,\n    category: {\n      id: product.category.id, // Return id (number)\n      name: product.category.name,\n    },\n    merchant: {\n      id: product.merchant.id, // Return id (number)\n      name: product.merchant.name,\n    },\n    outletStock: product.outletStock.map((stock: any) => ({\n      id: stock.id, // Keep CUID for internal use\n      stock: stock.stock,\n      available: stock.available,\n      renting: stock.renting,\n      outlet: {\n        id: stock.outlet.id, // Return id (number)\n        name: stock.outlet.name,\n        address: stock.outlet.address,\n      },\n    })),\n  }));\n\n  return {\n    products: transformedProducts,\n    total,\n    page: offset !== undefined ? Math.floor(offset / limit) + 1 : page,\n    limit,\n    offset: skip,\n    hasMore: skip + limit < total,\n    totalPages: Math.ceil(total / limit),\n  };\n}\n\n// ============================================================================\n// DEFAULT CATEGORY FUNCTIONS\n// ============================================================================\n\n/**\n * Get or create default category for merchant\n */\nasync function getOrCreateDefaultCategory(merchantId: number): Promise<any> {\n  // First try to find existing default category\n  const existingDefault = await prisma.category.findFirst({\n    where: {\n      merchantId: merchantId, // merchantId is number (public ID)\n      name: 'General',\n      isActive: true\n    }\n  });\n\n  if (existingDefault) {\n    console.log('‚úÖ Found existing default category:', existingDefault.id);\n    return existingDefault;\n  }\n\n  // Create default category if not exists\n  console.log('üîß Creating default category for merchant:', merchantId);\n  \n  // Generate next category id\n  const lastCategory = await prisma.category.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastCategory?.id || 0) + 1;\n\n  const defaultCategory = await prisma.category.create({\n    data: {\n      id: nextPublicId,\n      name: 'General',\n      description: 'Default category for general products',\n      merchantId: merchantId,\n      isActive: true\n    }\n  });\n\n  console.log('‚úÖ Created default category:', defaultCategory.id);\n  return defaultCategory;\n}\n\n// ============================================================================\n// PRODUCT CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new product - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createProduct(input: any): Promise<any> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: input.merchantId }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${input.merchantId} not found`);\n  }\n\n  // Find category by id if provided\n  let category = null;\n  if (input.categoryId) {\n    category = await prisma.category.findUnique({\n      where: { id: input.categoryId }\n    });\n    \n    if (!category) {\n      throw new Error(`Category with id ${input.categoryId} not found`);\n    }\n  }\n\n  // Generate next product id\n  const lastProduct = await prisma.product.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastProduct?.id || 0) + 1;\n\n  // Create product\n  const productData: any = {\n    id: nextPublicId,\n    name: input.name,\n    description: input.description,\n    barcode: input.barcode,\n    totalStock: input.totalStock || 0,\n    rentPrice: input.rentPrice,\n    salePrice: input.salePrice,\n    costPrice: input.costPrice,\n    deposit: input.deposit || 0,\n    images: input.images,\n    isActive: input.isActive ?? true,\n    merchantId: merchant.id, // Use CUID\n    // Optional pricing configuration (default FIXED if null)\n    pricingType: input.pricingType || null,\n    durationConfig: input.durationConfig || null,\n  };\n\n  // Only add categoryId if category is provided\n  if (category) {\n    productData.categoryId = category.id;\n  }\n\n  const product = await prisma.product.create({\n    data: productData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return product;\n}\n\n// ============================================================================\n// PRODUCT UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update product - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateProduct(\n  id: number,\n  input: any\n): Promise<any> {\n  // Find product by id\n  const existingProduct = await prisma.product.findUnique({\n    where: { id }\n  });\n\n  if (!existingProduct) {\n    throw new Error(`Product with id ${id} not found`);\n  }\n\n  // Handle category update if categoryId is provided\n  let categoryId = undefined;\n  if (input.categoryId !== undefined) {\n    if (input.categoryId === null || input.categoryId === 0) {\n      // Remove category\n      categoryId = null;\n    } else {\n      // Find category by id\n      const category = await prisma.category.findUnique({\n        where: { id: input.categoryId }\n      });\n      \n      if (!category) {\n        throw new Error(`Category with id ${input.categoryId} not found`);\n      }\n      \n      categoryId = category.id; // Use CUID for database\n    }\n  }\n\n  // Prepare update data\n  const updateData: any = {};\n  \n  // Only update fields that are provided\n  if (input.name !== undefined) updateData.name = input.name;\n  if (input.description !== undefined) updateData.description = input.description;\n  if (input.barcode !== undefined) updateData.barcode = input.barcode;\n  if (input.totalStock !== undefined) updateData.totalStock = input.totalStock;\n  // Optional pricing configuration\n  if (input.pricingType !== undefined) updateData.pricingType = input.pricingType;\n  if (input.durationConfig !== undefined) updateData.durationConfig = input.durationConfig;\n  if (input.rentPrice !== undefined) updateData.rentPrice = input.rentPrice;\n  if (input.salePrice !== undefined) updateData.salePrice = input.salePrice;\n  if (input.costPrice !== undefined) updateData.costPrice = input.costPrice;\n  if (input.deposit !== undefined) updateData.deposit = input.deposit;\n  if (input.images !== undefined) updateData.images = input.images;\n  if (input.isActive !== undefined) updateData.isActive = input.isActive;\n  if (categoryId !== undefined) updateData.categoryId = categoryId;\n\n  // Update product\n  const updatedProduct = await prisma.product.update({\n    where: { id },\n    data: updateData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return updatedProduct;\n}\n\n// ============================================================================\n// PRODUCT UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get products by merchant - follows dual ID system\n */\nexport async function getProductsByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.product.findMany({\n    where: { merchantId: merchant.id }, // Use CUID\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get products by category - follows dual ID system\n */\nexport async function getProductsByCategory(categoryId: number) {\n  // Find category by id\n  const category = await prisma.category.findUnique({\n    where: { id: categoryId },\n    select: { id: true }\n  });\n  \n  if (!category) {\n    throw new Error(`Category with id ${categoryId} not found`);\n  }\n\n  return await prisma.product.findMany({\n    where: { categoryId: category.id }, // Use CUID\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Update product stock - follows dual ID system\n */\nexport async function updateProductStock(\n  productId: number,\n  outletId: number,\n  stockChange: number\n): Promise<any> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id: productId },\n    select: { id: true }\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${productId} not found`);\n  }\n\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Update or create outlet stock\n  const outletStock = await prisma.outletStock.upsert({\n    where: {\n      productId_outletId: {\n        productId: product.id, // Use CUID\n        outletId: outlet.id, // Use CUID\n      },\n    },\n    update: {\n      stock: { increment: stockChange },\n      available: { increment: stockChange },\n    },\n    create: {\n      productId: product.id, // Use CUID\n      outletId: outlet.id, // Use CUID\n      stock: stockChange,\n      available: stockChange,\n      renting: 0,\n    },\n  });\n\n  // Sync Product.totalStock = sum of all OutletStock.stock\n  if (stockChange !== 0) {\n    await syncProductTotalStock(productId);\n  }\n\n  return outletStock;\n}\n\n/**\n * Sync Product.totalStock = sum of all OutletStock.stock for this product\n * This ensures Product.totalStock always equals the sum of all outlet stocks\n */\nexport async function syncProductTotalStock(productId: number): Promise<void> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id: productId },\n    select: { id: true }\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${productId} not found`);\n  }\n\n  // Get all outlet stock for this product\n  const allOutletStock = await prisma.outletStock.findMany({\n    where: { productId: product.id },\n    select: { stock: true }\n  });\n  \n  // Calculate total stock = sum of all outlet stocks\n  const totalStock = allOutletStock.reduce((sum, os) => sum + os.stock, 0);\n  \n  // Update Product.totalStock\n  await prisma.product.update({\n    where: { id: product.id },\n    data: { totalStock }\n  });\n  \n  console.log(`‚úÖ Synced Product.totalStock: ${totalStock} (sum of ${allOutletStock.length} outlets) for product ${productId}`);\n}\n\n/**\n * Sync OutletStock.available field to ensure it equals stock - renting\n * This ensures data consistency after any stock or renting updates\n */\nexport async function syncOutletStockAvailable(\n  productId: number,\n  outletId: number\n): Promise<void> {\n  // Find product and outlet by id\n  const product = await prisma.product.findUnique({\n    where: { id: productId },\n    select: { id: true }\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${productId} not found`);\n  }\n\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Get current outlet stock\n  const outletStock = await prisma.outletStock.findUnique({\n    where: {\n      productId_outletId: {\n        productId: product.id,\n        outletId: outlet.id,\n      },\n    },\n  });\n\n  if (!outletStock) {\n    console.warn(`OutletStock not found for product ${productId} and outlet ${outletId}`);\n    return;\n  }\n\n  // Recalculate available = stock - renting\n  // Note: Reserved orders are NOT counted in available calculation.\n  // Reserved items are still in stock physically, just reserved temporarily.\n  // For accurate date-based availability with reserved conflicts, use the availability API.\n  const calculatedAvailable = Math.max(0, outletStock.stock - outletStock.renting);\n\n  // Update if different\n  if (outletStock.available !== calculatedAvailable) {\n    await prisma.outletStock.update({\n      where: { id: outletStock.id },\n      data: { available: calculatedAvailable },\n    });\n    console.log(`‚úÖ Synced OutletStock.available: ${outletStock.available} ‚Üí ${calculatedAvailable} (product ${productId}, outlet ${outletId})`);\n  }\n}\n\n/**\n * Update OutletStock when order status changes\n * Handles both RENT and SALE orders according to Odoo best practices:\n * - RENT: Uses renting field (temporary), stock doesn't change\n * - SALE: Decreases stock permanently (sold, not returned)\n */\nexport async function updateOutletStockForOrder(\n  orderId: number,\n  oldStatus: string | null,\n  newStatus: string,\n  orderType: 'RENT' | 'SALE',\n  outletId: number,\n  orderItems: Array<{ productId: number; quantity: number }>\n): Promise<void> {\n  console.log(`üîÑ Updating outlet stock for order ${orderId}: ${oldStatus} ‚Üí ${newStatus} (${orderType})`);\n\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Process each order item\n  for (const item of orderItems) {\n    // Allow negative quantity (user requirement)\n    if (!item.productId || item.quantity === undefined || item.quantity === null) {\n      console.warn(`‚ö†Ô∏è Skipping invalid order item:`, item);\n      continue;\n    }\n\n    // Find product by id\n    const product = await prisma.product.findUnique({\n      where: { id: item.productId },\n      select: { id: true }\n    });\n\n    if (!product) {\n      console.warn(`‚ö†Ô∏è Product ${item.productId} not found, skipping stock update`);\n      continue;\n    }\n\n    // Get or create outlet stock\n    let outletStock = await prisma.outletStock.findUnique({\n      where: {\n        productId_outletId: {\n          productId: product.id,\n          outletId: outlet.id,\n        },\n      },\n    });\n\n    if (!outletStock) {\n      console.warn(`‚ö†Ô∏è OutletStock not found for product ${item.productId} and outlet ${outletId}, creating...`);\n      outletStock = await prisma.outletStock.create({\n        data: {\n          productId: product.id,\n          outletId: outlet.id,\n          stock: 0,\n          available: 0,\n          renting: 0,\n        },\n      });\n    }\n\n    // Determine stock changes based on order type and status transition\n    let stockChange = 0;\n    let rentingChange = 0;\n    let availableChange = 0;\n\n    if (orderType === ORDER_TYPE.SALE) {\n      // SALE orders: Permanently decrease stock when COMPLETED/PICKUPED\n      if (newStatus === ORDER_STATUS.COMPLETED || newStatus === ORDER_STATUS.PICKUPED) {\n        // Only decrease if wasn't already completed/pickuped\n        if (oldStatus !== ORDER_STATUS.COMPLETED && oldStatus !== ORDER_STATUS.PICKUPED) {\n          stockChange = -item.quantity;\n          availableChange = -item.quantity;\n          console.log(`üìâ SALE order ${orderId}: Decreasing stock by ${item.quantity} for product ${item.productId}`);\n        }\n      } else if (newStatus === ORDER_STATUS.CANCELLED) {\n        // Rollback stock if was previously completed/pickuped\n        if (oldStatus === ORDER_STATUS.COMPLETED || oldStatus === ORDER_STATUS.PICKUPED) {\n          stockChange = item.quantity;\n          availableChange = item.quantity;\n          console.log(`üìà SALE order ${orderId}: Rolling back stock by ${item.quantity} for product ${item.productId}`);\n        }\n      }\n      // RESERVED status doesn't change stock (just reserved, not sold yet)\n    } else if (orderType === ORDER_TYPE.RENT) {\n      // RENT orders: Use renting field (temporary), stock doesn't change\n      if (newStatus === ORDER_STATUS.RESERVED) {\n        // Reserve: No change to stock/renting/available (items still in stock)\n        // Reserved is only checked in availability API with date conflicts\n        // Only if not already reserved\n        if (oldStatus !== ORDER_STATUS.RESERVED && oldStatus !== ORDER_STATUS.PICKUPED) {\n          // No stock/renting/available change - reserved items are still physically in stock\n          console.log(`üîí RENT order ${orderId}: Reserving ${item.quantity} for product ${item.productId} (items still in stock)`);\n        }\n      } else if (newStatus === ORDER_STATUS.PICKUPED) {\n        // Pickup: Increase renting, decrease available (if not already picked up)\n        if (oldStatus !== ORDER_STATUS.PICKUPED) {\n          if (oldStatus === ORDER_STATUS.RESERVED) {\n            // From RESERVED: renting increases, available decreases\n            rentingChange = item.quantity;\n            availableChange = -item.quantity;\n          } else {\n            // From other status (e.g., directly to PICKUPED): both renting and available change\n            rentingChange = item.quantity;\n            availableChange = -item.quantity;\n          }\n          console.log(`üì§ RENT order ${orderId}: Picking up ${item.quantity} for product ${item.productId}`);\n        }\n      } else if (newStatus === ORDER_STATUS.RETURNED) {\n        // Return: Decrease renting, increase available\n        if (oldStatus === ORDER_STATUS.PICKUPED) {\n          rentingChange = -item.quantity;\n          availableChange = item.quantity;\n          console.log(`üì• RENT order ${orderId}: Returning ${item.quantity} for product ${item.productId}`);\n        }\n      } else if (newStatus === ORDER_STATUS.CANCELLED) {\n        // Cancel: Rollback based on previous status\n        if (oldStatus === ORDER_STATUS.PICKUPED) {\n          // Was picked up: rollback renting and available\n          rentingChange = -item.quantity;\n          availableChange = item.quantity;\n          console.log(`‚Ü©Ô∏è RENT order ${orderId}: Cancelling pickup, rolling back ${item.quantity} for product ${item.productId}`);\n        } else if (oldStatus === ORDER_STATUS.RESERVED) {\n          // Was only reserved: no rollback needed (items were still in stock)\n          // Reserved items don't affect available, so no change needed\n          console.log(`‚Ü©Ô∏è RENT order ${orderId}: Cancelling reservation for product ${item.productId} (items were still in stock)`);\n        }\n      }\n    }\n\n    // Apply changes if any\n    if (stockChange !== 0 || rentingChange !== 0 || availableChange !== 0) {\n      const updateData: any = {};\n      \n      // Use increment for stock and renting\n      if (stockChange !== 0) {\n        updateData.stock = { increment: stockChange };\n      }\n      \n      if (rentingChange !== 0) {\n        updateData.renting = { increment: rentingChange };\n      }\n\n      // Calculate final available value: available = stock - renting\n      // Note: Reserved orders are NOT counted in available calculation here.\n      // Reserved items are still in stock physically, just reserved temporarily.\n      // For accurate date-based availability with reserved conflicts, use the availability API.\n      const newStock = outletStock.stock + stockChange;\n      const newRenting = outletStock.renting + rentingChange;\n      \n      // Calculate available: stock - renting (reserved items are still in stock)\n      const finalAvailable = Math.max(0, newStock - newRenting);\n      updateData.available = finalAvailable;\n\n      await prisma.outletStock.update({\n        where: { id: outletStock.id },\n        data: updateData,\n      });\n\n      console.log(`‚úÖ Updated OutletStock for product ${item.productId}, outlet ${outletId}:`, {\n        stockChange,\n        rentingChange,\n        availableChange,\n        newStock,\n        newRenting,\n        newAvailable: finalAvailable,\n      });\n\n      // Sync Product.totalStock = sum of all OutletStock.stock for this product\n      // Only sync if stock changed (SALE orders - permanent stock reduction)\n      if (stockChange !== 0) {\n        await syncProductTotalStock(item.productId);\n      }\n    }\n  }\n}\n\n/**\n * Delete product - follows dual ID system\n * Input: id (number), Output: deleted product data\n */\nexport async function deleteProduct(id: number): Promise<any> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${id} not found`);\n  }\n\n  // Delete the product (this will cascade to outletStock due to Prisma schema)\n  const deletedProduct = await prisma.product.delete({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  // Transform to match expected types\n  return {\n    id: deletedProduct.id,\n    name: deletedProduct.name,\n    description: deletedProduct.description,\n    barcode: deletedProduct.barcode,\n    totalStock: deletedProduct.totalStock,\n    rentPrice: deletedProduct.rentPrice,\n    salePrice: deletedProduct.salePrice,\n    deposit: deletedProduct.deposit,\n    images: deletedProduct.images,\n    isActive: deletedProduct.isActive,\n    createdAt: deletedProduct.createdAt,\n    updatedAt: deletedProduct.updatedAt,\n    category: {\n      id: deletedProduct.category.id,\n      name: deletedProduct.category.name,\n    },\n    merchant: {\n      id: deletedProduct.merchant.id,\n      name: deletedProduct.merchant.name,\n    },\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedProducts = {\n  /**\n   * Find product by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.product.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true, address: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Find product by barcode (simplified API)\n   */\n  findByBarcode: async (barcode: string) => {\n    return await prisma.product.findUnique({\n      where: { barcode },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new product (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('üîç simplifiedProducts.create called with data:', data);\n      \n      // If no categoryId provided, get or create default category\n      if (!data.categoryId && data.merchant && data.merchant.connect && data.merchant.connect.id) {\n        const merchantPublicId = data.merchant.connect.id; // This is the public ID (number)\n        const defaultCategory = await getOrCreateDefaultCategory(merchantPublicId);\n        \n        // Add category connection to data\n        data.category = { connect: { id: defaultCategory.id } };\n        console.log('‚úÖ Using default category:', defaultCategory.id, 'for merchant:', merchantPublicId);\n      }\n      \n      const product = await prisma.product.create({\n        data,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          category: { select: { id: true, name: true } },\n          outletStock: {\n            include: {\n              outlet: { select: { id: true, name: true } }\n            }\n          }\n        }\n      });\n      \n      console.log('‚úÖ Product created successfully:', product.id);\n      return product;\n    } catch (error) {\n      console.error('‚ùå Error in simplifiedProducts.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update product (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.product.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Delete product (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.product.update({\n      where: { id },\n      data: { isActive: false }\n    });\n  },\n\n  /**\n   * Find first product matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.product.findFirst({\n      where,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get product statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.product.count({ where });\n  },\n\n  /**\n   * Search products with simple filters (simplified API)\n   * Handles conversion of public IDs (numbers) to CUIDs for database queries\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, sortBy, sortOrder, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {\n      isActive: whereFilters.isActive !== undefined ? whereFilters.isActive : true\n    };\n    \n    // Convert merchantId (public ID) to CUID\n    if (whereFilters.merchantId) {\n      const merchant = await prisma.merchant.findUnique({\n        where: { id: whereFilters.merchantId },\n        select: { id: true }\n      });\n      if (merchant) {\n        where.merchantId = merchant.id; // Use CUID\n      } else {\n        // Merchant not found, return empty result\n        return {\n          data: [],\n          total: 0,\n          page,\n          limit,\n          hasMore: false\n        };\n      }\n    }\n    \n    // Convert categoryId (public ID) to CUID\n    if (whereFilters.categoryId) {\n      const category = await prisma.category.findUnique({\n        where: { id: whereFilters.categoryId },\n        select: { id: true }\n      });\n      if (category) {\n        where.categoryId = category.id; // Use CUID\n      } else {\n        // Category not found, return empty result\n        return {\n          data: [],\n          total: 0,\n          page,\n          limit,\n          hasMore: false\n        };\n      }\n    }\n    \n    // Convert outletId (public ID) to CUID and filter by outlet stock\n    if (whereFilters.outletId) {\n      const outlet = await prisma.outlet.findUnique({\n        where: { id: whereFilters.outletId },\n        select: { id: true }\n      });\n      if (outlet) {\n        where.outletStock = {\n          some: {\n            outletId: outlet.id, // Use CUID\n            stock: { gt: 0 }\n          }\n        };\n      } else {\n        // Outlet not found, return empty result\n        return {\n          data: [],\n          total: 0,\n          page,\n          limit,\n          hasMore: false\n        };\n      }\n    }\n    \n    // Availability filter\n    if (whereFilters.available !== undefined) {\n      if (whereFilters.available) {\n        where.outletStock = {\n          ...(where.outletStock || {}),\n          some: {\n            available: { gt: 0 }\n          }\n        };\n      } else {\n        where.outletStock = {\n          ...(where.outletStock || {}),\n          none: {\n            available: { gt: 0 }\n          }\n        };\n      }\n    }\n    \n    // Text search (case-insensitive and diacritics-insensitive)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      const searchConditions: any[] = [\n        { name: { contains: searchTerm, mode: 'insensitive' } },\n        { description: { contains: searchTerm, mode: 'insensitive' } },\n        { barcode: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n      \n      // Add normalized search if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { name: { contains: normalizedTerm, mode: 'insensitive' } },\n          { description: { contains: normalizedTerm, mode: 'insensitive' } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    // Price range\n    if (whereFilters.minPrice !== undefined || whereFilters.maxPrice !== undefined) {\n      where.rentPrice = {};\n      if (whereFilters.minPrice !== undefined) where.rentPrice.gte = whereFilters.minPrice;\n      if (whereFilters.maxPrice !== undefined) where.rentPrice.lte = whereFilters.maxPrice;\n    }\n\n    // Build orderBy clause\n    const orderBy = buildProductOrderByClause(sortBy, sortOrder);\n\n    const [products, total] = await Promise.all([\n      prisma.product.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          category: { select: { id: true, name: true } },\n          outletStock: {\n            include: {\n              outlet: { select: { id: true, name: true, address: true } }\n            }\n          }\n        },\n        orderBy,\n        skip,\n        take: limit\n      }),\n      prisma.product.count({ where })\n    ]);\n\n    return {\n      data: products,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.product.count({ where });\n  }\n};\n","// ============================================================================\n// SIMPLIFIED DATABASE PACKAGE EXPORTS - NEW VERSION\n// ============================================================================\n// This is the new, simplified version that replaces the complex dual ID system\n// Goal: Reduce from 139 exports to ~10 simple functions\n\nimport { prisma } from './client';\nimport { simplifiedUsers } from './user';\nimport { simplifiedCustomers } from './customer';\nimport { simplifiedProducts } from './product';\nimport { simplifiedOrders } from './order';\nimport { simplifiedPayments } from './payment';\nimport { simplifiedOutlets } from './outlet';\nimport { simplifiedPlans } from './plan';\nimport { simplifiedSubscriptions } from './subscription';\nimport { simplifiedSubscriptionActivities } from './subscription-activity';\nimport { simplifiedMerchants } from './merchant';\nimport { simplifiedOrderNumbers } from './order-number-generator';\nimport { simplifiedCategories } from './category';\nimport { simplifiedAuditLogs } from './audit-logs';\nimport { simplifiedOrderItems } from './order-items';\nimport { sessions } from './sessions';\nimport { simplifiedSync } from './sync';\n\n// Optimized order functions (temporarily disabled due to type issues)\n// export { \n//   searchOrdersOptimized, \n//   searchOrdersWithCursor, \n//   getOrderDetailsOptimized, \n//   getOrderSummary \n// } from './order-optimized';\n\n// Database client\nexport { prisma };\n\n// ============================================================================\n// TYPES FOR SIMPLIFIED API\n// ============================================================================\n\nexport interface SimpleFilters {\n  merchantId?: number;\n  outletId?: number;\n  isActive?: boolean;\n  search?: string;\n  page?: number;\n  limit?: number;\n}\n\nexport interface SimpleResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  hasMore: boolean;\n}\n\n// ============================================================================\n// SIMPLIFIED DATABASE API\n// ============================================================================\n\n/**\n * Simplified database operations\n * Replaces the complex dual ID system with simple, consistent operations\n */\nconst db = {\n  // ============================================================================\n  // PRISMA CLIENT (for transactions)\n  // ============================================================================\n  prisma,\n\n  // ============================================================================\n  // USER OPERATIONS\n  // ============================================================================\n  users: simplifiedUsers,\n\n  // ============================================================================\n  // CUSTOMER OPERATIONS\n  // ============================================================================\n  customers: simplifiedCustomers,\n\n  // ============================================================================\n  // PRODUCT OPERATIONS\n  // ============================================================================\n  products: simplifiedProducts,\n\n  // ============================================================================\n  // ORDER OPERATIONS\n  // ============================================================================\n  orders: simplifiedOrders,\n\n  // ============================================================================\n  // PAYMENT OPERATIONS\n  // ============================================================================\n  payments: simplifiedPayments,\n\n  // ============================================================================\n  // OUTLET OPERATIONS\n  // ============================================================================\n  outlets: simplifiedOutlets,\n\n  // ============================================================================\n  // MERCHANT OPERATIONS\n  // ============================================================================\n  merchants: simplifiedMerchants,\n\n  // ============================================================================\n  // PLAN OPERATIONS\n  // ============================================================================\n  plans: simplifiedPlans,\n\n  // ============================================================================\n  // CATEGORY OPERATIONS\n  // ============================================================================\n  categories: simplifiedCategories,\n\n  // ============================================================================\n  // AUDIT LOG OPERATIONS\n  // ============================================================================\n  auditLogs: simplifiedAuditLogs,\n\n  // ============================================================================\n  // ORDER ITEM OPERATIONS\n  // ============================================================================\n  orderItems: simplifiedOrderItems,\n\n  // ============================================================================\n  // SUBSCRIPTION OPERATIONS\n  // ============================================================================\n  subscriptions: simplifiedSubscriptions,\n\n  // ============================================================================\n  // ORDER NUMBER OPERATIONS\n  // ============================================================================\n  orderNumbers: simplifiedOrderNumbers,\n\n  // ============================================================================\n  // OUTLET STOCK OPERATIONS\n  // ============================================================================\n  outletStock: {\n    /**\n     * Aggregate outlet stock statistics\n     */\n    aggregate: async (options: any) => {\n      return await prisma.outletStock.aggregate(options);\n    }\n  },\n\n  // ============================================================================\n  // SUBSCRIPTION ACTIVITY OPERATIONS\n  // ============================================================================\n  subscriptionActivities: simplifiedSubscriptionActivities,\n\n  // ============================================================================\n  // SESSION OPERATIONS (Single Session Enforcement)\n  // ============================================================================\n  sessions,\n\n  // ============================================================================\n  // SYNC OPERATIONS (Temporary - for sync-standalone endpoint)\n  // ============================================================================\n  sync: simplifiedSync\n};\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check database connection health\n */\nconst checkDatabaseConnection = async () => {\n  try {\n    await prisma.$queryRaw`SELECT 1`;\n    return { status: 'connected' };\n  } catch (error) {\n    return { status: 'disconnected', error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n};\n\n/**\n * Generate next order number (simplified) - Random 6 digits\n */\nconst generateOrderNumber = async (outletId: number): Promise<string> => {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Generate random 6-digit number (100000 to 999999)\n  const generateRandom6Digits = (): string => {\n    return Math.floor(100000 + Math.random() * 900000).toString();\n  };\n\n  const maxRetries = 10;\n  for (let i = 0; i < maxRetries; i++) {\n    const orderNumber = generateRandom6Digits();\n    \n    // Check if order number already exists\n    const existingOrder = await prisma.order.findUnique({\n      where: { orderNumber }\n    });\n\n    if (!existingOrder) {\n      return orderNumber;\n    }\n  }\n\n  throw new Error('Failed to generate unique 6-digit random order number after maximum retries');\n};\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport { db, checkDatabaseConnection, generateOrderNumber };\n\n// Export payment functions\nexport { simplifiedPayments } from './payment';\n\n// Export subscription activity functions\nexport { simplifiedSubscriptionActivities } from './subscription-activity';\n\n// Legacy exports for backward compatibility\nexport { getSubscriptionByMerchantId, createSubscriptionPayment, updateSubscription, getExpiredSubscriptions, getSubscriptionById } from './subscription';\nexport { AuditLogger, getAuditLogger, extractAuditContext } from './audit';\nexport type { AuditContext } from './audit';\nexport { getOutletOrderStats, createOrderNumberWithFormat } from './order-number-generator';\nexport { getDefaultOutlet, getDefaultBankAccount } from './outlet';\nexport type { OrderNumberFormat } from './order-number-generator';\nexport { searchOrders } from './order'; // Legacy order search function\n\n// Registration functions\nexport { registerUser, registerMerchantWithTrial } from './registration';\nexport type { RegistrationInput, RegistrationResult } from './registration';\n\n// Email verification functions\nexport * from './email-verification';\n\n// Password reset functions\nexport * from './password-reset';\n\n// Query builder helpers\nexport * from './query-builder';\n\n// ============================================================================\n// MIGRATION GUIDE\n// ============================================================================\n/*\nOLD WAY (139 exports):\nimport { \n  findOutletByPublicId, \n  convertOutletPublicIdToDatabaseId,\n  getCustomerByPublicId as getCustomerById,\n  getOutletByPublicId as getOutletById,\n  // ... 135 more exports\n} from '@rentalshop/database';\n\nNEW WAY (3 main exports):\nimport { db, prisma, checkDatabaseConnection } from '@rentalshop/database';\n\n// Usage examples:\nconst user = await db.users.findById(123);\nconst users = await db.users.search({ merchantId: 1, page: 1, limit: 20 });\nconst product = await db.products.findByBarcode('123456789');\nconst orders = await db.orders.search({ outletId: 1, status: 'ACTIVE' });\n\nBENEFITS:\n‚úÖ 93% reduction in exports (139 ‚Üí 10)\n‚úÖ Consistent API across all entities\n‚úÖ No more dual ID complexity\n‚úÖ Better TypeScript support\n‚úÖ Easier to maintain and debug\n‚úÖ Better performance with optimized queries\n*/\n","// ============================================================================\n// USER FUNCTIONS\n// ============================================================================\n// This file contains user functions that use integer IDs:\n// - Input: id (number)\n// - Database: queries by id (auto-incrementing integer)\n// - Return: includes id (number)\n\nimport { prisma } from './client';\nimport type { UserCreateInput, UserUpdateInput } from '@rentalshop/types';\nimport { hashPassword } from '@rentalshop/auth';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\n// ============================================================================\n// USER LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find user by ID\n */\nexport async function findUserById(id: number) {\n  return await prisma.user.findUnique({\n    where: { id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get user by ID\n */\nexport async function getUserById(id: number) {\n  return await prisma.user.findUnique({\n    where: { id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// USER CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new user - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createUser(input: UserCreateInput): Promise<any> {\n  // Generate next user id\n  const lastUser = await prisma.user.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastUser?.id || 0) + 1;\n\n  // Find merchant by id if provided\n  let merchantId: number | undefined;\n  if (input.merchantId) {\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: input.merchantId }\n    });\n    if (!merchant) {\n      throw new Error(`Merchant with id ${input.merchantId} not found`);\n    }\n    merchantId = merchant.id;\n  }\n\n  // Find outlet by id if provided\n  let outletId: number | undefined;\n  if (input.outletId) {\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: input.outletId }\n    });\n    if (!outlet) {\n      throw new Error(`Outlet with id ${input.outletId} not found`);\n    }\n    outletId = outlet.id;\n  }\n\n  // Create user\n  const user = await prisma.user.create({\n    data: {\n      id: nextPublicId,\n      email: input.email,\n      password: input.password,\n      firstName: input.firstName,\n      lastName: input.lastName,\n      phone: input.phone,\n      role: input.role,\n      isActive: true,\n      merchantId,\n      outletId,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return user;\n}\n\n// ============================================================================\n// USER UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update user - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateUser(\n  id: number,\n  input: UserUpdateInput\n): Promise<any> {\n  // Find user by id\n  const existingUser = await prisma.user.findUnique({\n    where: { id }\n  });\n\n  if (!existingUser) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  // Update user - only update fields that are provided\n  const updateData: any = {};\n  if (input.firstName !== undefined) updateData.firstName = input.firstName;\n  if (input.lastName !== undefined) updateData.lastName = input.lastName;\n  if (input.phone !== undefined) updateData.phone = input.phone;\n  // Note: email updates are disabled for security reasons\n\n  const updatedUser = await prisma.user.update({\n    where: { id },\n    data: updateData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n          phone: true,\n          address: true,\n          city: true,\n          state: true,\n          zipCode: true,\n          country: true,\n          businessType: true,\n          taxId: true,\n          website: true,\n          description: true,\n          isActive: true,\n          planId: true,\n          // subscriptionStatus removed - use subscription.status\n          totalRevenue: true,\n          createdAt: true,\n          lastActiveAt: true,\n        }\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          phone: true,\n          description: true,\n          isActive: true,\n          isDefault: true,\n          createdAt: true,\n          merchant: {\n            select: {\n              id: true,\n              name: true,\n            }\n          }\n        }\n      },\n    },\n  });\n\n  return updatedUser;\n}\n\n// ============================================================================\n// USER UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Helper: Build where clause excluding soft-deleted users\n * Automatically filters out users with deletedAt != null\n */\nfunction buildUserWhere(additionalWhere: any = {}) {\n  return {\n    ...additionalWhere,\n    deletedAt: null, // Only include non-deleted users\n  };\n}\n\n/**\n * Get users by merchant - follows dual ID system\n * Automatically excludes soft-deleted users\n */\nexport async function getUsersByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.user.findMany({\n    where: buildUserWhere({ merchantId: merchant.id }),\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get users by outlet - follows dual ID system\n * Automatically excludes soft-deleted users\n */\nexport async function getUsersByOutlet(outletId: number) {\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  return await prisma.user.findMany({\n    where: buildUserWhere({ outletId: outlet.id }),\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n// ============================================================================\n// USER SOFT DELETE FUNCTIONS\n// ============================================================================\n\n/**\n * Soft delete user by public ID - follows dual ID system\n * Sets isActive to false and deletedAt to current timestamp\n */\nexport async function softDeleteUser(id: number): Promise<any> {\n  // Find user by id\n  const user = await prisma.user.findUnique({\n    where: { id },\n    select: { id: true, email: true, isActive: true, deletedAt: true }\n  });\n\n  if (!user) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  if (user.deletedAt) {\n    throw new Error(`User with id ${id} is already deleted`);\n  }\n\n  // Soft delete the user\n  const deletedUser = await prisma.user.update({\n    where: { id: user.id },\n    data: {\n      isActive: false,\n      deletedAt: new Date(),\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return deletedUser;\n}\n\n/**\n * Restore soft deleted user by public ID - follows dual ID system\n * Sets isActive to true and clears deletedAt\n */\nexport async function restoreUser(id: number): Promise<any> {\n  // Find user by id\n  const user = await prisma.user.findUnique({\n    where: { id },\n    select: { id: true, email: true, isActive: true, deletedAt: true }\n  });\n\n  if (!user) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  if (!user.deletedAt) {\n    throw new Error(`User with id ${id} is not deleted`);\n  }\n\n  // Restore the user\n  const restoredUser = await prisma.user.update({\n    where: { id: user.id },\n    data: {\n      isActive: true,\n      deletedAt: null,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return restoredUser;\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedUsers = {\n  /**\n   * Find user by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.user.findUnique({\n      where: { id },\n      include: {\n        merchant: { \n          select: { \n            id: true, \n            name: true,\n            email: true,\n            phone: true,\n            address: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            businessType: true,\n            pricingType: true,\n            taxId: true,\n            website: true,\n            description: true,\n            isActive: true,\n            planId: true,\n            // subscriptionStatus removed - use subscription.status\n            totalRevenue: true,\n            createdAt: true,\n            lastActiveAt: true\n          } \n        },\n        outlet: { \n          select: { \n            id: true, \n            name: true,\n            address: true,\n            phone: true,\n            description: true,\n            isActive: true,\n            isDefault: true,\n            createdAt: true,\n            merchant: {\n              select: {\n                id: true,\n                name: true,\n              }\n            }\n          } \n        }\n      }\n    });\n  },\n\n  /**\n   * Find user by email (simplified API)\n   */\n  findByEmail: async (email: string) => {\n    return await prisma.user.findUnique({\n      where: { email },\n      select: {\n        id: true,\n        email: true,\n        password: true,\n        firstName: true,\n        lastName: true,\n        phone: true,\n        role: true,\n        isActive: true,\n        emailVerified: true,\n        emailVerifiedAt: true,\n        passwordChangedAt: true, // ‚úÖ Include passwordChangedAt for token validation\n        createdAt: true,\n        updatedAt: true,\n        merchantId: true,\n        outletId: true,\n        deletedAt: true,\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Find first user matching criteria (simplified API)\n   */\n  findFirst: async (where: any) => {\n    return await prisma.user.findFirst({\n      where,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Create new user (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('üîç simplifiedUsers.create called with data:', data);\n      \n      // Password should already be hashed when passed to this function\n      const userData = { ...data };\n\n      // Validate merchantId exists if provided\n      if (userData.merchantId && typeof userData.merchantId === 'number') {\n        const merchant = await prisma.merchant.findUnique({\n          where: { id: userData.merchantId },\n          select: { id: true, name: true }\n        });\n        \n        if (!merchant) {\n          throw new Error(`Merchant with id ${userData.merchantId} not found`);\n        }\n        \n        console.log('‚úÖ Merchant found:', merchant);\n        // Keep the number ID as-is since schema uses Int IDs\n      }\n\n      // Validate outletId exists if provided\n      if (userData.outletId && typeof userData.outletId === 'number') {\n        const outlet = await prisma.outlet.findUnique({\n          where: { id: userData.outletId },\n          select: { id: true, name: true, merchantId: true }\n        });\n        \n        if (!outlet) {\n          throw new Error(`Outlet with id ${userData.outletId} not found`);\n        }\n        \n        // Validate outlet belongs to the same merchant\n        if (userData.merchantId && outlet.merchantId !== userData.merchantId) {\n          throw new Error(`Outlet ${userData.outletId} does not belong to merchant ${userData.merchantId}`);\n        }\n        \n        console.log('‚úÖ Outlet found:', outlet);\n        // Keep the number ID as-is since schema uses Int IDs\n      }\n\n      // Check for duplicate email globally\n      if (userData.email) {\n        const existingEmail = await prisma.user.findUnique({\n          where: { email: userData.email },\n          select: { id: true, email: true }\n        });\n        \n        if (existingEmail) {\n          throw new Error(`Email ${userData.email} is already registered`);\n        }\n      }\n\n      // Check for duplicate phone within merchant\n      if (userData.phone && userData.merchantId) {\n        const existingPhone = await prisma.user.findFirst({\n          where: { \n            phone: userData.phone,\n            merchantId: userData.merchantId\n          },\n          select: { id: true, phone: true, merchantId: true }\n        });\n        \n        if (existingPhone) {\n          throw new Error(`Phone number ${userData.phone} is already registered in this merchant`);\n        }\n      }\n\n      // Generate next user id\n      const lastUser = await prisma.user.findFirst({\n        orderBy: { id: 'desc' },\n        select: { id: true }\n      });\n      const nextPublicId = (lastUser?.id || 0) + 1;\n      userData.id = nextPublicId;\n\n      const user = await prisma.user.create({\n        data: userData,\n        include: {\n          merchant: { \n            select: { \n              id: true, \n              name: true,\n              email: true,\n              phone: true,\n              address: true,\n              city: true,\n              state: true,\n              zipCode: true,\n              country: true,\n              businessType: true,\n              taxId: true,\n              website: true,\n              description: true,\n              isActive: true,\n              planId: true,\n              // subscriptionStatus removed - use subscription.status\n              totalRevenue: true,\n              createdAt: true,\n              lastActiveAt: true\n            } \n          },\n          outlet: { \n            select: { \n              id: true, \n              name: true,\n              address: true,\n              phone: true,\n              description: true,\n              isActive: true,\n              isDefault: true,\n              createdAt: true,\n              merchant: {\n                select: {\n                  id: true,\n                  name: true,\n                }\n              }\n            } \n          }\n        }\n      });\n      \n      console.log('‚úÖ User created successfully:', user);\n      return user;\n    } catch (error) {\n      console.error('‚ùå Error in simplifiedUsers.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update user (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.user.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Delete user (hard delete) (simplified API)\n   * Hard delete removes user from database permanently.\n   * Note: If user has created orders, the orders.createdById will remain but user will be deleted.\n   * This is acceptable as orders preserve the ID reference even if user no longer exists.\n   */\n  delete: async (id: number) => {\n    // Check if user has created any orders\n    const orderCount = await prisma.order.count({\n      where: { createdById: id }\n    });\n\n    if (orderCount > 0) {\n      console.log(`‚ö†Ô∏è Warning: User ${id} has created ${orderCount} orders. User will be hard deleted but orders.createdById will remain.`);\n    }\n\n    // Hard delete the user\n    // Note: UserSession will be cascade deleted due to onDelete: Cascade in schema\n    // Orders.createdById will remain with the deleted user's ID (historical reference)\n    return await prisma.user.delete({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Search users with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    // Automatically exclude soft-deleted users (deletedAt = null)\n    where.deletedAt = null;\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.outletId) where.outletId = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    \n    // Handle role filtering - roles array has priority over single role\n    if (whereFilters.roles && Array.isArray(whereFilters.roles)) {\n      where.role = { in: whereFilters.roles };\n    } else if (whereFilters.role) {\n      where.role = whereFilters.role;\n    }\n    \n    // Text search (case-insensitive and diacritics-insensitive)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      // Normalize Vietnamese text to support search without diacritics\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      // Search with both original and normalized terms to support diacritics-insensitive search\n      const searchConditions: any[] = [\n        { firstName: { contains: searchTerm, mode: 'insensitive' } },\n        { lastName: { contains: searchTerm, mode: 'insensitive' } },\n        { email: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n      \n      // Add normalized search if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { firstName: { contains: normalizedTerm, mode: 'insensitive' } },\n          { lastName: { contains: normalizedTerm, mode: 'insensitive' } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    // ‚úÖ Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [users, total] = await Promise.all([\n      prisma.user.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          outlet: { select: { id: true, name: true } }\n        },\n        orderBy, // ‚úÖ Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.user.count({ where })\n    ]);\n\n    console.log(`üìä db.users.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, users=${users.length}`);\n\n    return {\n      data: users,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const baseWhere = options?.where || {};\n    // Automatically exclude soft-deleted users\n    const where = buildUserWhere(baseWhere);\n    return await prisma.user.count({ where });\n  },\n\n  /**\n   * Get user statistics (simplified API)\n   * Automatically excludes soft-deleted users\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const baseWhere = whereClause?.where || whereClause || {};\n    // Automatically exclude soft-deleted users\n    const where = buildUserWhere(baseWhere);\n    return await prisma.user.count({ where });\n  }\n};\n","// ============================================================================\n// NEW: CORRECT DUAL ID CUSTOMER FUNCTIONS\n// ============================================================================\n// This file contains only the correct customer functions that follow the dual ID system:\n// - Input: id (number)\n// - Database: queries by id, uses CUIDs for relationships\n// - Return: includes both id (CUID) and id (number)\n\nimport { prisma } from './client';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\nimport type { \n  CustomerInput, \n  CustomerUpdateInput, \n  CustomerSearchFilter,\n  CustomerSearchResult,\n  CustomerSearchResponse \n} from '@rentalshop/types';\n\n// ============================================================================\n// CUSTOMER LOOKUP FUNCTIONS (BY PUBLIC ID)\n// ============================================================================\n\n/**\n * Get customer by public ID and merchant - follows dual ID system\n * Input: id (number) and merchantId (number), Output: Customer with relations\n */\nexport async function getCustomerByPublicId(id: number, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findFirst({\n    where: { \n      id,\n      merchantId: merchant.id // Use CUID for merchant\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      orders: {\n        select: {\n          id: true,\n          orderNumber: true,\n          status: true,\n          totalAmount: true,\n          createdAt: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get customer by email and merchant - follows dual ID system\n */\nexport async function getCustomerByEmail(email: string, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      email: email,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get customer by phone and merchant - follows dual ID system\n */\nexport async function getCustomerByPhone(phone: string, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      phone: phone,\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// CUSTOMER CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new customer - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createCustomer(input: CustomerInput): Promise<any> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: input.merchantId }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${input.merchantId} not found`);\n  }\n\n  // Generate next customer id\n  const lastCustomer = await prisma.customer.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastCustomer?.id || 0) + 1;\n\n  // Create customer\n  // lastName and phone are now optional (nullable) in schema\n  // Convert empty strings to null for optional fields\n  const customer = await prisma.customer.create({\n    data: {\n      id: nextPublicId,\n      firstName: input.firstName || '',\n      lastName: input.lastName && input.lastName.trim() !== '' ? input.lastName.trim() : null,\n      phone: input.phone && input.phone.trim() !== '' ? input.phone.trim() : null,\n      // Optional fields: convert empty strings to null\n      email: input.email && input.email.trim() !== '' ? input.email.trim() : null,\n      address: input.address && input.address.trim() !== '' ? input.address.trim() : null,\n      city: input.city && input.city.trim() !== '' ? input.city.trim() : null,\n      state: input.state && input.state.trim() !== '' ? input.state.trim() : null,\n      zipCode: input.zipCode && input.zipCode.trim() !== '' ? input.zipCode.trim() : null,\n      country: input.country && input.country.trim() !== '' ? input.country.trim() : null,\n      idNumber: input.idNumber && input.idNumber.trim() !== '' ? input.idNumber.trim() : null,\n      notes: input.notes && input.notes.trim() !== '' ? input.notes.trim() : null,\n      dateOfBirth: input.dateOfBirth || null,\n      idType: input.idType || null,\n      isActive: true, // Default to true\n      merchantId: merchant.id, // Use CUID\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return customer;\n}\n\n// ============================================================================\n// CUSTOMER UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update customer - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateCustomer(\n  id: number,\n  input: CustomerUpdateInput\n): Promise<any> {\n  // Find customer by id\n  const existingCustomer = await prisma.customer.findUnique({\n    where: { id }\n  });\n\n  if (!existingCustomer) {\n    throw new Error(`Customer with id ${id} not found`);\n  }\n\n  // Update customer\n  // lastName and phone are now optional (nullable) in schema\n  // Convert empty strings to null for optional fields\n  const updateData: any = {};\n  \n  // Only include fields that are being updated\n  if (input.firstName !== undefined) updateData.firstName = input.firstName || '';\n  if (input.lastName !== undefined) {\n    updateData.lastName = input.lastName && input.lastName.trim() !== '' ? input.lastName.trim() : null;\n  }\n  if (input.phone !== undefined) {\n    updateData.phone = input.phone && input.phone.trim() !== '' ? input.phone.trim() : null;\n  }\n  \n  // Optional fields: convert empty strings to null\n  if (input.email !== undefined) {\n    updateData.email = input.email && input.email.trim() !== '' ? input.email.trim() : null;\n  }\n  if (input.address !== undefined) {\n    updateData.address = input.address && input.address.trim() !== '' ? input.address.trim() : null;\n  }\n  if (input.city !== undefined) {\n    updateData.city = input.city && input.city.trim() !== '' ? input.city.trim() : null;\n  }\n  if (input.state !== undefined) {\n    updateData.state = input.state && input.state.trim() !== '' ? input.state.trim() : null;\n  }\n  if (input.zipCode !== undefined) {\n    updateData.zipCode = input.zipCode && input.zipCode.trim() !== '' ? input.zipCode.trim() : null;\n  }\n  if (input.country !== undefined) {\n    updateData.country = input.country && input.country.trim() !== '' ? input.country.trim() : null;\n  }\n  if (input.idNumber !== undefined) {\n    updateData.idNumber = input.idNumber && input.idNumber.trim() !== '' ? input.idNumber.trim() : null;\n  }\n  if (input.notes !== undefined) {\n    updateData.notes = input.notes && input.notes.trim() !== '' ? input.notes.trim() : null;\n  }\n  if (input.dateOfBirth !== undefined) {\n    updateData.dateOfBirth = input.dateOfBirth || null;\n  }\n  if (input.idType !== undefined) {\n    updateData.idType = input.idType || null;\n  }\n  if (input.isActive !== undefined) {\n    updateData.isActive = input.isActive;\n  }\n  \n  const updatedCustomer = await prisma.customer.update({\n    where: { id },\n    data: updateData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return updatedCustomer;\n}\n\n// ============================================================================\n// CUSTOMER SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Build order by clause for customer queries\n */\nfunction buildCustomerOrderByClause(sortBy?: string, sortOrder?: string): any {\n  const validSortFields = [\n    'createdAt', 'updatedAt', 'firstName', 'lastName', 'email', 'phone'\n  ];\n  \n  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';\n  const order = sortOrder === 'asc' ? 'asc' : 'desc';\n  \n  return { [field as string]: order };\n}\n\n/**\n * Search customers - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchCustomers(\n  filters: CustomerSearchFilter\n): Promise<CustomerSearchResponse> {\n  const {\n    q,\n    merchantId,\n    isActive,\n    city,\n    state,\n    country,\n    idType,\n    limit = 20,\n    offset = 0,\n    sortBy,\n    sortOrder\n  } = filters;\n\n  // Build where conditions\n  const where: any = {};\n\n  if (merchantId) {\n    // Find merchant by id\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: merchantId },\n      select: { id: true }\n    });\n    \n    if (merchant) {\n      where.merchantId = merchant.id; // Use CUID\n    }\n  }\n\n  // Default to active customers only\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  } else {\n    where.isActive = true;\n  }\n\n  if (city) {\n    where.city = { contains: city.toLowerCase() };\n  }\n\n  if (state) {\n    where.state = { contains: state.toLowerCase() };\n  }\n\n  if (country) {\n    where.country = { contains: country.toLowerCase() };\n  }\n\n  if (idType) {\n    where.idType = idType;\n  }\n\n  // Search query for name, email, phone, or idNumber (case-insensitive and diacritics-insensitive)\n  if (q && q.trim()) {\n    const searchQuery = q.trim();\n    // Normalize Vietnamese text to support search without diacritics\n    const normalizedQuery = removeVietnameseDiacritics(searchQuery);\n    \n    // Search with both original and normalized terms to support diacritics-insensitive search\n    const searchConditions: any[] = [\n      { firstName: { contains: searchQuery, mode: 'insensitive' } },\n      { lastName: { contains: searchQuery, mode: 'insensitive' } },\n      { email: { contains: searchQuery, mode: 'insensitive' } },\n      { phone: { contains: searchQuery } } // Phone numbers are usually exact match\n    ];\n    \n    // Add normalized search if different from original\n    if (normalizedQuery !== searchQuery) {\n      searchConditions.push(\n        { firstName: { contains: normalizedQuery, mode: 'insensitive' } },\n        { lastName: { contains: normalizedQuery, mode: 'insensitive' } }\n      );\n    }\n    \n    where.OR = searchConditions;\n  }\n\n  // Get total count\n  const total = await prisma.customer.count({ where });\n\n  // Get customers with pagination\n  const customers = await prisma.customer.findMany({\n    where,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    },\n    orderBy: buildCustomerOrderByClause(sortBy, sortOrder),\n    take: limit,\n    skip: offset\n  });\n\n  // Transform to match CustomerSearchResult type\n  const transformedCustomers: CustomerSearchResult[] = customers.map((customer: any) => ({\n    id: customer.id, // Use id (number) as required by CustomerSearchResult\n    firstName: customer.firstName,\n    lastName: customer.lastName,\n    email: customer.email || '',\n    phone: customer.phone,\n    address: customer.address || undefined,\n    city: customer.city || undefined,\n    state: customer.state || undefined,\n    zipCode: customer.zipCode || undefined,\n    country: customer.country || undefined,\n    dateOfBirth: customer.dateOfBirth || undefined,\n    idNumber: customer.idNumber || undefined,\n    idType: customer.idType as any,\n    notes: customer.notes || undefined,\n    isActive: customer.isActive,\n    createdAt: customer.createdAt,\n    updatedAt: customer.updatedAt,\n    merchantId: customer.merchant.id, // Add merchantId as required\n    merchant: {\n      id: customer.merchant.id, // Use id (number) as required\n      name: customer.merchant.name,\n    },\n  }));\n\n  return {\n    success: true,\n    data: {\n      customers: transformedCustomers as any, // Type assertion to handle CustomerWithMerchant mismatch\n      total,\n      page: Math.floor(offset / limit) + 1,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n      totalPages: Math.ceil(total / limit),\n    },\n  };\n}\n\n// ============================================================================\n// CUSTOMER UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get customers by merchant - follows dual ID system\n */\nexport async function getCustomersByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  return await prisma.customer.findMany({\n    where: { merchantId: merchant.id }, // Use CUID\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Check if customer exists by email - follows dual ID system\n */\nexport async function customerExistsByEmail(email: string, merchantId: number): Promise<boolean> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const customer = await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      email: email,\n    },\n  });\n\n  return !!customer;\n}\n\n/**\n * Check if customer exists by phone - follows dual ID system\n */\nexport async function customerExistsByPhone(phone: string, merchantId: number): Promise<boolean> {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const customer = await prisma.customer.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      phone: phone,\n    },\n  });\n\n  return !!customer;\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedCustomers = {\n  /**\n   * Find customer by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.customer.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        orders: {\n          select: { id: true, orderNumber: true, totalAmount: true, status: true, createdAt: true },\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new customer (simplified API)\n   */\n  create: async (data: any) => {\n    // lastName and phone are now optional (nullable) in schema\n    // Convert empty strings to null for optional fields\n    const customerData = {\n      ...data,\n      firstName: data.firstName || '',\n      lastName: data.lastName && data.lastName.trim() !== '' ? data.lastName.trim() : null,\n      phone: data.phone && data.phone.trim() !== '' ? data.phone.trim() : null,\n      // Optional fields: convert empty strings to null\n      email: data.email && data.email.trim() !== '' ? data.email.trim() : null,\n      address: data.address && data.address.trim() !== '' ? data.address.trim() : null,\n      city: data.city && data.city.trim() !== '' ? data.city.trim() : null,\n      state: data.state && data.state.trim() !== '' ? data.state.trim() : null,\n      zipCode: data.zipCode && data.zipCode.trim() !== '' ? data.zipCode.trim() : null,\n      country: data.country && data.country.trim() !== '' ? data.country.trim() : null,\n      idNumber: data.idNumber && data.idNumber.trim() !== '' ? data.idNumber.trim() : null,\n      notes: data.notes && data.notes.trim() !== '' ? data.notes.trim() : null,\n      dateOfBirth: data.dateOfBirth || null,\n      idType: data.idType || null,\n    };\n    \n    // Remove merchant connection from data since it's handled by Prisma relations\n    delete customerData.merchant;\n    \n    return await prisma.customer.create({\n      data: customerData,\n      include: {\n        merchant: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Update customer (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    // lastName and phone are now optional (nullable) in schema\n    // Convert empty strings to null for optional fields\n    const updateData: any = {};\n    \n    // Only include fields that are being updated\n    if (data.firstName !== undefined) updateData.firstName = data.firstName || '';\n    if (data.lastName !== undefined) {\n      updateData.lastName = data.lastName && data.lastName.trim() !== '' ? data.lastName.trim() : null;\n    }\n    if (data.phone !== undefined) {\n      updateData.phone = data.phone && data.phone.trim() !== '' ? data.phone.trim() : null;\n    }\n    \n    // Optional fields: convert empty strings to null\n    if (data.email !== undefined) {\n      updateData.email = data.email && data.email.trim() !== '' ? data.email.trim() : null;\n    }\n    if (data.address !== undefined) {\n      updateData.address = data.address && data.address.trim() !== '' ? data.address.trim() : null;\n    }\n    if (data.city !== undefined) {\n      updateData.city = data.city && data.city.trim() !== '' ? data.city.trim() : null;\n    }\n    if (data.state !== undefined) {\n      updateData.state = data.state && data.state.trim() !== '' ? data.state.trim() : null;\n    }\n    if (data.zipCode !== undefined) {\n      updateData.zipCode = data.zipCode && data.zipCode.trim() !== '' ? data.zipCode.trim() : null;\n    }\n    if (data.country !== undefined) {\n      updateData.country = data.country && data.country.trim() !== '' ? data.country.trim() : null;\n    }\n    if (data.idNumber !== undefined) {\n      updateData.idNumber = data.idNumber && data.idNumber.trim() !== '' ? data.idNumber.trim() : null;\n    }\n    if (data.notes !== undefined) {\n      updateData.notes = data.notes && data.notes.trim() !== '' ? data.notes.trim() : null;\n    }\n    if (data.dateOfBirth !== undefined) {\n      updateData.dateOfBirth = data.dateOfBirth || null;\n    }\n    if (data.idType !== undefined) {\n      updateData.idType = data.idType || null;\n    }\n    if (data.isActive !== undefined) {\n      updateData.isActive = data.isActive;\n    }\n    \n    return await prisma.customer.update({\n      where: { id },\n      data: updateData,\n      include: {\n        merchant: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Search customers with pagination (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.outletId) where.outletId = whereFilters.outletId;\n    // Default to active customers only unless explicitly requesting all\n    if (whereFilters.isActive !== undefined) {\n      where.isActive = whereFilters.isActive;\n    } else {\n      where.isActive = true; // Default: only show active customers\n    }\n    \n    // Text search across multiple fields (case-insensitive and diacritics-insensitive)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      const searchConditions: any[] = [\n        { firstName: { contains: searchTerm, mode: 'insensitive' } },\n        { lastName: { contains: searchTerm, mode: 'insensitive' } },\n        { email: { contains: searchTerm, mode: 'insensitive' } },\n        { phone: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n      \n      // Add normalized search for name fields if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { firstName: { contains: normalizedTerm, mode: 'insensitive' } },\n          { lastName: { contains: normalizedTerm, mode: 'insensitive' } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    // Specific field filters (case-insensitive and diacritics-insensitive for text fields)\n    if (whereFilters.firstName) {\n      const normalized = removeVietnameseDiacritics(whereFilters.firstName);\n      if (normalized !== whereFilters.firstName) {\n        const existingOR = where.OR || [];\n        where.OR = [\n          ...existingOR,\n          { firstName: { contains: whereFilters.firstName, mode: 'insensitive' } },\n          { firstName: { contains: normalized, mode: 'insensitive' } }\n        ];\n      } else {\n        where.firstName = { contains: whereFilters.firstName, mode: 'insensitive' };\n      }\n    }\n    if (whereFilters.lastName) {\n      const normalized = removeVietnameseDiacritics(whereFilters.lastName);\n      if (normalized !== whereFilters.lastName) {\n        const existingOR = where.OR || [];\n        where.OR = [\n          ...existingOR,\n          { lastName: { contains: whereFilters.lastName, mode: 'insensitive' } },\n          { lastName: { contains: normalized, mode: 'insensitive' } }\n        ];\n      } else {\n        where.lastName = { contains: whereFilters.lastName, mode: 'insensitive' };\n      }\n    }\n    if (whereFilters.email) where.email = { contains: whereFilters.email, mode: 'insensitive' };\n    if (whereFilters.phone) where.phone = { contains: whereFilters.phone, mode: 'insensitive' };\n    if (whereFilters.city) {\n      const normalized = removeVietnameseDiacritics(whereFilters.city);\n      if (normalized !== whereFilters.city) {\n        const existingOR = where.OR || [];\n        where.OR = [\n          ...existingOR,\n          { city: { contains: whereFilters.city, mode: 'insensitive' } },\n          { city: { contains: normalized, mode: 'insensitive' } }\n        ];\n      } else {\n        where.city = { contains: whereFilters.city, mode: 'insensitive' };\n      }\n    }\n    if (whereFilters.state) {\n      const normalized = removeVietnameseDiacritics(whereFilters.state);\n      if (normalized !== whereFilters.state) {\n        const existingOR = where.OR || [];\n        where.OR = [\n          ...existingOR,\n          { state: { contains: whereFilters.state, mode: 'insensitive' } },\n          { state: { contains: normalized, mode: 'insensitive' } }\n        ];\n      } else {\n        where.state = { contains: whereFilters.state, mode: 'insensitive' };\n      }\n    }\n    if (whereFilters.country) {\n      const normalized = removeVietnameseDiacritics(whereFilters.country);\n      if (normalized !== whereFilters.country) {\n        const existingOR = where.OR || [];\n        where.OR = [\n          ...existingOR,\n          { country: { contains: whereFilters.country, mode: 'insensitive' } },\n          { country: { contains: normalized, mode: 'insensitive' } }\n        ];\n      } else {\n        where.country = { contains: whereFilters.country, mode: 'insensitive' };\n      }\n    }\n\n    // ‚úÖ Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email' || sortBy === 'phone') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [customers, total] = await Promise.all([\n      prisma.customer.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          _count: {\n            select: { orders: true }\n          }\n        },\n        orderBy, // ‚úÖ Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.customer.count({ where })\n    ]);\n\n    console.log(`üìä db.customers.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, customers=${customers.length}`);\n\n    return {\n      data: customers,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Delete customer (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.customer.update({\n      where: { id },\n      data: { isActive: false },\n      select: {\n        id: true,\n        firstName: true,\n        lastName: true,\n        email: true,\n        phone: true,\n        address: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true,\n        merchantId: true\n      }\n    });\n  },\n\n  /**\n   * Find first customer matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.customer.findFirst({\n      where,\n      select: {\n        id: true,\n        firstName: true,\n        lastName: true,\n        email: true,\n        phone: true,\n        address: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true,\n        merchantId: true\n      }\n    });\n  },\n\n  /**\n   * Get customer statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.customer.count({ where });\n  }\n};\n","import { prisma } from './client';\nimport type { Prisma } from '@prisma/client';\nimport { ORDER_TYPE, ORDER_STATUS, PAYMENT_STATUS } from '@rentalshop/constants';\nimport type { \n  OrderSearchFilter,\n  OrderSearchResult,\n  OrderSearchResponse\n} from '@rentalshop/types';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\nexport interface OrderWithRelations {\n  id: number\n  orderNumber: string\n  orderType: string\n  status: string\n  totalAmount: number\n  depositAmount: number\n  securityDeposit: number\n  damageFee: number\n  lateFee: number\n  discountType?: string\n  discountValue: number\n  discountAmount: number\n  pickupPlanAt?: Date\n  returnPlanAt?: Date\n  pickedUpAt?: Date\n  returnedAt?: Date\n  rentalDuration?: number\n  isReadyToDeliver: boolean\n  collateralType?: string\n  collateralDetails?: string\n  notes?: string\n  pickupNotes?: string\n  returnNotes?: string\n  damageNotes?: string\n  createdAt: Date\n  updatedAt: Date\n  outletId: number\n  merchantId?: number // Extracted from outlet relation for authorization\n  customerId?: number\n  createdById: number\n  // Relations\n  customer?: {\n    id: number\n    firstName: string\n    lastName: string\n    phone?: string\n    email?: string\n    address?: string\n    idNumber?: string\n  }\n  outlet?: {\n    id: number\n    name: string\n    address: string\n    merchantId: number\n    merchant: {\n      id: number\n      name: string\n    }\n  }\n  createdBy?: {\n    id: number\n    firstName?: string\n    email: string\n  }\n  orderItems?: Array<{\n    id: number\n    quantity: number\n    unitPrice: number\n    totalPrice: number\n    productId: number\n    product?: {\n      id: number\n      name: string\n    }\n  }>\n  payments?: Array<{\n    id: number\n    amount: number\n    method: string\n    status: string\n    processedAt?: Date\n  }>\n}\n\nconst orderSelect = {\n  id: true,\n  orderNumber: true,\n  orderType: true,\n  status: true,\n  totalAmount: true,\n  depositAmount: true,\n  securityDeposit: true,\n  damageFee: true,\n  lateFee: true,\n  discountType: true,\n  discountValue: true,\n  discountAmount: true,\n  pickupPlanAt: true,\n  returnPlanAt: true,\n  pickedUpAt: true,\n  returnedAt: true,\n  rentalDuration: true,\n  isReadyToDeliver: true,\n  collateralType: true,\n  collateralDetails: true,\n  notes: true,\n  pickupNotes: true,\n  returnNotes: true,\n  damageNotes: true,\n  createdAt: true,\n  updatedAt: true,\n  outletId: true,\n  customerId: true,\n  createdById: true,\n} as const\n\nconst orderInclude = {\n  customer: {\n    select: {\n      id: true,\n      firstName: true,\n      lastName: true,\n      phone: true,\n      email: true,\n      address: true,\n      idNumber: true,\n    }\n  },\n  outlet: {\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      merchantId: true, // Include merchantId for authorization checks\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        }\n      }\n    }\n  },\n  createdBy: {\n    select: {\n      id: true,\n      firstName: true,\n      email: true,\n    }\n  },\n  orderItems: {\n    select: {\n      id: true,\n      quantity: true,\n      unitPrice: true,\n      totalPrice: true,\n      productId: true,\n      product: {\n        select: {\n          id: true,\n          name: true,\n        }\n      }\n    }\n  },\n  payments: {\n    select: {\n      id: true,\n      amount: true,\n      method: true,\n      status: true,\n      processedAt: true,\n    }\n  }\n} as const\n\nfunction transformOrder(order: any): OrderWithRelations {\n  return {\n    id: order.id,\n    orderNumber: order.orderNumber,\n    orderType: order.orderType,\n    status: order.status,\n    totalAmount: order.totalAmount,\n    depositAmount: order.depositAmount ?? 0,\n    securityDeposit: order.securityDeposit ?? 0,\n    damageFee: order.damageFee ?? 0,\n    lateFee: order.lateFee ?? 0,\n    discountType: order.discountType || undefined,\n    discountValue: order.discountValue ?? 0,\n    discountAmount: order.discountAmount ?? 0,\n    pickupPlanAt: order.pickupPlanAt || undefined,\n    returnPlanAt: order.returnPlanAt || undefined,\n    pickedUpAt: order.pickedUpAt || undefined,\n    returnedAt: order.returnedAt || undefined,\n    rentalDuration: order.rentalDuration || undefined,\n    isReadyToDeliver: order.isReadyToDeliver ?? false,\n    collateralType: order.collateralType || undefined,\n    collateralDetails: order.collateralDetails || undefined,\n    notes: order.notes || undefined,\n    pickupNotes: order.pickupNotes || undefined,\n    returnNotes: order.returnNotes || undefined,\n    damageNotes: order.damageNotes || undefined,\n    createdAt: order.createdAt,\n    updatedAt: order.updatedAt,\n    outletId: order.outletId,\n    merchantId: order.outlet?.merchantId, // Extract merchantId from outlet relation for authorization\n    customerId: order.customerId || undefined,\n    createdById: order.createdById,\n    // Relations\n    customer: order.customer,\n    outlet: order.outlet,\n    createdBy: order.createdBy,\n    orderItems: order.orderItems,\n    payments: order.payments,\n  }\n}\n\nexport async function getOrderById(id: number): Promise<OrderWithRelations | null> {\n  const order = await prisma.order.findUnique({\n    where: { id },\n    include: orderInclude,\n  })\n\n  if (!order) return null\n  return transformOrder(order)\n}\n\nexport async function getOrderByNumber(orderNumber: string): Promise<OrderWithRelations | null> {\n  const order = await prisma.order.findUnique({\n    where: { orderNumber },\n    include: orderInclude,\n  })\n\n  if (!order) return null\n  return transformOrder(order)\n}\n\nexport async function getOrdersByOutlet(outletId: number, limit = 50, offset = 0) {\n  const orders = await prisma.order.findMany({\n    where: { outletId },\n    include: orderInclude,\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: offset,\n  })\n\n  return orders.map(transformOrder)\n}\n\nexport async function getOrdersByCustomer(customerId: number, limit = 50, offset = 0) {\n  const orders = await prisma.order.findMany({\n    where: { customerId },\n    include: orderInclude,\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: offset,\n  })\n\n  return orders.map(transformOrder)\n}\n\nexport async function createOrder(data: {\n  orderNumber: string\n  orderType: string\n  status?: string\n  totalAmount: number\n  depositAmount?: number\n  securityDeposit?: number\n  damageFee?: number\n  lateFee?: number\n  discountType?: string\n  discountValue?: number\n  discountAmount?: number\n  pickupPlanAt?: Date\n  returnPlanAt?: Date\n  rentalDuration?: number\n  isReadyToDeliver?: boolean\n  collateralType?: string\n  collateralDetails?: string\n  notes?: string\n  pickupNotes?: string\n  outletId: number\n  customerId?: number\n  createdById: number\n}): Promise<OrderWithRelations> {\n  const order = await prisma.order.create({\n    data: {\n      orderNumber: data.orderNumber,\n      orderType: data.orderType as any, // ‚úÖ Type safe with Prisma enum\n      status: (data.status ?? ORDER_STATUS.RESERVED) as any, // ‚úÖ Type safe with Prisma enum\n      totalAmount: data.totalAmount,\n      depositAmount: data.depositAmount ?? 0,\n      securityDeposit: data.securityDeposit ?? 0,\n      damageFee: data.damageFee ?? 0,\n      lateFee: data.lateFee ?? 0,\n      discountType: data.discountType,\n      discountValue: data.discountValue ?? 0,\n      discountAmount: data.discountAmount ?? 0,\n      pickupPlanAt: data.pickupPlanAt,\n      returnPlanAt: data.returnPlanAt,\n      rentalDuration: data.rentalDuration,\n      isReadyToDeliver: data.isReadyToDeliver ?? false,\n      collateralType: data.collateralType,\n      collateralDetails: data.collateralDetails,\n      notes: data.notes,\n      pickupNotes: data.pickupNotes,\n      outletId: data.outletId,\n      customerId: data.customerId,\n      createdById: data.createdById,\n    },\n    include: orderInclude,\n  })\n\n  return transformOrder(order)\n}\n\nexport async function updateOrder(\n  id: number,\n  data: Partial<{\n    orderType: string\n    status: string\n    totalAmount: number\n    depositAmount: number\n    securityDeposit: number\n    damageFee: number\n    lateFee: number\n    discountType: string\n    discountValue: number\n    discountAmount: number\n    pickupPlanAt: Date\n    returnPlanAt: Date\n    pickedUpAt: Date\n    returnedAt: Date\n    rentalDuration: number\n    isReadyToDeliver: boolean\n    collateralType: string\n    collateralDetails: string\n    notes: string\n    pickupNotes: string\n    returnNotes: string\n    damageNotes: string\n    customerId: number\n    outletId: number\n    orderItems?: Array<{\n      productId: number\n      quantity: number\n      unitPrice: number\n      totalPrice: number\n      deposit?: number\n      notes?: string\n      rentalDays?: number\n    }>\n  }>\n): Promise<OrderWithRelations> {\n  console.log('üîß updateOrder called with id:', id);\n  console.log('üîß updateOrder data keys:', Object.keys(data));\n  console.log('üîß updateOrder has orderItems?:', !!data.orderItems, 'length:', data.orderItems?.length);\n  \n  // Extract relationship IDs and orderItems from data\n  const { \n    orderItems: inputOrderItems, \n    customerId, \n    outletId: inputOutletId,\n    ...allFields \n  } = data;\n  \n  // WHITELIST: Only valid Order model fields from schema\n  const validFields: (keyof typeof allFields)[] = [\n    'orderType', 'status', 'totalAmount', 'depositAmount', \n    'securityDeposit', 'damageFee', 'lateFee', 'discountType', \n    'discountValue', 'discountAmount', 'pickupPlanAt', 'returnPlanAt',\n    'pickedUpAt', 'returnedAt', 'rentalDuration', 'isReadyToDeliver',\n    'collateralType', 'collateralDetails', 'notes', 'pickupNotes',\n    'returnNotes', 'damageNotes'\n  ];\n  \n  // Build update data - filter to only valid fields\n  const updateData: any = {};\n  validFields.forEach(field => {\n    if (field in allFields && allFields[field as keyof typeof allFields] !== undefined) {\n      updateData[field] = allFields[field as keyof typeof allFields];\n    }\n  });\n  \n  console.log('üîß Filtered update fields:', Object.keys(updateData));\n  \n  // Handle customer relationship if provided\n  if (customerId !== undefined) {\n    if (customerId === null) {\n      updateData.customer = { disconnect: true };\n    } else {\n      updateData.customer = { connect: { id: customerId } };\n    }\n  }\n  \n  // Handle outlet relationship if provided (should not change usually)\n  if (inputOutletId !== undefined) {\n    updateData.outlet = { connect: { id: inputOutletId } };\n  }\n  \n  // Handle order items separately if provided\n  if (inputOrderItems && inputOrderItems.length > 0) {\n    console.log('üîß Processing', inputOrderItems.length, 'order items');\n    updateData.orderItems = {\n      // Delete all existing order items\n      deleteMany: {},\n      // Create new order items\n      create: inputOrderItems.map(item => ({\n        productId: item.productId,\n        quantity: item.quantity,\n        unitPrice: item.unitPrice,\n        totalPrice: item.totalPrice || (item.quantity * item.unitPrice),\n        deposit: item.deposit || 0,\n        notes: item.notes,\n        rentalDays: item.rentalDays\n      }))\n    }\n    console.log('üîß Converted orderItems to nested write format');\n  }\n  \n  console.log('üîß Final update data structure:', {\n    hasOrderItems: !!updateData.orderItems,\n    hasCustomer: !!updateData.customer,\n    hasOutlet: !!updateData.outlet\n  });\n  \n  // Get old order status before update (for stock/renting updates)\n  const oldOrder = await prisma.order.findUnique({\n    where: { id },\n    select: {\n      orderType: true,\n      status: true,\n      outletId: true,\n      orderItems: {\n        select: {\n          productId: true,\n          quantity: true,\n        },\n      },\n    },\n  });\n\n  const oldStatus = oldOrder?.status || null;\n  const newStatus = updateData.status;\n  const orderType = (updateData.orderType || oldOrder?.orderType) as 'RENT' | 'SALE' | undefined;\n  const oldOutletId = oldOrder?.outletId;\n  const oldOrderItems = oldOrder?.orderItems || [];\n  \n  // Update the order\n  const order = await prisma.order.update({\n    where: { id },\n    data: updateData,\n    include: orderInclude,\n  });\n\n  console.log('‚úÖ Order updated successfully');\n\n  // Update outlet stock if status changed and we have order items\n  if (newStatus && newStatus !== oldStatus && orderType && oldOutletId && oldOrderItems.length > 0) {\n    try {\n      // Import the function from product module\n      const productModule = await import('./product');\n      const { updateOutletStockForOrder } = productModule;\n      \n      if (!updateOutletStockForOrder) {\n        console.error('‚ùå updateOutletStockForOrder function not found in product module');\n        return transformOrder(order);\n      }\n      \n      await updateOutletStockForOrder(\n        id,\n        oldStatus,\n        newStatus,\n        orderType as 'RENT' | 'SALE',\n        oldOutletId,\n        oldOrderItems.map(item => ({\n          productId: item.productId || 0,\n          quantity: item.quantity,\n        })).filter(item => item.productId > 0)\n      );\n      console.log('‚úÖ Outlet stock updated successfully');\n    } catch (error) {\n      console.error('‚ùå Error updating outlet stock:', error);\n      // Don't throw - order update succeeded, stock update failed\n      // Log error for manual review\n    }\n  }\n\n  return transformOrder(order)\n}\n\nexport async function deleteOrder(id: number): Promise<boolean> {\n  try {\n    await prisma.order.delete({\n      where: { id },\n    })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport async function getOrderCount(outletId?: number, status?: string): Promise<number> {\n  const where: any = {}\n  if (outletId) where.outletId = outletId\n  if (status) where.status = status\n\n  return prisma.order.count({ where })\n}\n\nexport async function generateOrderNumber(outletId: number): Promise<string> {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Generate random 6-digit number (100000 to 999999)\n  const generateRandom6Digits = (): string => {\n    return Math.floor(100000 + Math.random() * 900000).toString();\n  };\n\n  const maxRetries = 10;\n  for (let i = 0; i < maxRetries; i++) {\n    const orderNumber = generateRandom6Digits();\n    \n    // Check if order number already exists\n    const existingOrder = await prisma.order.findUnique({\n      where: { orderNumber }\n    });\n\n    if (!existingOrder) {\n      return orderNumber;\n    }\n  }\n\n  throw new Error('Failed to generate unique 6-digit random order number after maximum retries');\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\n// ============================================================================\n// LEGACY ORDER SEARCH (for backward compatibility)\n// ============================================================================\n\n/**\n * Search orders with filters (legacy function)\n * @deprecated Use simplifiedOrders.search instead\n */\nexport async function searchOrders(filters: OrderSearchFilter): Promise<OrderSearchResponse> {\n  \n  const {\n    q,\n    outletId,\n    customerId,\n    userId,\n    orderType,\n    status,\n    startDate,\n    endDate,\n    pickupDate,\n    returnDate,\n    limit = 20,\n    offset = 0\n  } = filters;\n\n  const where: any = {};\n\n  // Text search (diacritics-insensitive for customer names)\n  if (q) {\n    const searchTerm = q.trim();\n    const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n    \n    const searchConditions: any[] = [\n      { orderNumber: { contains: searchTerm, mode: 'insensitive' } },\n      { customer: { firstName: { contains: searchTerm, mode: 'insensitive' } } },\n      { customer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },\n      { customer: { phone: { contains: searchTerm, mode: 'insensitive' } } },\n    ];\n    \n    // Add normalized search for customer names if different from original\n    if (normalizedTerm !== searchTerm) {\n      searchConditions.push(\n        { customer: { firstName: { contains: normalizedTerm, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: normalizedTerm, mode: 'insensitive' } } }\n      );\n    }\n    \n    where.OR = searchConditions;\n  }\n\n  // Filter by outlet\n  if (outletId) {\n    where.outletId = outletId;\n  }\n\n  // Filter by customer\n  if (customerId) {\n    where.customerId = customerId;\n  }\n\n  // Filter by user (created by)\n  if (userId) {\n    where.createdById = userId;  \n  }\n\n  // Filter by order type\n  if (orderType) {\n    where.orderType = orderType;\n  }\n\n  // Filter by status\n  if (status) {\n    where.status = status;\n  }\n\n  // Date filters\n  if (startDate || endDate) {\n    where.createdAt = {};\n    if (startDate) {\n      where.createdAt.gte = new Date(startDate);\n    }\n    if (endDate) {\n      where.createdAt.lte = new Date(endDate);\n    }\n  }\n\n  // Pickup date filter\n  if (pickupDate) {\n    where.pickupPlanAt = {\n      gte: new Date(pickupDate),\n      lt: new Date(new Date(pickupDate).getTime() + 24 * 60 * 60 * 1000)\n    };\n  }\n\n  // Return date filter\n  if (returnDate) {\n    where.returnPlanAt = {\n      gte: new Date(returnDate), \n      lt: new Date(new Date(returnDate).getTime() + 24 * 60 * 60 * 1000)\n    };\n  }\n\n  const [orders, total] = await Promise.all([\n    prisma.order.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset,\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        createdAt: true,\n        updatedAt: true,\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n          }\n        }\n      }\n    }),\n    prisma.order.count({ where })\n  ]);\n\n  const totalPages = Math.ceil(total / limit);\n  const page = Math.floor(offset / limit) + 1;\n\n  const transformedOrders: OrderSearchResult[] = orders.map((order: any) => ({\n    id: order.id,\n    orderNumber: order.orderNumber,\n    orderType: order.orderType as any,\n    status: order.status as any,\n    totalAmount: order.totalAmount,\n    depositAmount: order.depositAmount,\n    pickupPlanAt: order.pickupPlanAt,\n    returnPlanAt: order.returnPlanAt,\n    pickedUpAt: order.pickedUpAt,\n    returnedAt: order.returnedAt,\n    isReadyToDeliver: false,\n    customer: order.customer ? {\n      id: order.customer.id,\n      firstName: order.customer.firstName,\n      lastName: order.customer.lastName,\n      email: order.customer.email,\n      phone: order.customer.phone || '',\n    } : null,\n    outlet: {\n      id: order.outlet?.id || 0,\n      name: order.outlet?.name || '',\n    },\n    orderItems: [],\n    createdAt: order.createdAt,\n    updatedAt: order.updatedAt,\n  }));\n\n  return {\n    success: true,\n    data: {\n      orders: transformedOrders,\n      total,\n      page,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n      totalPages\n    }\n  };\n}\n\nexport const simplifiedOrders = {\n  /**\n   * Find order by ID (simplified API) - OPTIMIZED for performance\n   */\n  findById: async (id: number) => {\n    return await prisma.order.findUnique({\n      where: { id },\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { select: { id: true, name: true } },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            productId: true,\n            notes: true,\n            rentalDays: true,\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Find order by order number (simplified API)\n   */\n  findByNumber: async (orderNumber: string) => {\n    return await prisma.order.findUnique({\n      where: { orderNumber },\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { \n          select: { \n            id: true, \n            name: true,\n            merchantId: true,\n            merchant: { select: { id: true, name: true } }\n          } \n        },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            productId: true,\n            notes: true,\n            rentalDays: true,\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Create new order (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.order.create({\n      data,\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { select: { id: true, name: true } },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            productId: true,\n            notes: true,\n            rentalDays: true,\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Update order (simplified API) - Now uses proper updateOrder function\n   */\n  update: async (id: number, data: any) => {\n    return await updateOrder(id, data);\n  },\n\n  /**\n   * Delete order (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.order.delete({\n      where: { id }\n    });\n  },\n\n  /**\n   * Search orders with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      where: whereClause, \n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause - start with provided where clause if any\n    const where: any = whereClause || {};\n    \n    // Handle merchant-level filtering (orders belong to outlets, outlets belong to merchants)\n    if (whereFilters.merchantId) {\n      where.outlet = {\n        merchantId: whereFilters.merchantId\n      };\n    }\n    \n    // Handle outlet-level filtering (overrides merchant filter if both are present)                                                                            \n    if (whereFilters.outletId) {\n      // Support both simple values and complex objects like { in: [...] }\n      where.outletId = whereFilters.outletId;\n    }\n    \n    if (whereFilters.customerId) where.customerId = whereFilters.customerId;\n    if (whereFilters.status) where.status = whereFilters.status;\n    if (whereFilters.orderType) where.orderType = whereFilters.orderType;\n    \n    // Filter by product (through order items)\n    if (whereFilters.productId) {\n      where.orderItems = {\n        some: {\n          productId: whereFilters.productId\n        }\n      };\n    }\n    \n    // Date range\n    if (whereFilters.startDate || whereFilters.endDate) {\n      where.createdAt = {};\n      if (whereFilters.startDate) where.createdAt.gte = whereFilters.startDate;\n      if (whereFilters.endDate) where.createdAt.lte = whereFilters.endDate;\n    }\n\n    // Text search (case-insensitive and diacritics-insensitive for customer names)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      const searchConditions: any[] = [\n        { orderNumber: { contains: searchTerm, mode: 'insensitive' } },\n        { customer: { firstName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { phone: { contains: searchTerm, mode: 'insensitive' } } }\n      ];\n      \n      // Add normalized search for customer names if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { customer: { firstName: { contains: normalizedTerm, mode: 'insensitive' } } },\n          { customer: { lastName: { contains: normalizedTerm, mode: 'insensitive' } } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    // ‚úÖ Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'orderNumber') {\n      orderBy.orderNumber = sortOrder;\n    } else if (sortBy === 'totalAmount') {\n      orderBy.totalAmount = sortOrder;\n    } else if (sortBy === 'customer') {\n      orderBy.customer = { firstName: sortOrder };\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [orders, total] = await Promise.all([\n      // OPTIMIZED: Use select instead of include for better performance\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          pickupPlanAt: true,\n          returnPlanAt: true,\n          pickedUpAt: true,\n          returnedAt: true,\n          createdAt: true,\n          updatedAt: true,\n          customer: { \n            select: { \n              id: true, \n              firstName: true, \n              lastName: true, \n              phone: true, \n              email: true \n            } \n          },\n          outlet: { \n            select: { \n              id: true, \n              name: true,\n              merchant: { select: { id: true, name: true } }\n            } \n          },\n          createdBy: { \n            select: { \n              id: true, \n              firstName: true, \n              lastName: true \n            } \n          },\n          // OPTIMIZED: Count instead of loading all items\n          _count: {\n            select: {\n              orderItems: true,\n              payments: true\n            }\n          }\n        },\n        orderBy, // ‚úÖ Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    console.log(`üìä db.orders.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, orders=${orders.length}`);\n\n    return {\n      data: orders,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Find first order matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.order.findFirst({\n      where,\n      include: {\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true\n          }\n        },\n        orderItems: {\n          include: {\n            product: {\n              select: {\n                id: true,\n                name: true,\n                barcode: true\n              }\n            }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get order statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.order.count({ where });\n  },\n\n  /**\n   * Group orders by field (simplified API)\n   */\n  groupBy: async (args: any) => {\n    return await prisma.order.groupBy(args);\n  },\n\n  /**\n   * Aggregate orders (simplified API)\n   */\n  aggregate: async (args: any) => {\n    return await prisma.order.aggregate(args);\n  },\n\n  // ============================================================================\n  // PERFORMANCE OPTIMIZED METHODS FOR LARGE DATASETS\n  // ============================================================================\n\n  /**\n   * Get orders list with minimal data for performance (for large datasets)\n   * Only essential fields for list view - no nested objects\n   */\n  /**\n   * Search orders with orderItems included (for calendar API)\n   */\n  searchWithItems: async (filters: {\n    merchantId?: number;\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    productId?: number;\n    startDate?: Date;\n    endDate?: Date;\n    search?: string;\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n    where?: any;\n  } = {}) => {\n    const {\n      merchantId,\n      outletId,\n      status,\n      orderType,\n      productId,\n      startDate,\n      endDate,\n      search,\n      page = 1,\n      limit = 1000,\n      sortBy = 'createdAt',\n      sortOrder = 'desc',\n      where: whereClause\n    } = filters;\n\n    // Build where clause\n    const where: any = whereClause || {};\n    \n    console.log('üîç searchWithItems - Original whereClause:', JSON.stringify(whereClause, null, 2));\n\n    // Handle merchant-level filtering from whereClause first\n    if (where.merchantId) {\n      console.log('üîç Found merchantId in whereClause, converting to outlet.merchantId');\n      where.outlet = {\n        merchantId: where.merchantId\n      };\n      delete where.merchantId; // Remove direct merchantId\n      console.log('üîç After conversion:', JSON.stringify(where, null, 2));\n    }\n\n    // Handle merchant-level filtering from parameters\n    if (merchantId) {\n      where.outlet = {\n        merchantId: merchantId\n      };\n    }\n\n    // Handle outlet-level filtering (overrides merchant filter if both are present)\n    if (outletId) {\n      where.outletId = outletId;\n      // Remove outlet filter if outletId is specified\n      delete where.outlet;\n    }\n\n    if (status) where.status = status;\n    if (orderType) where.orderType = orderType;\n\n    // Filter by product (through order items)\n    if (productId) {\n      where.orderItems = {\n        some: {\n          productId: productId\n        }\n      };\n    }\n\n    // Date range\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    // Text search\n    if (search) {\n      where.OR = [\n        { orderNumber: { contains: search } },\n        { customer: { firstName: { contains: search } } },\n        { customer: { lastName: { contains: search } } },\n        { customer: { phone: { contains: search } } }\n      ];\n    }\n\n    const [orders, total] = await Promise.all([\n      prisma.order.findMany({\n        where,\n        include: {\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              email: true,\n            }\n          },\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n              merchantId: true\n            }\n          },\n          orderItems: {\n            include: {\n              product: {\n                select: {\n                  id: true,\n                  name: true,\n                  barcode: true,\n                  images: true,\n                  rentPrice: true,\n                  deposit: true\n                }\n              }\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip: (page - 1) * limit,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    return {\n      data: orders,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  findManyMinimal: async (filters: {\n    merchantId?: number;\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    startDate?: Date;\n    endDate?: Date;\n    search?: string;\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  } = {}) => {\n    const {\n      merchantId,\n      outletId,\n      status,\n      orderType,\n      startDate,\n      endDate,\n      search,\n      page = 1,\n      limit = 20,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = filters;\n\n    // Build where clause\n    const where: any = {};\n    if (merchantId) where.merchantId = merchantId;\n    if (outletId) where.outletId = outletId;\n    if (status) where.status = status;\n    if (orderType) where.orderType = orderType;\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n    if (search) {\n      const searchTerm = search.trim();\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      const searchConditions: any[] = [\n        { orderNumber: { contains: searchTerm, mode: 'insensitive' } },\n        { customer: { firstName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { phone: { contains: searchTerm, mode: 'insensitive' } } }\n      ];\n      \n      // Add normalized search for customer names if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { customer: { firstName: { contains: normalizedTerm, mode: 'insensitive' } } },\n          { customer: { lastName: { contains: normalizedTerm, mode: 'insensitive' } } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    const [orders, total] = await Promise.all([\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          notes: true,\n          createdAt: true,\n          updatedAt: true,\n          outletId: true,\n          customerId: true,\n          createdById: true,\n          // Minimal customer data\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              email: true\n            }\n          },\n          // Minimal outlet data\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n              address: true,\n              merchant: {\n                select: {\n                  id: true,\n                  name: true\n                }\n              }\n            }\n          },\n          // Minimal createdBy data\n          createdBy: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              email: true\n            }\n          }\n        },\n        orderBy: { [sortBy]: sortOrder },\n        skip: (page - 1) * limit,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    // Get item counts for each order\n    const orderIds = orders.map(order => order.id);\n    const itemCounts = await prisma.orderItem.groupBy({\n      by: ['orderId'],\n      where: { orderId: { in: orderIds } },\n      _count: { id: true }\n    });\n    const itemCountMap = new Map(itemCounts.map(item => [item.orderId, item._count.id]));\n\n    // Get payment counts and totals\n    const paymentCounts = await prisma.payment.groupBy({\n      by: ['orderId'],\n      where: { orderId: { in: orderIds } },\n      _count: { id: true },\n      _sum: { amount: true }\n    });\n    const paymentCountMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._count.id]));\n    const totalPaidMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._sum.amount || 0]));\n\n    // Enhance orders with calculated fields and flattened structure\n    const enhancedOrders = orders.map(order => ({\n      id: order.id,\n      orderNumber: order.orderNumber,\n      orderType: order.orderType,\n      status: order.status,\n      totalAmount: order.totalAmount,\n      depositAmount: order.depositAmount,\n      notes: order.notes,\n      createdAt: order.createdAt,\n      updatedAt: order.updatedAt,\n      \n      // Flatten customer data\n      customerId: order.customerId,\n      customerName: order.customer ? `${order.customer.firstName} ${order.customer.lastName}` : null,\n      customerPhone: order.customer?.phone || null,\n      customerEmail: order.customer?.email || null,\n      \n      // Flatten outlet data\n      outletId: order.outletId,\n      outletName: order.outlet?.name || null,\n      outletAddress: order.outlet?.address || null,\n      merchantId: order.outlet?.merchant?.id || null,\n      merchantName: order.outlet?.merchant?.name || null,\n      \n      // Flatten createdBy data\n      createdById: order.createdById,\n      createdByName: order.createdBy ? `${order.createdBy.firstName} ${order.createdBy.lastName}` : null,\n      createdByEmail: order.createdBy?.email || null,\n      \n      // Calculated fields\n      itemCount: itemCountMap.get(order.id) || 0,\n      paymentCount: paymentCountMap.get(order.id) || 0,\n      totalPaid: totalPaidMap.get(order.id) || 0\n    }));\n\n    return {\n      data: enhancedOrders,\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit)\n      }\n    };\n  },\n\n  /**\n   * Get orders list with complete order information for performance (for large datasets)\n   * Includes all order fields, customer, outlet, createdBy, and products\n   */\n  findManyLightweight: async (filters: {\n    merchantId?: number;\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    productId?: number;\n    startDate?: Date;\n    endDate?: Date;\n    search?: string;\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  }) => {\n    const {\n      merchantId,\n      outletId,\n      status,\n      orderType,\n      productId,\n      startDate,\n      endDate,\n      search,\n      page = 1,\n      limit = 20,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = filters;\n\n    const where: any = {};\n    \n    if (merchantId) {\n      where.outlet = { merchantId };\n    }\n    if (outletId) {\n      where.outletId = outletId;\n    }\n    if (status) {\n      where.status = status;\n    }\n    if (orderType) {\n      where.orderType = orderType;\n    }\n    \n    // Filter by product (through order items)\n    if (productId) {\n      where.orderItems = {\n        some: {\n          productId: productId\n        }\n      };\n    }\n    \n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    // Search functionality: search in order number, customer name, and customer phone (diacritics-insensitive)\n    if (search) {\n      const searchTerm = search.trim();\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      const searchConditions: any[] = [\n        { orderNumber: { contains: searchTerm, mode: 'insensitive' } },\n        { customer: { firstName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { phone: { contains: searchTerm, mode: 'insensitive' } } }\n      ];\n      \n      // Add normalized search for customer names if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { customer: { firstName: { contains: normalizedTerm, mode: 'insensitive' } } },\n          { customer: { lastName: { contains: normalizedTerm, mode: 'insensitive' } } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    const [orders, total] = await Promise.all([\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          securityDeposit: true,\n          damageFee: true,\n          lateFee: true,\n          discountType: true,\n          discountValue: true,\n          discountAmount: true,\n          pickupPlanAt: true,\n          returnPlanAt: true,\n          pickedUpAt: true,\n          returnedAt: true,\n          rentalDuration: true,\n          isReadyToDeliver: true,\n          collateralType: true,\n          collateralDetails: true,\n          notes: true,\n          pickupNotes: true,\n          returnNotes: true,\n          damageNotes: true,\n          createdAt: true,\n          updatedAt: true,\n          outletId: true,\n          customerId: true,\n          createdById: true,\n          // Customer data\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              email: true,\n              address: true,\n              city: true,\n              state: true,\n              zipCode: true,\n              country: true\n            }\n          },\n          // Outlet data\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n              address: true,\n              phone: true,\n              city: true,\n              state: true,\n              zipCode: true,\n              country: true,\n              merchant: {\n                select: {\n                  id: true,\n                  name: true\n                }\n              }\n            }\n          },\n          // CreatedBy data\n          createdBy: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              email: true\n            }\n          },\n          // Include products for list view\n          orderItems: {\n            select: {\n              id: true,\n              quantity: true,\n              unitPrice: true,\n              totalPrice: true,\n              notes: true,\n              product: {\n                select: {\n                  id: true,\n                  name: true,\n                  barcode: true,\n                  images: true,\n                  rentPrice: true,\n                  deposit: true\n                }\n              }\n            }\n          }\n        },\n        orderBy: { [sortBy]: sortOrder },\n        skip: (page - 1) * limit,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    // Get summary counts for order items and payments (separate queries for performance)\n    const orderIds = orders.map(o => o.id);\n    const [itemCounts, paymentCounts] = await Promise.all([\n      prisma.orderItem.groupBy({\n        by: ['orderId'],\n        where: { orderId: { in: orderIds } },\n        _count: { id: true }\n      }),\n      prisma.payment.groupBy({\n        by: ['orderId'],\n        where: { \n          orderId: { in: orderIds },\n          status: 'COMPLETED'\n        },\n        _sum: { amount: true },\n        _count: { id: true }\n      })\n    ]);\n\n    // Create lookup maps for performance\n    const itemCountMap = new Map(itemCounts.map(item => [item.orderId, item._count.id]));\n    const paymentCountMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._count.id]));\n    const totalPaidMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._sum.amount || 0]));\n\n    // Enhance orders with calculated fields and flattened structure\n    const enhancedOrders = orders.map(order => ({\n      id: order.id,\n      orderNumber: order.orderNumber,\n      orderType: order.orderType,\n      status: order.status,\n      totalAmount: order.totalAmount,\n      depositAmount: order.depositAmount,\n      securityDeposit: order.securityDeposit,\n      damageFee: order.damageFee,\n      lateFee: order.lateFee,\n      discountType: order.discountType,\n      discountValue: order.discountValue,\n      discountAmount: order.discountAmount,\n      pickupPlanAt: order.pickupPlanAt,\n      returnPlanAt: order.returnPlanAt,\n      pickedUpAt: order.pickedUpAt,\n      returnedAt: order.returnedAt,\n      rentalDuration: order.rentalDuration,\n      isReadyToDeliver: order.isReadyToDeliver,\n      collateralType: order.collateralType,\n      collateralDetails: order.collateralDetails,\n      notes: order.notes,\n      pickupNotes: order.pickupNotes,\n      returnNotes: order.returnNotes,\n      damageNotes: order.damageNotes,\n      createdAt: order.createdAt,\n      updatedAt: order.updatedAt,\n      \n      // Flatten customer data (simplified)\n      customerId: order.customerId,\n      customerName: order.customer ? `${order.customer.firstName} ${order.customer.lastName}` : null,\n      customerPhone: order.customer?.phone || null,\n      \n      // Flatten outlet data (simplified)\n      outletId: order.outletId,\n      outletName: order.outlet?.name || null,\n      merchantName: order.outlet?.merchant?.name || null,\n      \n      // Flatten createdBy data\n      createdById: order.createdById,\n      createdByName: order.createdBy ? `${order.createdBy.firstName} ${order.createdBy.lastName}` : null,\n      \n      // Order items with flattened product data\n      orderItems: order.orderItems?.map(item => ({\n        id: item.id,\n        quantity: item.quantity,\n        unitPrice: item.unitPrice,\n        totalPrice: item.totalPrice,\n        notes: item.notes,\n        // Flatten product data\n        productId: item.product?.id,\n        productName: item.product?.name,\n        productBarcode: item.product?.barcode,\n        productImages: item.product?.images ? \n          (Array.isArray(item.product.images) ? item.product.images : []) : [],\n        productRentPrice: item.product?.rentPrice,\n        productDeposit: item.product?.deposit\n      })) || [],\n      \n      // Calculated fields\n      itemCount: itemCountMap.get(order.id) || 0,\n      paymentCount: paymentCountMap.get(order.id) || 0,\n      totalPaid: totalPaidMap.get(order.id) || 0\n    }));\n\n    return {\n      data: enhancedOrders,\n      total,\n      page,\n      limit,\n      hasMore: page * limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Get order by ID with full detail data\n   * Includes all order fields, customer, outlet, products, payments, and timeline\n   */\n  findByIdDetail: async (id: number) => {\n    const order = await prisma.order.findUnique({\n      where: { id },\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        securityDeposit: true,\n        damageFee: true,\n        lateFee: true,\n        discountType: true,\n        discountValue: true,\n        discountAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        rentalDuration: true,\n        isReadyToDeliver: true,\n        collateralType: true,\n        collateralDetails: true,\n        notes: true,\n        pickupNotes: true,\n        returnNotes: true,\n        damageNotes: true,\n        createdAt: true,\n        updatedAt: true,\n        outletId: true,\n        customerId: true,\n        createdById: true,\n        \n        // Full customer data\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n            address: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            dateOfBirth: true,\n            notes: true,\n            createdAt: true,\n            updatedAt: true\n          }\n        },\n        \n        // Full outlet data\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n            address: true,\n            phone: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            isActive: true,\n            merchant: {\n              select: {\n                id: true,\n                name: true,\n                email: true,\n                phone: true,\n                address: true,\n                city: true,\n                state: true,\n                zipCode: true,\n                country: true,\n                businessType: true,\n                pricingType: true,\n                taxId: true,\n                currency: true\n              }\n            }\n          }\n        },\n        \n        // Full createdBy data\n        createdBy: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n            phone: true,\n            role: true,\n            isActive: true,\n            createdAt: true\n          }\n        },\n        \n        // Full order items with products\n        orderItems: {\n          select: {\n            id: true,\n            orderId: true,\n            productId: true,\n            productName: true,\n            productBarcode: true,\n            productImages: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            notes: true,\n            rentalDays: true,\n            product: {\n              select: {\n                id: true,\n                name: true,\n                barcode: true,\n                images: true,\n                rentPrice: true,\n                deposit: true,\n                description: true,\n                isActive: true,\n                category: {\n                  select: {\n                    id: true,\n                    name: true,\n                    description: true\n                  }\n                }\n              }\n            }\n          }\n        },\n        \n        // Full payments data\n        payments: {\n          select: {\n            id: true,\n            amount: true,\n            method: true,\n            status: true,\n            reference: true,\n            notes: true,\n            processedAt: true,\n            createdAt: true,\n            updatedAt: true\n          },\n          orderBy: { createdAt: 'desc' }\n        }\n      }\n    });\n\n    if (!order) return null;\n\n    // Get order timeline/audit log (if exists)\n    let timeline: any[] = [];\n    try {\n      timeline = await (prisma as any).orderAuditLog?.findMany({\n        where: { orderId: id },\n        select: {\n          id: true,\n          action: true,\n          description: true,\n          oldValues: true,\n          newValues: true,\n          createdAt: true,\n          createdBy: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              email: true\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' }\n      }) || [];\n    } catch (error) {\n      // OrderAuditLog table might not exist\n      console.log('OrderAuditLog table not found, skipping timeline');\n    }\n\n    // Calculate additional fields\n    const itemCount = (order as any).orderItems?.length || 0;\n    const paymentCount = (order as any).payments?.length || 0;\n    const totalPaid = (order as any).payments\n      ?.filter((p: any) => p.status === PAYMENT_STATUS.COMPLETED)\n      .reduce((sum: number, p: any) => sum + p.amount, 0) || 0;\n\n    return {\n      ...order,\n      // Calculated fields\n      itemCount,\n      paymentCount,\n      totalPaid,\n      // Timeline\n      timeline\n    };\n  },\n\n  /**\n   * Get order detail with optimized loading\n   * Loads related data only when needed\n   */\n  findByIdOptimized: async (id: number, options: {\n    includeItems?: boolean;\n    includePayments?: boolean;\n    includeCustomer?: boolean;\n    includeOutlet?: boolean;\n  } = {}) => {\n    const {\n      includeItems = true,\n      includePayments = true,\n      includeCustomer = true,\n      includeOutlet = true\n    } = options;\n\n    const select: any = {\n      id: true,\n      orderNumber: true,\n      orderType: true,\n      status: true,\n      totalAmount: true,\n      depositAmount: true,\n      securityDeposit: true,\n      damageFee: true,\n      lateFee: true,\n      discountType: true,\n      discountValue: true,\n      discountAmount: true,\n      pickupPlanAt: true,\n      returnPlanAt: true,\n      pickedUpAt: true,\n      returnedAt: true,\n      rentalDuration: true,\n      isReadyToDeliver: true,\n      collateralType: true,\n      collateralDetails: true,\n      notes: true,\n      pickupNotes: true,\n      returnNotes: true,\n      damageNotes: true,\n      createdAt: true,\n      updatedAt: true,\n      outletId: true,\n      customerId: true,\n      createdById: true\n    };\n\n    // Conditionally include relations based on options\n    if (includeCustomer) {\n      select.customer = {\n        select: {\n          id: true,\n          firstName: true,\n          lastName: true,\n          phone: true,\n          email: true,\n          address: true,\n          city: true,\n          state: true,\n          zipCode: true,\n          country: true,\n          dateOfBirth: true,\n          idNumber: true,\n          idType: true\n        }\n      };\n    }\n\n    if (includeOutlet) {\n      select.outlet = {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          phone: true,\n          city: true,\n          state: true,\n          zipCode: true,\n          country: true,\n          merchant: {\n            select: {\n              id: true,\n              name: true\n            }\n          }\n        }\n      };\n    }\n\n    select.createdBy = {\n      select: {\n        id: true,\n        firstName: true,\n        lastName: true,\n        email: true\n      }\n    };\n\n    if (includeItems) {\n      select.orderItems = {\n        select: {\n          id: true,\n          quantity: true,\n          unitPrice: true,\n          totalPrice: true,\n          deposit: true,\n          productId: true,\n          notes: true,\n          rentalDays: true,\n          product: {\n            select: {\n              id: true,\n              name: true,\n              barcode: true,\n              description: true,\n              images: true,\n              category: {\n                select: {\n                  id: true,\n                  name: true\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n\n    if (includePayments) {\n      select.payments = {\n        select: {\n          id: true,\n          amount: true,\n          currency: true,\n          method: true,\n          type: true,\n          status: true,\n          reference: true,\n          transactionId: true,\n          invoiceNumber: true,\n          description: true,\n          notes: true,\n          failureReason: true,\n          processedAt: true,\n          processedBy: true,\n          createdAt: true\n        }\n      };\n    }\n\n    return await prisma.order.findUnique({\n      where: { id },\n      select\n    });\n  },\n\n  /**\n   * Search orders with cursor-based pagination for large datasets\n   * More efficient than offset-based pagination for large datasets\n   * Includes complete order information and products\n   */\n  searchWithCursor: async (filters: {\n    merchantId?: number;\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    startDate?: Date;\n    endDate?: Date;\n    cursor?: string;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  }) => {\n    const {\n      merchantId,\n      outletId,\n      status,\n      orderType,\n      startDate,\n      endDate,\n      cursor,\n      limit = 20,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = filters;\n\n    const where: any = {};\n    \n    if (merchantId) {\n      where.outlet = { merchantId };\n    }\n    if (outletId) {\n      where.outletId = outletId;\n    }\n    if (status) {\n      where.status = status;\n    }\n    if (orderType) {\n      where.orderType = orderType;\n    }\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    // Add cursor condition for pagination\n    if (cursor) {\n      const cursorCondition = sortOrder === 'desc' \n        ? { [sortBy]: { lt: new Date(cursor) } }\n        : { [sortBy]: { gt: new Date(cursor) } };\n      where.AND = [cursorCondition];\n    }\n\n    const orders = await prisma.order.findMany({\n      where,\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        securityDeposit: true,\n        damageFee: true,\n        lateFee: true,\n        discountType: true,\n        discountValue: true,\n        discountAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        rentalDuration: true,\n        isReadyToDeliver: true,\n        collateralType: true,\n        collateralDetails: true,\n        notes: true,\n        pickupNotes: true,\n        returnNotes: true,\n        damageNotes: true,\n        createdAt: true,\n        updatedAt: true,\n        outletId: true,\n        customerId: true,\n        createdById: true,\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n            address: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n            address: true,\n            phone: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            merchant: {\n              select: {\n                id: true,\n                name: true\n              }\n            }\n          }\n        },\n        createdBy: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        },\n        // Include products for list view\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            notes: true,\n            product: {\n              select: {\n                id: true,\n                name: true,\n                barcode: true,\n                images: true,\n                rentPrice: true,\n                deposit: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: { [sortBy]: sortOrder },\n      take: limit + 1 // Take one extra to check if there are more\n    });\n\n    const hasMore = orders.length > limit;\n    if (hasMore) {\n      orders.pop(); // Remove the extra item\n    }\n\n    const nextCursor = hasMore && orders.length > 0 \n      ? orders[orders.length - 1][sortBy as keyof typeof orders[0]]?.toString()\n      : null;\n\n    return {\n      data: orders,\n      hasMore,\n      nextCursor\n    };\n  },\n\n  /**\n   * Get order statistics for dashboard (optimized aggregation)\n   */\n  getStatistics: async (filters: {\n    merchantId?: number;\n    outletId?: number;\n    startDate?: Date;\n    endDate?: Date;\n  }) => {\n    const { merchantId, outletId, startDate, endDate } = filters;\n\n    const where: any = {};\n    \n    if (merchantId) {\n      where.outlet = { merchantId };\n    }\n    if (outletId) {\n      where.outletId = outletId;\n    }\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    const [\n      totalOrders,\n      totalRevenue,\n      statusBreakdown,\n      typeBreakdown,\n      recentOrders\n    ] = await Promise.all([\n      // Total orders count\n      prisma.order.count({ where }),\n      \n      // Total revenue\n      prisma.order.aggregate({\n        where,\n        _sum: { totalAmount: true }\n      }),\n      \n      // Status breakdown\n      prisma.order.groupBy({\n        by: ['status'],\n        where,\n        _count: { id: true }\n      }),\n      \n      // Type breakdown\n      prisma.order.groupBy({\n        by: ['orderType'],\n        where,\n        _count: { id: true }\n      }),\n      \n      // Recent orders (last 10)\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          createdAt: true,\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        take: 10\n      })\n    ]);\n\n    return {\n      totalOrders,\n      totalRevenue: totalRevenue._sum.totalAmount || 0,\n      statusBreakdown: statusBreakdown.reduce((acc, item) => {\n        acc[item.status] = item._count.id;\n        return acc;\n      }, {} as Record<string, number>),\n      typeBreakdown: typeBreakdown.reduce((acc, item) => {\n        acc[item.orderType] = item._count.id;\n        return acc;\n      }, {} as Record<string, number>),\n      recentOrders\n    };\n  }\n};","import { prisma } from './client';\nimport type { Prisma } from '@prisma/client';\n\n/**\n * Create payment\n */\nexport async function createPayment(data: any) {\n  return await prisma.payment.create({\n    data,\n    include: {\n      order: {\n        include: {\n          customer: { select: { firstName: true, lastName: true } },\n          outlet: { select: { name: true } }\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find payment by ID\n */\nexport async function findById(id: number) {\n  return await prisma.payment.findUnique({\n    where: { id },\n    include: {\n      order: {\n        include: {\n          customer: { select: { firstName: true, lastName: true } },\n          outlet: { select: { name: true } }\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find payments by subscription ID\n */\nexport async function findBySubscriptionId(subscriptionId: number, options: { limit?: number } = {}) {\n  const { limit = 20 } = options;\n  \n  return await prisma.payment.findMany({\n    where: { subscriptionId },\n    orderBy: { createdAt: 'desc' },\n    take: limit\n  });\n}\n\n/**\n * Search payments with pagination\n */\nexport async function searchPayments(filters: any) {\n  const { where, include, orderBy, limit = 20, page = 1 } = filters;\n  const skip = (page - 1) * limit;\n  \n  const [payments, total] = await Promise.all([\n    prisma.payment.findMany({\n      where,\n      include,\n      orderBy,\n      take: limit,\n      skip\n    }),\n    prisma.payment.count({ where })\n  ]);\n\n  const totalPages = Math.ceil(total / limit);\n\n  return {\n    data: payments,\n    total,\n    page,\n    limit,\n    totalPages,\n    hasMore: page < totalPages\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED PAYMENTS API\n// ============================================================================\n\nexport const simplifiedPayments = {\n  /**\n   * Create payment (simplified API)\n   */\n  create: createPayment,\n\n  /**\n   * Find payment by ID (simplified API)\n   */\n  findById,\n\n  /**\n   * Find payments by subscription ID (simplified API)\n   */\n  findBySubscriptionId,\n\n  /**\n   * Search payments (simplified API)\n   */\n  search: searchPayments,\n\n  /**\n   * Find first payment matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.payment.findFirst({\n      where,\n      include: {\n        order: {\n          select: {\n            id: true,\n            orderNumber: true,\n            totalAmount: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get payment statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.payment.count({ where });\n  },\n\n  /**\n   * Group payments by field (simplified API)\n   */\n  groupBy: async (args: any) => {\n    return await prisma.payment.groupBy(args);\n  },\n\n  /**\n   * Aggregate payments (simplified API)\n   */\n  aggregate: async (args: any) => {\n    return await prisma.payment.aggregate(args);\n  }\n};\n","// ============================================================================\n// OUTLET DATABASE FUNCTIONS\n// ============================================================================\n// This file contains outlet functions that use integer ID system:\n// - Input: id (number)\n// - Database: queries by id (integer), uses integer IDs for relationships\n// - Return: includes id (number)\n\nimport { prisma } from './client';\nimport type { \n  OutletCreateInput, \n  OutletUpdateInput, \n  OutletSearchFilter,\n  OutletSearchResponse \n} from '@rentalshop/types';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\n// ============================================================================\n// OUTLET SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Get default bank account for outlet\n */\nexport async function getDefaultBankAccount(outletId: number): Promise<any | null> {\n  const bankAccount = await prisma.bankAccount.findFirst({\n    where: {\n      outletId,\n      isDefault: true,\n      isActive: true\n    },\n    select: {\n      id: true,\n      accountHolderName: true,\n      accountNumber: true,\n      bankName: true,\n      bankCode: true,\n      branch: true,\n      isDefault: true,\n      qrCode: true,\n      notes: true,\n      isActive: true,\n      outletId: true\n    }\n  });\n\n  if (!bankAccount) return null;\n\n  return {\n    id: bankAccount.id,\n    accountHolderName: bankAccount.accountHolderName,\n    accountNumber: bankAccount.accountNumber,\n    bankName: bankAccount.bankName,\n    bankCode: bankAccount.bankCode || undefined,\n    branch: bankAccount.branch || undefined,\n    isDefault: bankAccount.isDefault,\n    qrCode: bankAccount.qrCode || undefined,\n    notes: bankAccount.notes || undefined,\n    isActive: bankAccount.isActive,\n    outletId: bankAccount.outletId\n  };\n}\n\n/**\n * Get default outlet for merchant\n */\nexport async function getDefaultOutlet(merchantId: number): Promise<any> {\n  // First find merchant by public ID to get CUID\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const outlet = await prisma.outlet.findFirst({\n    where: {\n      merchantId: merchant.id, // Use CUID\n      isDefault: true,\n      isActive: true\n    },\n    select: {\n      id: true,\n      name: true,\n      merchantId: true\n    }\n  });\n\n  if (!outlet) {\n    throw new Error(`No default outlet found for merchant ${merchantId}`);\n  }\n\n  return outlet;\n}\n\n/**\n * Search outlets - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchOutlets(filters: OutletSearchFilter): Promise<OutletSearchResponse> {\n  const {\n    merchantId,\n    outletId, // Add outletId filter for outlet-level users\n    isActive,\n    search,\n    page = 1,\n    limit = 20\n  } = filters;\n\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {};\n\n  if (merchantId) {\n    // Find merchant by id\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: merchantId },\n      select: { id: true }\n    });\n    \n    if (merchant) {\n      where.merchantId = merchant.id;\n    }\n  }\n\n  // Outlet-level filtering: Users can only see their assigned outlet\n  if (outletId) {\n    // Find outlet by id\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: outletId },\n      select: { id: true }\n    });\n    \n    if (outlet) {\n      where.id = outlet.id;\n    }\n  }\n\n  // Only filter by isActive if explicitly provided\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  }\n\n  if (search) {\n    const searchTerm = search.trim();\n    // Normalize Vietnamese text to support search without diacritics\n    const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n    \n    // Search with both original and normalized terms to support diacritics-insensitive search\n    const searchConditions: any[] = [\n      { name: { contains: searchTerm, mode: 'insensitive' } },\n      { address: { contains: searchTerm, mode: 'insensitive' } },\n      { description: { contains: searchTerm, mode: 'insensitive' } }\n    ];\n    \n    // Add normalized search if different from original\n    if (normalizedTerm !== searchTerm) {\n      searchConditions.push(\n        { name: { contains: normalizedTerm, mode: 'insensitive' } },\n        { address: { contains: normalizedTerm, mode: 'insensitive' } },\n        { description: { contains: normalizedTerm, mode: 'insensitive' } }\n      );\n    }\n    \n    where.OR = searchConditions;\n  }\n\n  // Get total count\n  const total = await prisma.outlet.count({ where });\n\n  // Get outlets with pagination\n  const outlets = await prisma.outlet.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    },\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: skip\n  });\n\n  // Transform to match expected types\n  const transformedOutlets = outlets.map((outlet: any) => ({\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    isDefault: outlet.isDefault || false,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  }));\n\n  return {\n    outlets: transformedOutlets,\n    total,\n    page,\n    limit,\n    totalPages: Math.ceil(total / limit),\n    hasMore: skip + limit < total,\n  };\n}\n\n/**\n * Get outlets by merchant - follows dual ID system\n */\nexport async function getOutletsByMerchant(merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  const outlets = await prisma.outlet.findMany({\n    where: { merchantId: merchant.id },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  // Transform to match expected types\n  return outlets.map((outlet: any) => ({\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    isDefault: outlet.isDefault || false,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  }));\n}\n\n/**\n * Get outlet by public ID - follows dual ID system\n */\nexport async function getOutletByPublicId(id: number) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    }\n  });\n\n  if (!outlet) return null;\n\n  // Transform to match expected types\n  return {\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address,\n    phone: outlet.phone,\n    description: outlet.description,\n    isActive: outlet.isActive,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  };\n}\n\n/**\n * Create outlet - follows dual ID system\n */\nexport async function createOutlet(input: OutletCreateInput, merchantId: number) {\n  // Find merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    throw new Error(`Merchant with id ${merchantId} not found`);\n  }\n\n  // Generate unique id\n  const id = Math.floor(Math.random() * 1000000) + 100000;\n\n  const outlet = await prisma.outlet.create({\n    data: {\n      id,\n      name: input.name.trim(),\n      address: input.address?.trim(),\n      phone: input.phone?.trim(),\n      description: input.description?.trim(),\n      merchantId: merchant.id,\n      isActive: true\n    },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    }\n  });\n\n  // Transform to match expected types\n  return {\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n    merchantId: outlet.merchant.id, // Return merchant id\n    merchant: {\n      id: outlet.merchant.id,\n      name: outlet.merchant.name\n    }\n  };\n}\n\n/**\n * Update outlet - follows dual ID system\n */\nexport async function updateOutlet(id: number, input: OutletUpdateInput) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: { id: true, merchantId: true, name: true, isDefault: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${id} not found`);\n  }\n\n  // Prevent disabling default outlets\n  if (outlet.isDefault && input.isActive === false) {\n    throw new Error('Default outlet cannot be disabled');\n  }\n\n  const updatedOutlet = await prisma.outlet.update({\n    where: { id: outlet.id },\n    data: {\n      ...(input.name !== undefined && { name: input.name.trim() }),\n      ...(input.address !== undefined && { address: input.address?.trim() }),\n      ...(input.phone !== undefined && { phone: input.phone?.trim() }),\n      ...(input.city !== undefined && { city: input.city?.trim() }),\n      ...(input.state !== undefined && { state: input.state?.trim() }),\n      ...(input.zipCode !== undefined && { zipCode: input.zipCode?.trim() }),\n      ...(input.country !== undefined && { country: input.country?.trim() }),\n      ...(input.description !== undefined && { description: input.description?.trim() }),\n      ...(input.isActive !== undefined && { isActive: input.isActive })\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true\n        }\n      }\n    }\n  });\n\n  // Transform to match expected types\n  return {\n    id: updatedOutlet.id, // Return id as \"id\" to frontend\n    name: updatedOutlet.name,\n    address: updatedOutlet.address || undefined,\n    phone: updatedOutlet.phone || undefined,\n    city: (updatedOutlet as any).city || undefined,\n    state: (updatedOutlet as any).state || undefined,\n    zipCode: (updatedOutlet as any).zipCode || undefined,\n    country: (updatedOutlet as any).country || undefined,\n    description: updatedOutlet.description || undefined,\n    isActive: updatedOutlet.isActive,\n    createdAt: updatedOutlet.createdAt,\n    updatedAt: updatedOutlet.updatedAt,\n    merchantId: updatedOutlet.merchant.id, // Return merchant id\n    merchant: {\n      id: updatedOutlet.merchant.id,\n      name: updatedOutlet.merchant.name\n    }\n  };\n}\n\n/**\n * Delete outlet - follows dual ID system\n */\nexport async function deleteOutlet(id: number) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${id} not found`);\n  }\n\n  await prisma.outlet.delete({\n    where: { id: outlet.id }\n  });\n\n  return { success: true };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedOutlets = {\n  /**\n   * Find outlet by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.outlet.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        _count: {\n          select: { \n            users: true,\n            orders: true,\n            products: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new outlet (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('üîç simplifiedOutlets.create called with data:', data);\n      \n      // Validate that merchant exists if merchant connection is provided\n      if (data.merchant && data.merchant.connect && data.merchant.connect.id) {\n        const merchantId = data.merchant.connect.id;\n        const merchant = await prisma.merchant.findUnique({\n          where: { id: merchantId },\n          select: { id: true }\n        });\n        \n        if (!merchant) {\n          throw new Error(`Merchant with id ${merchantId} not found`);\n        }\n        \n        console.log('‚úÖ Merchant found:', merchant);\n      }\n      \n      const outlet = await prisma.outlet.create({\n        data,\n        include: {\n          merchant: { select: { id: true, name: true } }\n        }\n      });\n      \n      console.log('‚úÖ Outlet created successfully:', outlet);\n      return outlet;\n    } catch (error) {\n      console.error('‚ùå Error in simplifiedOutlets.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update outlet (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.outlet.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Find first outlet matching criteria (simplified API)\n   */\n  findFirst: async (where: any) => {\n    return await prisma.outlet.findFirst({\n      where,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        _count: {\n          select: { \n            users: true,\n            orders: true,\n            products: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get outlet statistics (simplified API)\n   */\n  getStats: async (options: any) => {\n    return await prisma.outlet.count(options.where);\n  },\n\n  /**\n   * Update multiple outlets (simplified API)\n   */\n  updateMany: async (where: any, data: any) => {\n    return await prisma.outlet.updateMany({\n      where,\n      data\n    });\n  },\n\n  /**\n   * Search outlets with pagination (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc', ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    console.log('üîç DB outlet.search - Received filters:', filters);\n    console.log('üîç DB outlet.search - whereFilters:', whereFilters);\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.outletId) where.id = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.status) where.status = whereFilters.status;\n    \n    // Text search across multiple fields - ONLY search by name (diacritics-insensitive)\n    const searchTerm = whereFilters.search?.trim();\n    console.log('üîç DB outlet.search - searchTerm:', searchTerm, 'length:', searchTerm?.length);\n    \n    if (searchTerm && searchTerm.length > 0) {\n      // Normalize Vietnamese text to support search without diacritics\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      // Search with both original and normalized terms\n      const nameConditions: any[] = [\n        { name: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n      \n      // Add normalized search if different from original\n      if (normalizedTerm !== searchTerm) {\n        nameConditions.push({ name: { contains: normalizedTerm, mode: 'insensitive' } });\n      }\n      \n      where.OR = nameConditions;\n      console.log('‚úÖ DB outlet.search - Added name filter (with diacritics support):', where.OR);\n    } else {\n      console.log('‚ö†Ô∏è DB outlet.search - No search term, will return all outlets for this merchant');\n    }\n    \n    console.log('üîç DB outlet.search - Final where clause:', JSON.stringify(where, null, 2));\n\n    // Specific field filters (not used in current implementation)\n    if (whereFilters.name) {\n      const normalizedName = removeVietnameseDiacritics(whereFilters.name);\n      const nameConditions: any[] = [\n        { name: { contains: whereFilters.name, mode: 'insensitive' } }\n      ];\n      if (normalizedName !== whereFilters.name) {\n        nameConditions.push({ name: { contains: normalizedName, mode: 'insensitive' } });\n      }\n      where.OR = nameConditions;\n    }\n    // Field filters with diacritics-insensitive support for text fields\n    if (whereFilters.address) {\n      const normalized = removeVietnameseDiacritics(whereFilters.address);\n      if (normalized !== whereFilters.address) {\n        const existingOR = where.OR || [];\n        where.OR = [\n          ...existingOR,\n          { address: { contains: whereFilters.address, mode: 'insensitive' } },\n          { address: { contains: normalized, mode: 'insensitive' } }\n        ];\n      } else {\n        where.address = { contains: whereFilters.address, mode: 'insensitive' };\n      }\n    }\n    if (whereFilters.phone) where.phone = { contains: whereFilters.phone, mode: 'insensitive' };\n\n    // Build orderBy based on sortBy and sortOrder\n    const orderBy: any = {};\n    if (sortBy === 'name' || sortBy === 'createdAt' || sortBy === 'updatedAt') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      orderBy.createdAt = 'desc'; // Default\n    }\n\n    const [outlets, total] = await Promise.all([\n      prisma.outlet.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          _count: {\n            select: { \n              users: true,\n              orders: true\n            }\n          }\n        },\n        orderBy,\n        skip,\n        take: limit\n      }),\n      prisma.outlet.count({ where })\n    ]);\n\n    console.log(`üìä db.outlets.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, outlets=${outlets.length}`);\n\n    return {\n      data: outlets,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.outlet.count({ where });\n  }\n};\n","// ============================================================================\n// PLAN DATABASE FUNCTIONS - MODERN SUBSCRIPTION SYSTEM\n// ============================================================================\n\nimport { prisma } from './client';\nimport type { Plan, PlanCreateInput, PlanUpdateInput, PlanFilters } from '@rentalshop/types';\nimport { calculatePlanPricing } from './subscription';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\n/**\n * Helper function to generate pricing object for a plan\n */\nfunction generatePlanPricing(basePrice: number) {\n  return {\n    monthly: {\n      price: basePrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: basePrice * 3, // 0% discount for quarterly\n      discount: 0,\n      savings: 0\n    },\n    semi_annual: {\n      price: basePrice * 6 * 0.95, // 5% discount for semi-annual\n      discount: 5,\n      savings: basePrice * 6 * 0.05\n    },\n    annual: {\n      price: basePrice * 12 * 0.90, // 10% discount for annual\n      discount: 10,\n      savings: basePrice * 12 * 0.10\n    }\n  };\n}\n\n/**\n * Get plan by public ID\n */\nexport async function getPlanById(id: number): Promise<Plan | null> {\n  try {\n    const plan = await prisma.plan.findUnique({\n      where: { id }\n    });\n\n    if (!plan) return null;\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error getting plan by public ID:', error);\n    throw error;\n  }\n}\n\n/**\n * Get all plans\n */\nexport async function getAllPlans(): Promise<Plan[]> {\n  try {\n    const plans = await prisma.plan.findMany({\n      where: { isActive: true },\n      orderBy: { sortOrder: 'asc' }\n    });\n\n    return plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Error getting all plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Search plans with filters\n */\nexport async function searchPlans(filters: PlanFilters = {}): Promise<{ plans: Plan[]; total: number; hasMore: boolean; page: number; limit: number; totalPages: number }> {\n  try {\n    const where: any = {};\n\n    // Apply filters\n    if (filters.search) {\n      const searchTerm = filters.search.trim();\n      const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n      \n      const searchConditions: any[] = [\n        { name: { contains: searchTerm, mode: 'insensitive' } },\n        { description: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n      \n      // Add normalized search if different from original\n      if (normalizedTerm !== searchTerm) {\n        searchConditions.push(\n          { name: { contains: normalizedTerm, mode: 'insensitive' } },\n          { description: { contains: normalizedTerm, mode: 'insensitive' } }\n        );\n      }\n      \n      where.OR = searchConditions;\n    }\n\n    if (filters.isActive !== undefined) {\n      where.isActive = filters.isActive;\n    }\n\n    if (filters.isPopular !== undefined) {\n      where.isPopular = filters.isPopular;\n    }\n\n    // Get total count\n    const total = await prisma.plan.count({ where });\n\n    // Get plans with pagination\n    const limit = filters.limit || 20;\n    const page = filters.page || 1;\n    const skip = (page - 1) * limit;\n    \n    const plans = await prisma.plan.findMany({\n      where,\n      orderBy: { sortOrder: 'asc' },\n      take: limit,\n      skip\n    });\n\n    const transformedPlans = plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n\n    const totalPages = Math.ceil(total / limit);\n    \n    return {\n      plans: transformedPlans,\n      total,\n      hasMore: page < totalPages,\n      page,\n      limit,\n      totalPages\n    };\n  } catch (error) {\n    console.error('Error searching plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Create a new plan\n */\nexport async function createPlan(data: PlanCreateInput): Promise<Plan> {\n  try {\n    const plan = await prisma.plan.create({\n      data: {\n        name: data.name,\n        description: data.description,\n        basePrice: data.basePrice,\n        currency: data.currency || 'USD',\n        trialDays: data.trialDays,\n        limits: JSON.stringify(data.limits),\n        features: JSON.stringify(data.features),\n        isActive: data.isActive ?? true,\n        isPopular: data.isPopular ?? false,\n        sortOrder: data.sortOrder ?? 0\n      }\n    });\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error creating plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Update a plan\n */\nexport async function updatePlan(id: number, data: PlanUpdateInput): Promise<Plan | null> {\n  try {\n    const plan = await prisma.plan.update({\n      where: { id },\n      data: {\n        ...(data.name && { name: data.name }),\n        ...(data.description && { description: data.description }),\n        ...(data.basePrice && { basePrice: data.basePrice }),\n        ...(data.currency && { currency: data.currency }),\n        ...(data.trialDays && { trialDays: data.trialDays }),\n        ...(data.limits && {\n          limits: JSON.stringify(data.limits)\n        }),\n        ...(data.features && { features: JSON.stringify(data.features) }),\n        ...(data.isActive !== undefined && { isActive: data.isActive }),\n        ...(data.isPopular !== undefined && { isPopular: data.isPopular }),\n        ...(data.sortOrder !== undefined && { sortOrder: data.sortOrder })\n      }\n    });\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error updating plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Delete a plan (soft delete)\n */\nexport async function deletePlan(id: number): Promise<boolean> {\n  try {\n    await prisma.plan.update({\n      where: { id },\n      data: { \n        isActive: false,\n        deletedAt: new Date()\n      }\n    });\n    return true;\n  } catch (error) {\n    console.error('Error deleting plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Get active plans\n */\nexport async function getActivePlans(): Promise<Plan[]> {\n  try {\n    const plans = await prisma.plan.findMany({\n      where: { \n        isActive: true,\n        deletedAt: null\n      },\n      orderBy: { sortOrder: 'asc' }\n    });\n\n    return plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Error getting active plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Get plan statistics\n */\nexport async function getPlanStats() {\n  try {\n    const [totalPlans, activePlans, popularPlans] = await Promise.all([\n      prisma.plan.count(),\n      prisma.plan.count({ where: { isActive: true } }),\n      prisma.plan.count({ where: { isPopular: true } })\n    ]);\n\n    return {\n      totalPlans,\n      activePlans,\n      popularPlans\n    };\n  } catch (error) {\n    console.error('Error getting plan stats:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedPlans = {\n  /**\n   * Find plan by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.plan.findUnique({\n      where: { id }\n    });\n  },\n\n  /**\n   * Find plan by name (simplified API)\n   */\n  findByName: async (name: string) => {\n    return await prisma.plan.findFirst({\n      where: { \n        name,\n        isActive: true \n      }\n    });\n  },\n\n  /**\n   * Create new plan (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.plan.create({\n      data\n    });\n  },\n\n  /**\n   * Update plan (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.plan.update({\n      where: { id },\n      data\n    });\n  },\n\n  /**\n   * Delete plan (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.plan.delete({\n      where: { id }\n    });\n  },\n\n  /**\n   * Search plans with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.isPopular !== undefined) where.isPopular = whereFilters.isPopular;\n    \n    // Text search\n    if (whereFilters.search) {\n      where.OR = [\n        { name: { contains: whereFilters.search } },\n        { description: { contains: whereFilters.search } }\n      ];\n    }\n\n    // Price range\n    if (whereFilters.minPrice !== undefined || whereFilters.maxPrice !== undefined) {\n      where.basePrice = {};\n      if (whereFilters.minPrice !== undefined) where.basePrice.gte = whereFilters.minPrice;\n      if (whereFilters.maxPrice !== undefined) where.basePrice.lte = whereFilters.maxPrice;\n    }\n\n    const [plans, total] = await Promise.all([\n      prisma.plan.findMany({\n        where,\n        orderBy: { sortOrder: 'asc' },\n        skip,\n        take: limit\n      }),\n      prisma.plan.count({ where })\n    ]);\n\n    return {\n      data: plans,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  /**\n   * Find first plan matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    const plan = await prisma.plan.findFirst({\n      where,\n      include: {\n        subscriptions: {\n          select: {\n            id: true,\n            merchantId: true,\n            status: true\n          }\n        }\n      }\n    });\n\n    if (!plan) return null;\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n      subscriptions: plan.subscriptions\n    };\n  },\n\n  /**\n   * Get plan statistics (simplified API)\n   */\n  getStats: async () => {\n    const [totalPlans, activePlans, popularPlans] = await Promise.all([\n      prisma.plan.count(),\n      prisma.plan.count({ where: { isActive: true } }),\n      prisma.plan.count({ where: { isPopular: true } })\n    ]);\n\n    return {\n      totalPlans,\n      activePlans,\n      popularPlans\n    };\n  }\n};","// ============================================================================\n// SIMPLIFIED SUBSCRIPTION DATABASE FUNCTIONS\n// ============================================================================\n\nimport { prisma } from './client';\nimport { calculateSubscriptionPrice, getPricingBreakdown } from '@rentalshop/utils';\nimport { SUBSCRIPTION_STATUS, PAYMENT_METHOD, PAYMENT_TYPE, PAYMENT_STATUS } from '@rentalshop/constants';\nimport type { \n  Subscription, \n  Plan, \n  PlanLimits,\n  SubscriptionCreateInput, \n  SubscriptionUpdateInput,\n  SubscriptionStatus,\n  BillingInterval\n} from '@rentalshop/types';\n\n// ============================================================================\n// PRICING UTILITIES\n// ============================================================================\n\n/**\n * Generate pricing object from base price\n */\nfunction generatePricingFromBasePrice(basePrice: number) {\n  const monthlyPrice = basePrice;\n  const quarterlyPrice = monthlyPrice * 3;\n  const semiAnnualPrice = monthlyPrice * 6;\n  const annualPrice = monthlyPrice * 12;\n  \n  return {\n    monthly: {\n      price: monthlyPrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: quarterlyPrice, // 0% discount\n      discount: 0,\n      savings: 0\n    },\n    semi_annual: {\n      price: semiAnnualPrice * 0.95, // 5% discount\n      discount: 5,\n      savings: semiAnnualPrice * 0.05\n    },\n    annual: {\n      price: annualPrice * 0.90, // 10% discount\n      discount: 10,\n      savings: annualPrice * 0.10\n    }\n  };\n}\n\n/**\n * Convert Prisma plan object to our Plan type\n */\nfunction convertPrismaPlanToPlan(prismaPlan: any): Plan {\n  return {\n    id: prismaPlan.id,\n    name: prismaPlan.name,\n    description: prismaPlan.description,\n    basePrice: prismaPlan.basePrice,\n    currency: prismaPlan.currency,\n    trialDays: prismaPlan.trialDays,\n    limits: JSON.parse(prismaPlan.limits as string) as PlanLimits,\n    features: JSON.parse(prismaPlan.features as string) as string[],\n    isActive: prismaPlan.isActive,\n    isPopular: prismaPlan.isPopular,\n    sortOrder: prismaPlan.sortOrder,\n    pricing: generatePricingFromBasePrice(prismaPlan.basePrice),\n    createdAt: prismaPlan.createdAt,\n    updatedAt: prismaPlan.updatedAt,\n    deletedAt: prismaPlan.deletedAt || undefined\n  };\n}\n\n/**\n * Helper function to generate pricing object for a plan\n */\nfunction generatePlanPricing(basePrice: number) {\n  return {\n    monthly: {\n      price: basePrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: basePrice * 3, // 0% discount for quarterly\n      discount: 0,\n      savings: 0\n    },\n    semi_annual: {\n      price: basePrice * 6 * 0.95, // 5% discount for semi-annual\n      discount: 5,\n      savings: basePrice * 6 * 0.05\n    },\n    annual: {\n      price: basePrice * 12 * 0.90, // 10% discount for annual\n      discount: 10,\n      savings: basePrice * 12 * 0.10\n    }\n  };\n}\n\n/**\n * Helper function to transform database plan to Plan type\n */\nfunction transformPlanFromDb(plan: any): Plan {\n  return {\n    id: plan.id,\n    name: plan.name,\n    description: plan.description,\n    basePrice: plan.basePrice,\n    currency: plan.currency,\n    trialDays: plan.trialDays,\n    limits: typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits,\n    features: typeof plan.features === 'string' ? JSON.parse(plan.features) : plan.features,\n    isActive: plan.isActive,\n    isPopular: plan.isPopular,\n    sortOrder: plan.sortOrder,\n    pricing: generatePlanPricing(plan.basePrice),\n    createdAt: plan.createdAt,\n    updatedAt: plan.updatedAt,\n    ...(plan.deletedAt && { deletedAt: plan.deletedAt })\n  };\n}\n\n/**\n * Helper function to transform Prisma subscription to Subscription type\n * Ensures all required fields are included\n */\nfunction transformSubscriptionFromDb(sub: any): Subscription {\n  return {\n    id: sub.id,\n    merchantId: sub.merchantId,\n    planId: sub.planId,\n    status: sub.status as SubscriptionStatus, // ‚úÖ Type safe with Prisma enum\n    billingInterval: sub.interval as BillingInterval,\n    currentPeriodStart: sub.currentPeriodStart,\n    currentPeriodEnd: sub.currentPeriodEnd,\n    trialStart: sub.trialStart,\n    trialEnd: sub.trialEnd,\n    amount: sub.amount,\n    currency: sub.currency || 'USD',\n    interval: sub.interval,\n    intervalCount: sub.intervalCount || 1,\n    period: sub.period || 1,\n    discount: sub.discount || 0,\n    savings: sub.savings || 0,\n    cancelAtPeriodEnd: sub.cancelAtPeriodEnd || false,\n    canceledAt: sub.canceledAt,\n    cancelReason: sub.cancelReason,\n    createdAt: sub.createdAt,\n    updatedAt: sub.updatedAt,\n    ...(sub.merchant && { merchant: sub.merchant }),\n    ...(sub.plan && { plan: convertPrismaPlanToPlan(sub.plan) })\n  };\n}\n\nexport function calculatePlanPricing(plan: Plan): Record<BillingInterval, number> {\n  const pricing: Record<BillingInterval, number> = {} as any;\n  \n  const intervals: BillingInterval[] = ['monthly', 'quarterly', 'semi_annual', 'annual'];\n  \n  for (const interval of intervals) {\n    pricing[interval] = calculateSubscriptionPrice(plan, interval);\n  }\n  \n  return pricing;\n}\n\nexport function calculatePeriodEnd(startDate: Date, billingInterval: BillingInterval): Date {\n  const endDate = new Date(startDate);\n  \n  switch (billingInterval) {\n    case 'monthly':\n      endDate.setMonth(endDate.getMonth() + 1);\n      break;\n    case 'quarterly':\n      endDate.setMonth(endDate.getMonth() + 3);\n      break;\n    case 'semi_annual':\n      endDate.setMonth(endDate.getMonth() + 6);\n      break;\n    case 'annual':\n      endDate.setFullYear(endDate.getFullYear() + 1);\n      break;\n    default:\n      endDate.setMonth(endDate.getMonth() + 1);\n  }\n  \n  return endDate;\n}\n\n// ============================================================================\n// SUBSCRIPTION QUERIES\n// ============================================================================\n\nexport async function getSubscriptionByMerchantId(merchantId: number): Promise<Subscription | null> {\n  // Find the merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: merchantId },\n    select: { id: true }\n  });\n  \n  if (!merchant) {\n    return null;\n  }\n  \n  const subscription = await prisma.subscription.findUnique({\n    where: { merchantId: merchant.id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  if (!subscription) return null;\n\n  return transformSubscriptionFromDb(subscription);\n}\n\nexport async function getAllSubscriptions(): Promise<Subscription[]> {\n  const subscriptions = await prisma.subscription.findMany({\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    },\n    orderBy: { createdAt: 'desc' }\n  });\n\n  return subscriptions.map((sub: any) => transformSubscriptionFromDb(sub));\n}\n\n// ============================================================================\n// SUBSCRIPTION SEARCH\n// ============================================================================\n\nexport async function searchSubscriptions(filters: {\n  search?: string;\n  merchantId?: number;\n  planId?: number;\n  status?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  page?: number;\n}): Promise<{ subscriptions: Subscription[]; total: number; hasMore: boolean; page: number; limit: number; totalPages: number }> {\n  const where: any = {};\n\n  // Apply search filter (merchant name)\n  if (filters.search) {\n    where.merchant = {\n      name: {\n        contains: filters.search,\n        mode: 'insensitive'\n      }\n    };\n  }\n\n  // Apply filters\n  if (filters.merchantId) {\n    where.merchantId = filters.merchantId;\n  }\n\n  if (filters.planId) {\n    where.planId = filters.planId;\n  }\n\n  if (filters.status) {\n    where.status = filters.status;\n  }\n\n  if (filters.startDate || filters.endDate) {\n    where.currentPeriodStart = {};\n    if (filters.startDate) where.currentPeriodStart.gte = filters.startDate;\n    if (filters.endDate) where.currentPeriodStart.lte = filters.endDate;\n  }\n\n  // Get total count\n  const total = await prisma.subscription.count({ where });\n\n  // Get subscriptions with pagination\n  const limit = filters.limit || 20;\n  const page = filters.page || 1;\n  const skip = (page - 1) * limit;\n  \n  const subscriptions = await prisma.subscription.findMany({\n    where,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    },\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip\n  });\n\n  const totalPages = Math.ceil(total / limit);\n  const hasMore = page < totalPages;\n\n  return {\n    subscriptions: subscriptions.map((sub: any) => transformSubscriptionFromDb(sub)),\n    total,\n    hasMore,\n    page,\n    limit,\n    totalPages\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION MUTATIONS\n// ============================================================================\n\nexport async function createSubscription(data: SubscriptionCreateInput): Promise<Subscription> {\n  // Get merchant by id\n  const merchant = await prisma.merchant.findUnique({\n    where: { id: data.merchantId }\n  });\n\n  if (!merchant) {\n    throw new Error('Merchant not found');\n  }\n\n  // Get plan by id\n  const plan = await prisma.plan.findUnique({\n    where: { id: data.planId }\n  });\n\n  if (!plan) {\n    throw new Error('Plan not found');\n  }\n\n  // Check if merchant already has a subscription\n  const existingSubscription = await prisma.subscription.findUnique({\n    where: { merchantId: merchant.id }\n  });\n\n  if (existingSubscription) {\n    throw new Error('Merchant already has a subscription');\n  }\n\n  // Calculate pricing based on billing interval\n  const billingInterval = data.billingInterval || 'monthly';\n  const convertedPlan = convertPrismaPlanToPlan(plan);\n  const amount = calculateSubscriptionPrice(convertedPlan, billingInterval);\n  \n  // Calculate dates\n  const startDate = data.startDate || new Date();\n  const currentPeriodEnd = calculatePeriodEnd(startDate, billingInterval);\n\n  const subscription = await prisma.subscription.create({\n    data: {\n      merchantId: merchant.id,\n      planId: plan.id,\n      status: (data.status || SUBSCRIPTION_STATUS.TRIAL) as SubscriptionStatus, // ‚úÖ Type safe with enum constant\n      interval: billingInterval,\n      currentPeriodStart: startDate,\n      currentPeriodEnd: currentPeriodEnd,\n      amount: amount\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  // Update merchant subscription status\n  await prisma.merchant.update({\n    where: { id: merchant.id },\n    data: {\n      // // subscriptionStatus: (removed - use subscription.status) (removed - use subscription.status) subscription.status\n    }\n  });\n\n  return transformSubscriptionFromDb(subscription);\n}\n\n// ============================================================================\n// PLAN FUNCTIONS\n// ============================================================================\n\nexport async function getAllPlans(): Promise<Plan[]> {\n  const plans = await prisma.plan.findMany({\n    where: { isActive: true },\n    orderBy: { sortOrder: 'asc' }\n  });\n\n  return plans.map((plan: any) => convertPrismaPlanToPlan(plan));\n}\n\nexport async function getPlanById(planId: number): Promise<Plan | null> {\n  const plan = await prisma.plan.findUnique({\n    where: { id: planId }\n  });\n\n  if (!plan) return null;\n\n  return {\n    id: plan.id,\n    name: plan.name,\n    description: plan.description,\n    basePrice: plan.basePrice,\n    currency: plan.currency,\n    trialDays: plan.trialDays,\n    limits: JSON.parse(plan.limits as string) as PlanLimits,\n    features: JSON.parse(plan.features as string) as string[],\n    isActive: plan.isActive,\n    isPopular: plan.isPopular,\n    sortOrder: plan.sortOrder,\n    pricing: generatePricingFromBasePrice(plan.basePrice),\n    createdAt: plan.createdAt,\n    updatedAt: plan.updatedAt,\n    deletedAt: plan.deletedAt || undefined\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION ACTIONS\n// ============================================================================\n\nexport async function changePlan(\n  subscriptionId: number, \n  newPlanId: number, \n  billingInterval: BillingInterval = 'monthly'\n): Promise<Subscription> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const plan = await prisma.plan.findUnique({\n    where: { id: newPlanId }\n  });\n\n  if (!plan) {\n    throw new Error('Plan not found');\n  }\n\n  const convertedPlan = convertPrismaPlanToPlan(plan);\n  const amount = calculateSubscriptionPrice(convertedPlan, billingInterval);\n\n  // Calculate new period dates based on billing interval\n  const now = new Date();\n  const newPeriodStart = now;\n  \n  // Calculate period duration in days based on billing interval\n  const getPeriodDays = (interval: BillingInterval): number => {\n    switch (interval) {\n      case 'monthly': return 30;\n      case 'quarterly': return 90;\n      case 'semi_annual': return 180;\n      case 'annual': return 365;\n      default: return 30;\n    }\n  };\n  \n  const periodDays = getPeriodDays(billingInterval);\n  const newPeriodEnd = new Date(now.getTime() + periodDays * 24 * 60 * 60 * 1000);\n\n  const updatedSubscription = await prisma.subscription.update({\n    where: { merchantId: subscription.merchantId },\n    data: {\n      planId: plan.id,\n      interval: billingInterval,\n      amount: amount,\n      currentPeriodStart: newPeriodStart,\n      currentPeriodEnd: newPeriodEnd,\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  // No need to update merchant - subscription.status is the single source of truth\n\n  const result = transformSubscriptionFromDb(updatedSubscription);\n  \n  // Add enhanced subscription period information\n  return {\n    ...result,\n    subscriptionPeriod: {\n      startDate: updatedSubscription.currentPeriodStart,\n      endDate: updatedSubscription.currentPeriodEnd,\n      duration: updatedSubscription.interval,\n      isActive: updatedSubscription.status === SUBSCRIPTION_STATUS.ACTIVE, // ‚úÖ Use enum constant\n      daysRemaining: Math.ceil((updatedSubscription.currentPeriodEnd.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)),\n      nextBillingDate: updatedSubscription.currentPeriodEnd\n    }\n  };\n}\n\nexport async function pauseSubscription(subscriptionId: number): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: SUBSCRIPTION_STATUS.PAUSED, // ‚úÖ Use enum constant\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  return transformSubscriptionFromDb(subscription);\n}\n\nexport async function resumeSubscription(subscriptionId: number): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: SUBSCRIPTION_STATUS.ACTIVE, // ‚úÖ Use enum constant\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  return transformSubscriptionFromDb(subscription);\n}\n\nexport async function cancelSubscription(subscriptionId: number): Promise<{ success: boolean; message: string; data?: Subscription; statusCode?: number }> {\n  try {\n    const subscription = await prisma.subscription.update({\n      where: { id: subscriptionId },\n      data: {\n        status: SUBSCRIPTION_STATUS.CANCELLED, // ‚úÖ Use enum constant\n        updatedAt: new Date()\n      },\n      include: {\n        merchant: {\n          select: {\n      id: true,\n            name: true,\n            email: true,\n          }\n        },\n        plan: true\n      }\n    });\n\n    const result = transformSubscriptionFromDb(subscription);\n\n    return {\n      success: true,\n      message: 'Subscription cancelled successfully',\n      data: result\n    };\n  } catch (error) {\n    console.error('Error cancelling subscription:', error);\n    return {\n      success: false,\n      message: 'Failed to cancel subscription',\n      statusCode: 500\n    };\n  }\n}\n\n// ============================================================================\n// SUBSCRIPTION RENEWAL FUNCTIONS\n// ============================================================================\n\nexport async function getExpiredSubscriptions(): Promise<Subscription[]> {\n  const now = new Date();\n  \n  const subscriptions = await prisma.subscription.findMany({\n    where: {\n      currentPeriodEnd: {\n        lt: now\n      },\n      status: {\n        in: [SUBSCRIPTION_STATUS.ACTIVE, SUBSCRIPTION_STATUS.TRIAL] // ‚úÖ Use enum constants\n      }\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    },\n    orderBy: { currentPeriodEnd: 'asc' }\n  });\n\n  return subscriptions.map((sub: any) => transformSubscriptionFromDb(sub));\n}\n\nexport async function getSubscriptionById(id: number): Promise<Subscription | null> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  if (!subscription) return null;\n\n  return transformSubscriptionFromDb(subscription);\n}\n\nexport async function updateSubscription(\n  subscriptionId: number, \n  data: Partial<{\n    status: SubscriptionStatus;\n    currentPeriodStart: Date;\n    currentPeriodEnd: Date;\n    amount: number;\n  }>\n): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      ...data,\n      updatedAt: new Date()\n    },\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n          email: true,\n        }\n      },\n      plan: true\n    }\n  });\n\n  return transformSubscriptionFromDb(subscription);\n}\n\n// ============================================================================\n// SUBSCRIPTION PAYMENT FUNCTIONS\n// ============================================================================\n\nexport interface SubscriptionPaymentCreateInput {\n  subscriptionId: number;\n  amount: number;\n  currency: string;\n  method: string;\n  status: string;\n  transactionId: string;\n  description?: string;\n  failureReason?: string;\n}\n\nexport interface SubscriptionPayment {\n  id: number;\n  subscriptionId: number;\n  amount: number;\n  currency: string;\n  method: string;\n  status: string;\n  transactionId: string;\n  description?: string;\n  failureReason?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport async function createSubscriptionPayment(data: SubscriptionPaymentCreateInput): Promise<SubscriptionPayment> {\n  // Find subscription by id\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: data.subscriptionId },\n    select: { id: true }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const payment = await prisma.payment.create({\n    data: {\n      subscriptionId: subscription.id,\n      amount: data.amount,\n      currency: data.currency,\n      method: (data.method || PAYMENT_METHOD.STRIPE) as any, // ‚úÖ Prisma s·∫Ω convert string -> enum automatically\n      type: PAYMENT_TYPE.SUBSCRIPTION_PAYMENT as any, // ‚úÖ Prisma s·∫Ω convert string -> enum automatically\n      status: (data.status || PAYMENT_STATUS.PENDING) as any, // ‚úÖ Prisma s·∫Ω convert string -> enum automatically\n      transactionId: data.transactionId,\n      description: data.description,\n      failureReason: data.failureReason\n    }\n  });\n\n  return {\n    id: payment.id,\n    subscriptionId: data.subscriptionId,\n    amount: payment.amount,\n    currency: payment.currency,\n    method: payment.method,\n    status: payment.status,\n    transactionId: payment.transactionId || '',\n    description: payment.description || undefined,\n    failureReason: payment.failureReason || undefined,\n    createdAt: payment.createdAt,\n    updatedAt: payment.updatedAt\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION PAYMENT HISTORY\n// ============================================================================\n\n/**\n * Get payment history for a subscription\n * @param subscriptionId - Subscription ID\n * @param filters - Optional filters for payments\n * @returns Payment history with pagination\n */\nexport async function getSubscriptionPaymentHistory(\n  subscriptionId: number,\n  filters?: {\n    status?: string;\n    method?: string;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n    offset?: number;\n  }\n): Promise<{\n  payments: SubscriptionPayment[];\n  total: number;\n  hasMore: boolean;\n}> {\n  const where: any = {\n    subscriptionId,\n    type: 'SUBSCRIPTION'\n  };\n\n  // Apply filters\n  if (filters?.status) {\n    where.status = filters.status.toUpperCase();\n  }\n\n  if (filters?.method) {\n    where.method = filters.method.toUpperCase();\n  }\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {};\n    if (filters.startDate) where.createdAt.gte = filters.startDate;\n    if (filters.endDate) where.createdAt.lte = filters.endDate;\n  }\n\n  const limit = filters?.limit || 20;\n  const offset = filters?.offset || 0;\n\n  // Get total count and payments\n  const [total, payments] = await Promise.all([\n    prisma.payment.count({ where }),\n    prisma.payment.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset\n    })\n  ]);\n\n  const hasMore = offset + limit < total;\n\n  return {\n    payments: payments.map((p: any) => ({\n      id: p.id,\n      subscriptionId: subscriptionId,\n      amount: p.amount,\n      currency: p.currency,\n      method: p.method,\n      status: p.status,\n      transactionId: p.transactionId || '',\n      description: p.description || undefined,\n      failureReason: p.failureReason || undefined,\n      createdAt: p.createdAt,\n      updatedAt: p.updatedAt\n    })),\n    total,\n    hasMore\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION RENEWAL\n// ============================================================================\n\n/**\n * Renew subscription for another month with payment\n * @param subscriptionId - Subscription ID\n * @param paymentData - Payment information\n * @returns Updated subscription and payment record\n */\nexport async function renewSubscription(\n  subscriptionId: number,\n  paymentData: {\n    method: 'STRIPE' | 'TRANSFER';\n    transactionId: string;\n    reference?: string;\n    description?: string;\n  }\n): Promise<{\n  subscription: Subscription;\n  payment: SubscriptionPayment;\n}> {\n  // 1. Get subscription with merchant\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId },\n    include: {\n      merchant: true,\n      plan: true\n    }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  // 2. Validate subscription can be renewed\n  if (subscription.status === SUBSCRIPTION_STATUS.CANCELLED) { // ‚úÖ Use enum constant\n    throw new Error('Cannot renew cancelled subscription');\n  }\n\n  // 3. Calculate new period (extend by 1 month)\n  const newPeriodStart = subscription.currentPeriodEnd;\n  const newPeriodEnd = calculatePeriodEnd(newPeriodStart, 'monthly');\n\n  // 4. Use database transaction to ensure atomicity\n  const result = await prisma.$transaction(async (tx: any) => {\n    // Create payment record\n    const payment = await tx.payment.create({\n      data: {\n        subscriptionId: subscription.id,\n        merchantId: subscriptionId,\n        amount: subscription.amount,\n        currency: subscription.currency,\n        method: paymentData.method,\n        type: PAYMENT_TYPE.SUBSCRIPTION_PAYMENT as any,\n        status: paymentData.method === PAYMENT_METHOD.STRIPE ? PAYMENT_STATUS.COMPLETED as any : PAYMENT_STATUS.PENDING as any,\n        transactionId: paymentData.transactionId,\n        reference: paymentData.reference,\n        description: paymentData.description || `Monthly subscription renewal - ${new Date().toLocaleDateString()}`,\n        processedAt: paymentData.method === PAYMENT_METHOD.STRIPE ? new Date() : null\n      }\n    });\n\n    // Update subscription period\n    const updatedSubscription = await tx.subscription.update({\n      where: { merchantId: subscription.merchantId },\n      data: {\n        currentPeriodStart: newPeriodStart,\n        currentPeriodEnd: newPeriodEnd,\n        status: SUBSCRIPTION_STATUS.ACTIVE, // ‚úÖ Use enum constant\n        updatedAt: new Date()\n      },\n      include: {\n        merchant: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n          }\n        },\n        plan: true\n      }\n    });\n\n    // Update merchant status\n    await tx.merchant.update({\n      where: { id: subscription.merchantId },\n      data: {\n        // subscriptionStatus removed - use subscription.status instead\n        lastActiveAt: new Date()\n      }\n    });\n\n    return { updatedSubscription, payment };\n  });\n\n  // 5. Return formatted response\n  return {\n    subscription: transformSubscriptionFromDb(result.updatedSubscription),\n    payment: {\n      id: result.payment.id,\n      subscriptionId: subscriptionId,\n      amount: result.payment.amount,\n      currency: result.payment.currency,\n      method: result.payment.method,\n      status: result.payment.status,\n      transactionId: result.payment.transactionId || '',\n      description: result.payment.description || undefined,\n      createdAt: result.payment.createdAt,\n      updatedAt: result.payment.updatedAt\n    }\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedSubscriptions = {\n  /**\n   * Find subscription by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.subscription.findUnique({\n      where: { id },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Find subscription by merchant ID (simplified API)\n   */\n  findByMerchantId: async (merchantId: number) => {\n    return await prisma.subscription.findFirst({\n      where: { \n        merchantId,\n        status: { not: 'CANCELLED' }\n      },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new subscription (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.subscription.create({\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Update subscription (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.subscription.update({\n      where: { id },\n      data,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Delete subscription (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.subscription.update({\n      where: { id },\n      data: { \n        status: 'CANCELLED',\n        canceledAt: new Date()\n      }\n    });\n  },\n\n  /**\n   * Search subscriptions with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    // Apply search filter (merchant name)\n    if (whereFilters.search) {\n      where.merchant = {\n        name: {\n          contains: whereFilters.search,\n          mode: 'insensitive'\n        }\n      };\n    }\n    \n    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n    if (whereFilters.planId) where.planId = whereFilters.planId;\n    if (whereFilters.isActive !== undefined) {\n      if (whereFilters.isActive) {\n        where.status = { not: 'CANCELLED' };\n      } else {\n        where.status = 'CANCELLED';\n      }\n    }\n    if (whereFilters.status) where.status = whereFilters.status;\n    \n    // Date range filters\n    if (whereFilters.startDate || whereFilters.endDate) {\n      where.createdAt = {};\n      if (whereFilters.startDate) where.createdAt.gte = whereFilters.startDate;\n      if (whereFilters.endDate) where.createdAt.lte = whereFilters.endDate;\n    }\n\n    const [subscriptions, total] = await Promise.all([\n      prisma.subscription.findMany({\n        where,\n        include: {\n          merchant: { select: { id: true, name: true } },\n          plan: { select: { id: true, name: true } },\n          payments: {\n            orderBy: { createdAt: 'desc' },\n            take: 3\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit\n      }),\n      prisma.subscription.count({ where })\n    ]);\n\n    return {\n      data: subscriptions,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  /**\n   * Find first subscription matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.subscription.findFirst({\n      where,\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Get subscription statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.subscription.count({ where });\n  },\n\n  /**\n   * Get expired subscriptions (simplified API)\n   */\n  getExpired: async () => {\n    const now = new Date();\n    \n    return await prisma.subscription.findMany({\n      where: {\n        status: { not: 'CANCELLED' },\n        OR: [\n          { \n            status: 'TRIAL',\n            trialEnd: { lt: now }\n          },\n          {\n            status: 'ACTIVE',\n            currentPeriodEnd: { lt: now }\n          }\n        ]\n      },\n      include: {\n        merchant: { select: { id: true, name: true } },\n        plan: { select: { id: true, name: true } }\n      },\n      orderBy: { currentPeriodEnd: 'asc' }\n    });\n  }\n};","import { prisma } from './client';\n\n/**\n * Create a subscription activity log\n */\nexport async function createActivity(data: {\n  subscriptionId: number;\n  type: string;\n  description: string;\n  reason?: string;\n  metadata?: any;\n  performedBy?: number;\n}) {\n  const { metadata, ...rest } = data;\n  \n  return await prisma.subscriptionActivity.create({\n    data: {\n      ...rest,\n      metadata: metadata ? JSON.stringify(metadata) : null\n    }\n  });\n}\n\n/**\n * Get activities for a subscription\n */\nexport async function getActivitiesBySubscriptionId(\n  subscriptionId: number,\n  options: { limit?: number; offset?: number } = {}\n) {\n  const { limit = 50, offset = 0 } = options;\n  \n  const [activities, total] = await Promise.all([\n    prisma.subscriptionActivity.findMany({\n      where: { subscriptionId },\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            role: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset\n    }),\n    prisma.subscriptionActivity.count({ where: { subscriptionId } })\n  ]);\n\n  // Parse metadata JSON\n  return {\n    activities: activities.map((activity: any) => ({\n      ...activity,\n      metadata: activity.metadata ? JSON.parse(activity.metadata) : null\n    })),\n    total\n  };\n}\n\n/**\n * Simplified subscription activity operations\n */\nexport const simplifiedSubscriptionActivities = {\n  /**\n   * Create activity (simplified API)\n   */\n  create: createActivity,\n\n  /**\n   * Get activities by subscription ID\n   */\n  getBySubscriptionId: getActivitiesBySubscriptionId\n};\n\n","\n// ============================================================================\n// SIMPLIFIED MERCHANT OPERATIONS\n// ============================================================================\n// Consistent with other simplified database operations\n\nimport { prisma } from './client';\nimport { ORDER_STATUS } from '@rentalshop/constants';\nimport type { SimpleFilters, SimpleResponse } from './index';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ntype BusinessTypeEnum = 'GENERAL' | 'VEHICLE' | 'CLOTHING' | 'EQUIPMENT';\ntype PricingTypeEnum = 'FIXED' | 'HOURLY' | 'DAILY';\n\nexport interface MerchantFilters extends SimpleFilters {\n  businessType?: BusinessTypeEnum;\n  // subscriptionStatus removed - use subscription.status instead\n  planId?: number;\n  isActive?: boolean;\n}\n\nexport interface MerchantCreateData {\n  name: string;\n  email: string;\n  phone?: string;\n  tenantKey?: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  businessType?: BusinessTypeEnum;\n  pricingType?: PricingTypeEnum;\n  taxId?: string;\n  website?: string;\n  description?: string;\n  currency?: string; // Currency code (USD, VND), defaults to USD\n  pricingConfig?: string;\n  planId?: number;\n  // subscriptionStatus removed - use subscription.status instead\n}\n\nexport interface MerchantUpdateData extends Partial<MerchantCreateData> {\n  totalRevenue?: number;\n  lastActiveAt?: Date;\n  isActive?: boolean;\n}\n\n// ============================================================================\n// MERCHANT OPERATIONS\n// ============================================================================\n\n/**\n * Find merchant by ID\n */\nexport async function findById(id: number) {\n  return await prisma.merchant.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      phone: true,\n      address: true,\n      city: true,\n      state: true,\n      zipCode: true,\n      country: true,\n      website: true,\n      description: true,\n      businessType: true,\n      pricingType: true,\n      pricingConfig: true,\n      taxId: true,\n      currency: true,\n      tenantKey: true, // Include tenantKey for public product links\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n      subscription: {\n        include: {\n          plan: true\n        }\n      },\n      outlets: {\n        select: {\n          id: true,\n          name: true,\n          isActive: true\n        }\n      },\n      _count: {\n        select: {\n          outlets: true,\n          users: true,\n          products: true,\n          customers: true\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find merchant by email\n */\nexport async function findByEmail(email: string) {\n  return await prisma.merchant.findUnique({\n    where: { email },\n    include: {\n      Plan: true,\n      subscription: true\n    }\n  });\n}\n\n/**\n * Find merchant by tenantKey\n * Used for public product pages where merchant shares link with customers\n */\nexport async function findByTenantKey(tenantKey: string) {\n  return await prisma.merchant.findUnique({\n    where: { tenantKey },\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      address: true,\n      phone: true,\n      email: true,\n      website: true,\n      city: true,\n      country: true,\n      currency: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n}\n\n/**\n * Search merchants with filtering and pagination\n */\nexport async function search(filters: MerchantFilters): Promise<SimpleResponse<any>> {\n  const {\n    page = 1,\n    limit = 20,\n    search,\n    businessType,\n    planId,\n    isActive\n  } = filters;\n\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {};\n\n  if (search) {\n    const searchTerm = search.trim();\n    const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n    \n    const searchConditions: any[] = [\n      { name: { contains: searchTerm, mode: 'insensitive' } },\n      { email: { contains: searchTerm, mode: 'insensitive' } }\n    ];\n    \n    // Add normalized search if different from original\n    if (normalizedTerm !== searchTerm) {\n      searchConditions.push(\n        { name: { contains: normalizedTerm, mode: 'insensitive' } }\n      );\n    }\n    \n    where.OR = searchConditions;\n  }\n\n  if (businessType) {\n    where.businessType = businessType;\n  }\n\n  // subscriptionStatus filter removed - use subscription.status instead\n  // if (subscriptionStatus) {\n  //   where.subscription = {\n  //     status: subscriptionStatus\n  //   };\n  // }\n\n  if (planId !== undefined) {\n    where.planId = planId;\n  }\n\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  }\n\n  // Execute query\n  const [merchants, total] = await Promise.all([\n    prisma.merchant.findMany({\n      where,\n      include: {\n        subscription: {\n          select: {\n            id: true,\n            status: true,\n            currentPeriodStart: true,\n            currentPeriodEnd: true,\n            trialStart: true,\n            trialEnd: true,\n            amount: true,\n            currency: true,\n            interval: true,\n            period: true,\n            discount: true,\n            savings: true,\n            cancelAtPeriodEnd: true,\n            canceledAt: true,\n            cancelReason: true,\n            plan: {\n              select: {\n                id: true,\n                name: true,\n                description: true,\n                basePrice: true,\n                currency: true,\n                trialDays: true\n              }\n            }\n          }\n        },\n        _count: {\n          select: {\n            outlets: true,\n            users: true,\n            products: true,\n            customers: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      skip,\n      take: limit\n    }),\n    prisma.merchant.count({ where })\n  ]);\n\n  return {\n    data: merchants,\n    total,\n    page,\n    limit,\n    hasMore: skip + limit < total\n  };\n}\n\n/**\n * Create new merchant\n */\nexport async function create(data: MerchantCreateData) {\n  const { planId, ...rest } = data;\n  return await prisma.merchant.create({\n    data: {\n      ...rest,\n      ...(planId !== undefined ? { Plan: { connect: { id: planId } } } : {}),\n      createdAt: new Date(),\n      updatedAt: new Date()\n    },\n    include: {\n      Plan: true,\n      subscription: true\n    }\n  });\n}\n\n/**\n * Update merchant\n */\nexport async function update(id: number, data: MerchantUpdateData) {\n  const { planId, ...rest } = data;\n  return await prisma.merchant.update({\n    where: { id },\n    data: {\n      ...rest,\n      ...(planId !== undefined ? { Plan: { connect: { id: planId } } } : {}),\n      updatedAt: new Date()\n    },\n    include: {\n      Plan: true,\n      subscription: true\n    }\n  });\n}\n\n/**\n * Delete merchant (soft delete)\n */\nexport async function remove(id: number) {\n  return await prisma.merchant.update({\n    where: { id },\n    data: {\n      isActive: false,\n      updatedAt: new Date()\n    }\n  });\n}\n\n/**\n * Get merchant statistics\n */\nexport async function getStats(id: number) {\n  const merchant = await prisma.merchant.findUnique({\n    where: { id },\n    include: {\n        _count: {\n          select: {\n            outlets: true,\n            users: true,\n            products: true,\n            customers: true\n          }\n        }\n    }\n  });\n\n  if (!merchant) {\n    return null;\n  }\n\n  // Get revenue from orders\n  const revenueResult = await prisma.order.aggregate({\n    where: {\n      outlet: {\n        merchantId: id\n      },\n      status: { in: [ORDER_STATUS.COMPLETED as any, ORDER_STATUS.RETURNED as any] }\n    },\n    _sum: {\n      totalAmount: true\n    }\n  });\n\n  return {\n    totalOutlets: merchant._count.outlets,\n    totalUsers: merchant._count.users,\n    totalProducts: merchant._count.products,\n    totalCustomers: merchant._count.customers,\n    totalOrders: 0, // Will be calculated separately\n    totalRevenue: revenueResult._sum.totalAmount || 0\n  };\n}\n\n/**\n * Count merchants with optional where clause\n */\nexport async function count(options?: { where?: any }) {\n  const where = options?.where || {};\n  return await prisma.merchant.count({ where });\n}\n\n/**\n * Check for duplicate merchant by email or phone\n */\nexport async function checkDuplicate(email?: string, phone?: string, excludeId?: number) {\n  if (!email && !phone) {\n    return null;\n  }\n\n  const conditions = [];\n  \n  if (email) {\n    conditions.push({ email });\n  }\n  \n  if (phone) {\n    conditions.push({ phone });\n  }\n\n  const where: any = {\n    OR: conditions\n  };\n\n  // Exclude specific merchant ID (for update operations)\n  if (excludeId) {\n    where.id = { not: excludeId };\n  }\n\n  return await prisma.merchant.findFirst({ where });\n}\n\n// ============================================================================\n// EXPORT SIMPLIFIED INTERFACE\n// ============================================================================\n\n/**\n * Find first merchant matching criteria (simplified API)\n */\nexport const findFirst = async (whereClause: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.merchant.findFirst({\n    where,\n    select: {\n      id: true,\n      name: true,\n      email: true,\n      phone: true,\n      address: true,\n      businessType: true,\n      pricingType: true,\n      pricingConfig: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\nexport const simplifiedMerchants = {\n  findById,\n  findByEmail,\n  findByTenantKey,\n  findFirst,\n  search,\n  create,\n  update,\n  remove,\n  getStats,\n  count,\n  checkDuplicate\n};\n\n\n","/**\n * Order Number Generator & Configuration\n * \n * Provides robust, concurrent-safe order number generation for rental shop orders.\n * Supports multiple formats, handles race conditions, and includes centralized configuration.\n */\n\nimport { prisma } from './index';\n\n// ============================================================================\n// TYPES & INTERFACES\n// ============================================================================\n\nexport type OrderNumberFormat = 'sequential' | 'date-based' | 'random' | 'random-numeric' | 'hybrid' | 'compact-numeric';\n\nexport interface OrderNumberConfig {\n  format: OrderNumberFormat;\n  outletId: number;\n  prefix?: string;\n  includeDate?: boolean;\n  sequenceLength?: number;\n  randomLength?: number;\n  numericOnly?: boolean;\n}\n\nexport interface OrderNumberResult {\n  orderNumber: string;\n  sequence: number;\n  generatedAt: Date;\n}\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\n/**\n * Default order number format for new orders\n * \n * Available formats:\n * - 'sequential': ORD-{outletId}-{sequence} (e.g., ORD-001-0001)\n * - 'date-based': ORD-{outletId}-{date}-{sequence} (e.g., ORD-001-20250115-0001)\n * - 'random': ORD-{outletId}-{random} (e.g., ORD-001-A7B9C2)\n * - 'random-numeric': ORD-{outletId}-{random} (e.g., ORD-001-123456)\n * - 'hybrid': ORD-{outletId}-{date}-{random} (e.g., ORD-001-20250115-A7B9)\n * - 'compact-numeric': ORD{outletId}{random} (e.g., ORD00112345)\n */\nexport const ORDER_NUMBER_CONFIG = {\n  // Primary format for all new orders\n  format: 'compact-numeric' as OrderNumberFormat,\n  \n  // Prefix for all order numbers\n  prefix: 'ORD',\n  \n  // Sequence number padding (how many digits)\n  sequenceLength: 4,\n  \n  // Random string length (for random and hybrid formats)\n  randomLength: 6,\n  \n  // Whether to include date in order numbers (for date-based and hybrid)\n  includeDate: true,\n  \n  // Maximum retry attempts for collision resolution\n  maxRetries: 5,\n  \n  // Retry delay in milliseconds (exponential backoff)\n  retryDelay: 10,\n} as const;\n\n/**\n * Format-specific configurations\n */\nexport const FORMAT_CONFIGS = {\n  sequential: {\n    description: 'Sequential numbering per outlet',\n    example: 'ORD-001-0001',\n    pros: ['Outlet identification', 'Easy tracking', 'Human readable'],\n    cons: ['Business intelligence leakage', 'Race conditions possible'],\n    bestFor: 'Small to medium businesses with low concurrency'\n  },\n  \n  'date-based': {\n    description: 'Date-based with daily sequence reset',\n    example: 'ORD-001-20250115-0001',\n    pros: ['Daily organization', 'Better security', 'Easy daily reporting'],\n    cons: ['Longer numbers', 'Still somewhat predictable'],\n    bestFor: 'Medium businesses with daily operations focus'\n  },\n  \n  random: {\n    description: 'Random alphanumeric strings for security',\n    example: 'ORD-001-A7B9C2',\n    pros: ['Maximum security', 'No race conditions', 'Unpredictable'],\n    cons: ['No sequence tracking', 'Harder to manage', 'No business insights'],\n    bestFor: 'Large businesses prioritizing security'\n  },\n  \n  'random-numeric': {\n    description: 'Random numeric strings for security',\n    example: 'ORD-001-123456',\n    pros: ['Maximum security', 'No race conditions', 'Numbers only', 'Unpredictable'],\n    cons: ['No sequence tracking', 'Harder to manage', 'No business insights'],\n    bestFor: 'Businesses needing numeric-only random order numbers'\n  },\n  \n  'compact-numeric': {\n    description: 'Compact format with outlet ID and 5-digit random number',\n    example: 'ORD00112345',\n    pros: ['Compact format', 'Outlet identification', 'Numbers only', 'Short length', 'Easy to read'],\n    cons: ['No sequence tracking', 'Limited randomness (5 digits)'],\n    bestFor: 'Businesses wanting compact, numeric-only order numbers'\n  },\n  \n  hybrid: {\n    description: 'Combines outlet, date, and random elements',\n    example: 'ORD-001-20250115-A7B9',\n    pros: ['Balanced security', 'Outlet identification', 'Date organization'],\n    cons: ['Longer numbers', 'More complex'],\n    bestFor: 'Large businesses needing both security and organization'\n  }\n} as const;\n\n// ============================================================================\n// CONFIGURATION FUNCTIONS\n// ============================================================================\n\n/**\n * Get the current order number configuration\n */\nexport function getOrderNumberConfig() {\n  return ORDER_NUMBER_CONFIG;\n}\n\n/**\n * Update order number configuration (for testing or admin purposes)\n */\nexport function updateOrderNumberConfig(updates: Partial<typeof ORDER_NUMBER_CONFIG>) {\n  Object.assign(ORDER_NUMBER_CONFIG, updates);\n}\n\n/**\n * Get format information for display purposes\n */\nexport function getFormatInfo(format: OrderNumberFormat) {\n  return FORMAT_CONFIGS[format];\n}\n\n/**\n * Get all available formats with their information\n */\nexport function getAllFormats() {\n  return Object.entries(FORMAT_CONFIGS).map(([key, value]) => ({\n    format: key as OrderNumberFormat,\n    ...value\n  }));\n}\n\n/**\n * Validate order number format configuration\n */\nexport function validateOrderNumberConfig(config: typeof ORDER_NUMBER_CONFIG): string[] {\n  const errors: string[] = [];\n  \n  if (!config.prefix || config.prefix.length === 0) {\n    errors.push('Prefix cannot be empty');\n  }\n  \n  if (config.sequenceLength < 1 || config.sequenceLength > 10) {\n    errors.push('Sequence length must be between 1 and 10');\n  }\n  \n  if (config.randomLength < 4 || config.randomLength > 20) {\n    errors.push('Random length must be between 4 and 20');\n  }\n  \n  if (config.maxRetries < 1 || config.maxRetries > 20) {\n    errors.push('Max retries must be between 1 and 20');\n  }\n  \n  if (config.retryDelay < 1 || config.retryDelay > 1000) {\n    errors.push('Retry delay must be between 1 and 1000 milliseconds');\n  }\n  \n  return errors;\n}\n\n/**\n * Get recommended format based on business characteristics\n */\nexport function getRecommendedFormat(businessSize: 'small' | 'medium' | 'large', \n                                   concurrencyLevel: 'low' | 'medium' | 'high',\n                                   securityPriority: 'low' | 'medium' | 'high'): OrderNumberFormat {\n  // Small business with low concurrency and low security needs\n  if (businessSize === 'small' && concurrencyLevel === 'low' && securityPriority === 'low') {\n    return 'compact-numeric';\n  }\n  \n  // Medium business or higher security needs\n  if (businessSize === 'medium' || securityPriority === 'medium') {\n    return 'date-based';\n  }\n  \n  // High concurrency or high security needs\n  if (concurrencyLevel === 'high' || securityPriority === 'high') {\n    return 'random-numeric';\n  }\n  \n  // Large business with balanced needs\n  if (businessSize === 'large') {\n    return 'hybrid';\n  }\n  \n  // Default fallback - compact numeric for easy use\n  return 'compact-numeric';\n}\n\n// ============================================================================\n// ORDER NUMBER GENERATION\n// ============================================================================\n\n/**\n * Generate order number with specified format\n */\nexport async function generateOrderNumber(\n  config: OrderNumberConfig\n): Promise<OrderNumberResult> {\n  const {\n    format = 'sequential',\n    outletId,\n    prefix = 'ORD',\n    includeDate = false,\n    sequenceLength = 4,\n    randomLength = 6,\n    numericOnly = false\n  } = config;\n\n  // Validate outlet exists\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true, name: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  const outletIdStr = outlet.id.toString().padStart(3, '0');\n  const generatedAt = new Date();\n\n  switch (format) {\n    case 'sequential':\n      return await generateSequentialNumber(outletIdStr, prefix, sequenceLength);\n    \n    case 'date-based':\n      return await generateDateBasedNumber(outletIdStr, prefix, sequenceLength, generatedAt);\n    \n    case 'random':\n      return await generateRandomNumber(outletIdStr, prefix, randomLength, false);\n    \n    case 'random-numeric':\n      return await generateRandomNumber(outletIdStr, prefix, randomLength, true);\n    \n    case 'compact-numeric':\n      return await generateCompactNumericNumber(outletIdStr, prefix);\n    \n    case 'hybrid':\n      return await generateHybridNumber(outletIdStr, prefix, sequenceLength, generatedAt, numericOnly);\n    \n    default:\n      throw new Error(`Unsupported order number format: ${format}`);\n  }\n}\n\n/**\n * Generate sequential order number: ORD-{outletId}-{sequence}\n * Uses atomic counter to prevent race conditions\n */\nasync function generateSequentialNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number\n): Promise<OrderNumberResult> {\n  const maxRetries = 5;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Use atomic increment with retry logic\n      const result = await prisma.$transaction(async (tx: any) => {\n        // Get current sequence for this outlet\n        const lastOrder = await tx.order.findFirst({\n          where: { \n            orderNumber: { startsWith: `${prefix}-${outletIdStr}-` }\n          },\n          orderBy: { createdAt: 'desc' },\n          select: { orderNumber: true, createdAt: true }\n        });\n\n        let nextSequence = 1;\n        \n        if (lastOrder) {\n          // Extract sequence from last order number\n          const parts = lastOrder.orderNumber.split('-');\n          const lastSequence = parseInt(parts[parts.length - 1]) || 0;\n          nextSequence = lastSequence + 1;\n        }\n\n        const orderNumber = `${prefix}-${outletIdStr}-${nextSequence.toString().padStart(sequenceLength, '0')}`;\n\n        // Check for uniqueness (double-check)\n        const existingOrder = await tx.order.findUnique({\n          where: { orderNumber },\n          select: { id: true }\n        });\n\n        if (existingOrder) {\n          throw new Error('Order number collision detected');\n        }\n\n        return {\n          orderNumber,\n          sequence: nextSequence,\n          generatedAt: new Date()\n        };\n      });\n\n      return result;\n    } catch (error) {\n      retryCount++;\n      if (retryCount >= maxRetries) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        throw new Error(`Failed to generate sequential order number after ${maxRetries} retries: ${errorMessage}`);\n      }\n      \n      // Wait before retry (exponential backoff)\n      await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 10));\n    }\n  }\n\n  throw new Error('Maximum retries exceeded');\n}\n\n/**\n * Generate date-based order number: ORD-{outletId}-{date}-{sequence}\n * Resets sequence daily for better organization\n */\nasync function generateDateBasedNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number,\n  generatedAt: Date\n): Promise<OrderNumberResult> {\n  const dateStr = generatedAt.toISOString().split('T')[0].replace(/-/g, '');\n  \n  const result = await prisma.$transaction(async (tx: any) => {\n    // Get last order for this outlet on this date\n    const lastOrder = await tx.order.findFirst({\n      where: { \n        orderNumber: { startsWith: `${prefix}-${outletIdStr}-${dateStr}-` }\n      },\n      orderBy: { createdAt: 'desc' },\n      select: { orderNumber: true }\n    });\n\n    let nextSequence = 1;\n    \n    if (lastOrder) {\n      const parts = lastOrder.orderNumber.split('-');\n      const lastSequence = parseInt(parts[parts.length - 1]) || 0;\n      nextSequence = lastSequence + 1;\n    }\n\n    const orderNumber = `${prefix}-${outletIdStr}-${dateStr}-${nextSequence.toString().padStart(sequenceLength, '0')}`;\n\n    // Check for uniqueness\n    const existingOrder = await tx.order.findUnique({\n      where: { orderNumber },\n      select: { id: true }\n    });\n\n    if (existingOrder) {\n      throw new Error('Order number collision detected');\n    }\n\n    return {\n      orderNumber,\n      sequence: nextSequence,\n      generatedAt\n    };\n  });\n\n  return result;\n}\n\n/**\n * Generate random order number: ORD-{outletId}-{random}\n * Uses crypto-secure random generation\n */\nasync function generateRandomNumber(\n  outletIdStr: string,\n  prefix: string,\n  randomLength: number,\n  numericOnly: boolean = false\n): Promise<OrderNumberResult> {\n  const maxRetries = 10;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Generate crypto-secure random string\n      const randomStr = generateRandomString(randomLength, numericOnly);\n      const orderNumber = `${prefix}-${outletIdStr}-${randomStr}`;\n\n      // Check for uniqueness\n      const existingOrder = await prisma.order.findUnique({\n        where: { orderNumber },\n        select: { id: true }\n      });\n\n      if (!existingOrder) {\n        return {\n          orderNumber,\n          sequence: 0, // No sequence for random\n          generatedAt: new Date()\n        };\n      }\n\n      retryCount++;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to generate random order number: ${errorMessage}`);\n    }\n  }\n\n  throw new Error(`Failed to generate unique random order number after ${maxRetries} attempts`);\n}\n\n/**\n * Generate compact numeric order number: ORD{outletId}{random}\n * Format: ORD00112345678 (no hyphens, 8-digit random number)\n */\nasync function generateCompactNumericNumber(\n  outletIdStr: string,\n  prefix: string\n): Promise<OrderNumberResult> {\n  const maxRetries = 10;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Generate 8-digit random number\n      const randomStr = generateRandomString(8, true); // 8 digits, numeric only\n      const orderNumber = `${prefix}${outletIdStr}${randomStr}`;\n\n      // Check for uniqueness\n      const existingOrder = await prisma.order.findUnique({\n        where: { orderNumber },\n        select: { id: true }\n      });\n\n      if (!existingOrder) {\n        return {\n          orderNumber,\n          sequence: 0, // No sequence for compact numeric\n          generatedAt: new Date()\n        };\n      }\n\n      retryCount++;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to generate compact numeric order number: ${errorMessage}`);\n    }\n  }\n\n  throw new Error(`Failed to generate unique compact numeric order number after ${maxRetries} attempts`);\n}\n\n/**\n * Generate hybrid order number: ORD-{outletId}-{date}-{random}\n * Combines outlet, date, and random for optimal security and organization\n */\nasync function generateHybridNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number,\n  generatedAt: Date,\n  numericOnly: boolean = false\n): Promise<OrderNumberResult> {\n  const dateStr = generatedAt.toISOString().split('T')[0].replace(/-/g, '');\n  const randomStr = generateRandomString(4, numericOnly); // Shorter random part\n  \n  const orderNumber = `${prefix}-${outletIdStr}-${dateStr}-${randomStr}`;\n\n  // Check for uniqueness\n  const existingOrder = await prisma.order.findUnique({\n    where: { orderNumber },\n    select: { id: true }\n  });\n\n  if (existingOrder) {\n    // If collision, try with different random string\n    return generateHybridNumber(outletIdStr, prefix, sequenceLength, generatedAt, numericOnly);\n  }\n\n  return {\n    orderNumber,\n    sequence: 0, // No sequence for hybrid\n    generatedAt\n  };\n}\n\n/**\n * Generate crypto-secure random string\n */\nfunction generateRandomString(length: number, numericOnly: boolean = false): string {\n  const chars = numericOnly ? '0123456789' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  const randomBytes = new Uint8Array(length);\n  \n  if (typeof window !== 'undefined' && window.crypto) {\n    // Browser environment\n    window.crypto.getRandomValues(randomBytes);\n  } else {\n    // Node.js environment\n    const crypto = require('crypto');\n    const randomBytesNode = crypto.randomBytes(length);\n    randomBytes.set(randomBytesNode);\n  }\n  \n  return Array.from(randomBytes, byte => chars[byte % chars.length]).join('');\n}\n\n// ============================================================================\n// VALIDATION & PARSING\n// ============================================================================\n\n/**\n * Validate order number format\n */\nexport function validateOrderNumber(orderNumber: string): boolean {\n  const patterns = [\n    /^\\d{3}-\\d{4}$/, // Sequential: ORD-001-0001\n    /^\\d{3}-\\d{8}-\\d{4}$/, // Date-based: ORD-001-20250115-0001\n    /^\\d{3}-[A-Z0-9]{6}$/, // Random: ORD-001-A7B9C2\n    /^\\d{3}-\\d{6}$/, // Random-numeric: ORD-001-123456\n    /^\\d{3}-\\d{8}-[A-Z0-9]{4}$/, // Hybrid: ORD-001-20250115-A7B9\n    /^\\d{3}\\d{5}$/ // Compact-numeric: ORD00112345\n  ];\n  \n  return patterns.some(pattern => pattern.test(orderNumber));\n}\n\n/**\n * Parse order number to extract components\n */\nexport function parseOrderNumber(orderNumber: string): {\n  prefix: string;\n  outletId: number;\n  date?: string;\n  sequence?: number;\n  random?: string;\n  format: OrderNumberFormat;\n} | null {\n  if (!validateOrderNumber(orderNumber)) {\n    return null;\n  }\n\n  // Check for compact-numeric format first (no hyphens)\n  if (/^ORD\\d{3}\\d{5}$/.test(orderNumber)) {\n    const outletId = parseInt(orderNumber.substring(3, 6));\n    const random = orderNumber.substring(6);\n    \n    return {\n      prefix: 'ORD',\n      outletId,\n      random,\n      format: 'compact-numeric'\n    };\n  }\n\n  const parts = orderNumber.split('-');\n  \n  if (parts.length === 3) {\n    // Sequential or Random format\n    const sequence = parseInt(parts[2]);\n    const isNumeric = /^\\d+$/.test(parts[2]);\n    \n    return {\n      prefix: parts[0],\n      outletId: parseInt(parts[1]),\n      sequence: isNumeric ? sequence : undefined,\n      random: !isNumeric ? parts[2] : undefined,\n      format: isNumeric ? 'sequential' : 'random'\n    };\n  }\n  \n  if (parts.length === 4) {\n    // Date-based or Hybrid format\n    const sequence = parseInt(parts[3]);\n    const isNumeric = /^\\d+$/.test(parts[3]);\n    \n    return {\n      prefix: parts[0],\n      outletId: parseInt(parts[1]),\n      date: parts[2],\n      sequence: isNumeric ? sequence : undefined,\n      random: !isNumeric ? parts[3] : undefined,\n      format: isNumeric ? 'date-based' : 'hybrid'\n    };\n  }\n  \n  return null;\n}\n\n// ============================================================================\n// STATISTICS & UTILITIES\n// ============================================================================\n\n/**\n * Get order statistics for an outlet\n */\nexport async function getOutletOrderStats(outletId: number): Promise<{\n  totalOrders: number;\n  todayOrders: number;\n  lastOrderNumber?: string;\n  lastOrderDate?: Date;\n}> {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const tomorrow = new Date(today);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n\n  const [totalOrders, todayOrders, lastOrder] = await Promise.all([\n    prisma.order.count({\n      where: { outletId: outlet.id }\n    }),\n    prisma.order.count({\n      where: { \n        outletId: outlet.id,\n        createdAt: {\n          gte: today,\n          lt: tomorrow\n        }\n      }\n    }),\n    prisma.order.findFirst({\n      where: { outletId: outlet.id },\n      orderBy: { createdAt: 'desc' },\n      select: { orderNumber: true, createdAt: true }\n    })\n  ]);\n\n  return {\n    totalOrders,\n    todayOrders,\n    lastOrderNumber: lastOrder?.orderNumber,\n    lastOrderDate: lastOrder?.createdAt\n  };\n}\n\n/**\n * Quick order number generation with default settings\n */\nexport async function createOrderNumber(outletId: number): Promise<string> {\n  const result = await generateOrderNumber({\n    format: 'sequential',\n    outletId,\n    prefix: 'ORD',\n    sequenceLength: 4\n  });\n  \n  return result.orderNumber;\n}\n\n/**\n * Generate order number with specific format\n */\nexport async function createOrderNumberWithFormat(\n  outletId: number, \n  format: OrderNumberFormat\n): Promise<OrderNumberResult> {\n  const config: OrderNumberConfig = {\n    format,\n    outletId,\n    prefix: 'ORD',\n    sequenceLength: 4,\n    randomLength: 6,\n    includeDate: true\n  };\n  \n  return await generateOrderNumber(config);\n}\n\n/**\n * Generate multiple order numbers for testing\n */\nexport async function generateTestOrderNumbers(\n  outletId: number, \n  count: number, \n  format: OrderNumberFormat = 'sequential'\n): Promise<string[]> {\n  const orderNumbers: string[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const result = await createOrderNumberWithFormat(outletId, format);\n    orderNumbers.push(result.orderNumber);\n  }\n  \n  return orderNumbers;\n}\n\n/**\n * Analyze order number\n */\nexport function analyzeOrderNumber(orderNumber: string) {\n  const isValid = validateOrderNumber(orderNumber);\n  const parsed = parseOrderNumber(orderNumber);\n  \n  return {\n    orderNumber,\n    isValid,\n    parsed,\n    format: parsed?.format || 'unknown',\n    outletId: parsed?.outletId,\n    sequence: parsed?.sequence,\n    date: parsed?.date,\n    random: parsed?.random\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedOrderNumbers = {\n  /**\n   * Get outlet order stats (simplified API)\n   */\n  getOutletStats: async (outletId: number) => {\n    return await getOutletOrderStats(outletId);\n  },\n\n  /**\n   * Create order number with format (simplified API)\n   */\n  createWithFormat: async (outletId: number, format: OrderNumberFormat) => {\n    return await createOrderNumberWithFormat(outletId, format);\n  },\n\n  /**\n   * Generate multiple order numbers (simplified API)\n   */\n  generateMultiple: async (outletId: number, count: number, format: OrderNumberFormat = 'sequential') => {\n    return await generateTestOrderNumbers(outletId, count, format);\n  },\n\n  /**\n   * Validate order number format (simplified API)\n   */\n  validateFormat: (orderNumber: string) => {\n    return validateOrderNumber(orderNumber);\n  },\n\n  /**\n   * Get format info (simplified API)\n   */\n  getFormatInfo: (format: OrderNumberFormat) => {\n    return getFormatInfo(format);\n  }\n};","// ============================================================================\n// CATEGORY FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains category functions that follow the simplified API pattern\n// - Input: id (number)\n// - Database: queries by id, uses numbers for relationships\n// - Return: includes id (number)\n\nimport { prisma } from './client';\n\n// ============================================================================\n// CATEGORY LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find category by ID (simplified API)\n */\nexport const findById = async (id: number) => {\n  return await prisma.category.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Find first category matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.category.findFirst({\n    where,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Find many categories matching criteria (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, select = {}, orderBy = { name: 'asc' }, take, skip } = options;\n  \n  return await prisma.category.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      ...select\n    },\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Create new category (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.category.create({\n    data,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Update category (simplified API)\n */\nexport const update = async (id: number, data: any) => {\n  return await prisma.category.update({\n    where: { id },\n    data,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Delete category (hard delete) (simplified API)\n * Note: Dependency check should be done before calling this function\n */\nexport const deleteCategory = async (id: number) => {\n  return await prisma.category.delete({\n    where: { id }\n  });\n};\n\n/**\n * Search categories with pagination (simplified API)\n */\nexport const search = async (filters: any) => {\n  const { page = 1, limit = 20, sortBy = 'name', sortOrder = 'asc', ...whereFilters } = filters;\n  const skip = (page - 1) * limit;\n\n  console.log('üîç DB category.search - Received filters:', filters);\n\n  // Build where clause\n  const where: any = {};\n  \n  if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;\n  // Default to active categories only unless explicitly requesting all\n  if (whereFilters.isActive !== undefined) {\n    where.isActive = whereFilters.isActive;\n  } else {\n    where.isActive = true; // Default: only show active categories\n  }\n  \n  // Text search by category name - accept both 'q' and 'search' parameters\n  const searchTerm = (whereFilters.q || whereFilters.search)?.trim();\n  console.log('üîç DB category.search - searchTerm:', searchTerm, 'length:', searchTerm?.length);\n  \n  if (searchTerm && searchTerm.length > 0) {\n    where.name = { \n      contains: searchTerm, \n      mode: 'insensitive' \n    };\n    console.log('‚úÖ DB category.search - Added name filter:', where.name);\n  } else {\n    console.log('‚ö†Ô∏è DB category.search - No search term, will return all categories');\n  }\n  \n  console.log('üîç DB category.search - Final where clause:', JSON.stringify(where, null, 2));\n\n  // Build orderBy based on sortBy and sortOrder\n  const orderBy: any = {};\n  if (sortBy === 'name' || sortBy === 'createdAt' || sortBy === 'updatedAt') {\n    orderBy[sortBy] = sortOrder;\n  } else {\n    orderBy.name = 'asc'; // Default\n  }\n\n  const [categories, total] = await Promise.all([\n    prisma.category.findMany({\n      where,\n      select: {\n        id: true,\n        name: true,\n        description: true,\n        isActive: true,\n        isDefault: true,\n        createdAt: true,\n        updatedAt: true,\n        _count: {\n          select: {\n            products: true\n          }\n        }\n      },\n      orderBy,\n      skip,\n      take: limit\n    }),\n    prisma.category.count({ where })\n  ]);\n\n  console.log(`üìä db.categories.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, categories=${categories.length}`);\n\n  return {\n    data: categories,\n    total,\n    page,\n    limit,\n    hasMore: skip + limit < total,\n    totalPages: Math.ceil(total / limit)\n  };\n};\n\n/**\n * Get category statistics (simplified API)\n */\nexport const getStats = async (whereClause?: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.category.count({ where });\n};\n\n// ============================================================================\n// SIMPLIFIED CATEGORY API\n// ============================================================================\n\nexport const simplifiedCategories = {\n  findById,\n  findFirst,\n  findMany,\n  create,\n  update,\n  delete: deleteCategory,\n  search,\n  getStats\n};\n","// ============================================================================\n// AUDIT LOG FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains audit log functions that follow the simplified API pattern\n\nimport { prisma } from './client';\n\n// ============================================================================\n// AUDIT LOG LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find audit logs with filtering (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, include = {}, orderBy = { createdAt: 'desc' }, take, skip } = options;\n  \n  return await prisma.auditLog.findMany({\n    where,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      },\n      ...include\n    },\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Get audit log statistics (simplified API)\n */\nexport const getStats = async (whereClause?: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.auditLog.count({ where });\n};\n\n/**\n * Find first audit log matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.auditLog.findFirst({\n    where,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      }\n    }\n  });\n};\n\n/**\n * Create audit log (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.auditLog.create({\n    data,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      }\n    }\n  });\n};\n\n// ============================================================================\n// SIMPLIFIED AUDIT LOGS API\n// ============================================================================\n\nexport const simplifiedAuditLogs = {\n  findMany,\n  findFirst,\n  create,\n  getStats\n};\n","// ============================================================================\n// ORDER ITEM FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains order item functions that follow the simplified API pattern\n\nimport { prisma } from './client';\n\n// ============================================================================\n// ORDER ITEM LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find order items with filtering (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, include = {}, orderBy = { createdAt: 'desc' }, take, skip } = options;\n  \n  return await prisma.orderItem.findMany({\n    where,\n    include,\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Group by order items (simplified API)\n */\nexport const groupBy = async (options: any) => {\n  const { by, where = {}, _count = {}, _sum = {}, _avg = {}, orderBy, take } = options;\n  \n  // Build the groupBy options object\n  const groupByOptions: any = {\n    by,\n    where,\n    orderBy,\n    take\n  };\n  \n  // Only add aggregation options if they have content\n  if (Object.keys(_count).length > 0) {\n    groupByOptions._count = _count;\n  }\n  \n  if (Object.keys(_sum).length > 0) {\n    groupByOptions._sum = _sum;\n  }\n  \n  if (Object.keys(_avg).length > 0) {\n    groupByOptions._avg = _avg;\n  }\n  \n  return await prisma.orderItem.groupBy(groupByOptions);\n};\n\n/**\n * Get order item statistics (simplified API)\n */\nexport const getStats = async (whereClause?: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.orderItem.count({ where });\n};\n\n/**\n * Find first order item matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.orderItem.findFirst({\n    where,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Create order item (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.orderItem.create({\n    data,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Update order item (simplified API)\n */\nexport const update = async (id: number, data: any) => {\n  return await prisma.orderItem.update({\n    where: { id },\n    data,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Delete order item (simplified API)\n */\nexport const deleteOrderItem = async (id: number) => {\n  return await prisma.orderItem.delete({\n    where: { id }\n  });\n};\n\n// ============================================================================\n// SIMPLIFIED ORDER ITEMS API\n// ============================================================================\n\nexport const simplifiedOrderItems = {\n  findMany,\n  findFirst,\n  create,\n  update,\n  delete: deleteOrderItem,\n  getStats,\n  groupBy\n};\n","import { prisma } from './client';\nimport { randomBytes } from 'crypto';\n\n/**\n * Generate a unique session ID\n */\nexport function generateSessionId(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Create a new session for a user and invalidate all previous sessions\n * This implements \"single session\" behavior - only the latest login is valid\n */\nexport async function createUserSession(\n  userId: number,\n  ipAddress?: string,\n  userAgent?: string\n) {\n  const sessionId = generateSessionId();\n  const expiresAt = new Date();\n  expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiry\n\n  // Start a transaction to ensure atomicity\n  return await prisma.$transaction(async (tx) => {\n    // 1. Invalidate ALL previous sessions for this user\n    await tx.userSession.updateMany({\n      where: {\n        userId,\n        isActive: true,\n      },\n      data: {\n        isActive: false,\n        invalidatedAt: new Date(),\n      },\n    });\n\n    // 2. Create new session\n    const session = await tx.userSession.create({\n      data: {\n        userId,\n        sessionId,\n        ipAddress,\n        userAgent,\n        expiresAt,\n        isActive: true,\n      },\n    });\n\n    return session;\n  });\n}\n\n/**\n * Validate a session by sessionId\n * Returns true if session is valid (active and not expired)\n */\nexport async function validateSession(sessionId: string): Promise<boolean> {\n  if (!sessionId) {\n    return false;\n  }\n\n  const session = await prisma.userSession.findUnique({\n    where: { sessionId },\n  });\n\n  if (!session) {\n    return false;\n  }\n\n  // Check if session is active\n  if (!session.isActive) {\n    return false;\n  }\n\n  // Check if session is expired\n  if (session.expiresAt < new Date()) {\n    // Auto-invalidate expired session\n    await prisma.userSession.update({\n      where: { id: session.id },\n      data: {\n        isActive: false,\n        invalidatedAt: new Date(),\n      },\n    });\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Invalidate a specific session (for logout)\n */\nexport async function invalidateSession(sessionId: string): Promise<void> {\n  await prisma.userSession.updateMany({\n    where: {\n      sessionId,\n      isActive: true,\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Invalidate all sessions for a user\n */\nexport async function invalidateAllUserSessions(userId: number): Promise<void> {\n  await prisma.userSession.updateMany({\n    where: {\n      userId,\n      isActive: true,\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Get active sessions for a user\n */\nexport async function getUserActiveSessions(userId: number) {\n  return await prisma.userSession.findMany({\n    where: {\n      userId,\n      isActive: true,\n      expiresAt: {\n        gt: new Date(),\n      },\n    },\n    orderBy: {\n      createdAt: 'desc',\n    },\n  });\n}\n\n/**\n * Clean up expired sessions (can be run periodically)\n */\nexport async function cleanupExpiredSessions(): Promise<number> {\n  const result = await prisma.userSession.updateMany({\n    where: {\n      isActive: true,\n      expiresAt: {\n        lt: new Date(),\n      },\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n\n  return result.count;\n}\n\nexport const sessions = {\n  generateSessionId,\n  createUserSession,\n  validateSession,\n  invalidateSession,\n  invalidateAllUserSessions,\n  getUserActiveSessions,\n  cleanupExpiredSessions,\n};\n\n","/**\n * Sync Session Operations\n * Temporary implementation for sync-standalone endpoint\n * TODO: Implement proper sync session tracking with database model\n */\n\nimport { prisma } from './client';\n\nexport interface SyncSession {\n  id: number;\n  type: 'sync' | 'import'; // Add type to distinguish sync vs import sessions\n  merchantId: number;\n  entities: string[];\n  config: {\n    endpoint?: string;\n    token?: string;\n    fileName?: string; // For import sessions\n    fileSize?: number; // For import sessions\n    options?: {\n      skipDuplicates?: boolean;\n      validateOnly?: boolean;\n    };\n  };\n  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED' | 'PARTIALLY_COMPLETED';\n  stats?: any;\n  errorLog?: any[];\n  progress?: {\n    currentEntity?: string;\n    currentEntityIndex?: number;\n    entityProgress?: {\n      customers?: { processed: number; total: number; lastProcessedIndex: number; errors?: number };\n      products?: { processed: number; total: number; lastProcessedIndex: number; errors?: number };\n      orders?: { processed: number; total: number; lastProcessedIndex: number; errors?: number };\n    };\n    lastError?: {\n      entity: string;\n      index: number;\n      error: string;\n      timestamp: Date;\n    };\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface CreateSessionInput {\n  type?: 'sync' | 'import'; // Default to 'sync' for backward compatibility\n  merchantId: number;\n  entities: string[];\n  config: {\n    endpoint?: string;\n    token?: string;\n    fileName?: string;\n    fileSize?: number;\n    options?: {\n      skipDuplicates?: boolean;\n      validateOnly?: boolean;\n    };\n  };\n}\n\nexport interface UpdateStatusInput {\n  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED' | 'PARTIALLY_COMPLETED';\n  stats?: any;\n  errorLog?: any[];\n  progress?: {\n    currentEntity?: string;\n    currentEntityIndex?: number;\n    entityProgress?: {\n      customers?: { processed: number; total: number; lastProcessedIndex: number };\n      products?: { processed: number; total: number; lastProcessedIndex: number };\n      orders?: { processed: number; total: number; lastProcessedIndex: number };\n    };\n    lastError?: {\n      entity: string;\n      index: number;\n      error: string;\n      timestamp: Date;\n    };\n  };\n}\n\nexport interface AddRecordInput {\n  syncSessionId: number;\n  entityType: 'customer' | 'product' | 'order';\n  entityId: number;\n  oldServerId: string;\n  status: 'created' | 'updated' | 'failed';\n  logMessage?: string;\n}\n\nexport interface CreatedRecord {\n  entityType: 'customer' | 'product' | 'order';\n  entityId: number;\n  oldServerId: string;\n}\n\n/**\n * Simplified sync operations\n * Note: This is a temporary implementation. \n * For production, consider creating a SyncSession model in Prisma schema.\n */\nconst simplifiedSync = {\n  /**\n   * Track created records for rollback\n   */\n  createdRecords: new Map<number, CreatedRecord[]>(),\n  \n  /**\n   * Store sync sessions in memory (temporary)\n   */\n  sessions: new Map<number, SyncSession>(),\n\n  /**\n   * Add created record to tracking\n   */\n  trackRecord(sessionId: number, record: CreatedRecord): void {\n    if (!this.createdRecords.has(sessionId)) {\n      this.createdRecords.set(sessionId, []);\n    }\n    this.createdRecords.get(sessionId)!.push(record);\n  },\n\n  /**\n   * Rollback all created records for a session\n   */\n  async rollback(sessionId: number): Promise<{ deleted: number; errors: string[] }> {\n    const records = this.createdRecords.get(sessionId) || [];\n    const errors: string[] = [];\n    let deleted = 0;\n\n    console.log(`üîÑ Rolling back ${records.length} records for session ${sessionId}`);\n\n    // Delete in reverse order (orders -> products -> customers)\n    // Orders must be deleted first (with their orderItems), then products, then customers\n    const orders = records.filter(r => r.entityType === 'order');\n    const products = records.filter(r => r.entityType === 'product');\n    const customers = records.filter(r => r.entityType === 'customer');\n\n    // Delete orders first (with orderItems)\n    for (const record of orders) {\n      try {\n        // Delete orderItems first (foreign key constraint)\n        await prisma.orderItem.deleteMany({ \n          where: { orderId: record.entityId } \n        }).catch(() => {\n          // OrderItems might not exist\n        });\n        \n        // Then delete the order\n        await prisma.order.delete({ \n          where: { id: record.entityId } \n        }).catch(() => {\n          // Order might have been deleted or doesn't exist\n        });\n        \n        deleted++;\n      } catch (error: any) {\n        errors.push(`Failed to delete order ${record.entityId}: ${error.message}`);\n      }\n    }\n\n    // Delete products (may have outletStock relations)\n    for (const record of products) {\n      try {\n        // Delete outletStock first if exists\n        await prisma.outletStock.deleteMany({ \n          where: { productId: record.entityId } \n        }).catch(() => {\n          // OutletStock might not exist\n        });\n        \n        // Then delete the product\n        await prisma.product.delete({ \n          where: { id: record.entityId } \n        }).catch(() => {\n          // Product might have been deleted or doesn't exist\n        });\n        \n        deleted++;\n      } catch (error: any) {\n        errors.push(`Failed to delete product ${record.entityId}: ${error.message}`);\n      }\n    }\n\n    // Delete customers last (may have orders, but we already deleted orders)\n    for (const record of customers) {\n      try {\n        await prisma.customer.delete({ \n          where: { id: record.entityId } \n        }).catch(() => {\n          // Customer might have been deleted or doesn't exist\n        });\n        \n        deleted++;\n      } catch (error: any) {\n        errors.push(`Failed to delete customer ${record.entityId}: ${error.message}`);\n      }\n    }\n\n    // Clear tracking\n    this.createdRecords.delete(sessionId);\n\n    console.log(`‚úÖ Rollback completed: ${deleted} records deleted, ${errors.length} errors`);\n\n    return { deleted, errors };\n  },\n\n  /**\n   * Clear tracking for a session (after successful completion)\n   */\n  clearTracking(sessionId: number): void {\n    this.createdRecords.delete(sessionId);\n  },\n  /**\n   * Create a sync session\n   * TODO: Store in database when SyncSession model is created\n   */\n  async createSession(input: CreateSessionInput): Promise<SyncSession> {\n    // Temporary in-memory implementation\n    // In production, this should create a record in the database\n    const session: SyncSession = {\n      id: Date.now(), // Temporary ID\n      type: input.type || 'sync', // Default to 'sync' for backward compatibility\n      merchantId: input.merchantId,\n      entities: input.entities,\n      config: input.config,\n      status: 'PENDING',\n      progress: {\n        entityProgress: {}\n      },\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    // Store in memory\n    this.sessions.set(session.id, session);\n\n    console.log('üìù Sync session created (temporary):', {\n      id: session.id,\n      merchantId: session.merchantId,\n      entities: session.entities\n    });\n\n    return session;\n  },\n  \n  /**\n   * Get sync session by ID\n   */\n  async getSession(sessionId: number): Promise<SyncSession | null> {\n    return this.sessions.get(sessionId) || null;\n  },\n\n  /**\n   * Update sync session status\n   * TODO: Update database record when SyncSession model is created\n   */\n  async updateStatus(\n    sessionId: number,\n    input: UpdateStatusInput\n  ): Promise<void> {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      console.warn(`‚ö†Ô∏è Sync session ${sessionId} not found`);\n      return;\n    }\n\n    // Update session in memory\n    session.status = input.status;\n    session.updatedAt = new Date();\n    if (input.stats) {\n      session.stats = input.stats;\n    }\n    if (input.errorLog) {\n      session.errorLog = input.errorLog;\n    }\n    if (input.progress) {\n      session.progress = {\n        ...session.progress,\n        ...input.progress,\n        entityProgress: {\n          ...session.progress?.entityProgress,\n          ...input.progress.entityProgress\n        }\n      };\n    }\n\n    // Store updated session\n    this.sessions.set(sessionId, session);\n\n    console.log('üìä Sync session status updated:', {\n      sessionId,\n      status: input.status,\n      hasStats: !!input.stats,\n      hasErrorLog: !!input.errorLog,\n      progress: input.progress\n    });\n\n    // In production, update the database record:\n    // await prisma.syncSession.update({\n    //   where: { id: sessionId },\n    //   data: {\n    //     status: input.status,\n    //     stats: input.stats ? JSON.stringify(input.stats) : undefined,\n    //     errorLog: input.errorLog ? JSON.stringify(input.errorLog) : undefined,\n    //     progress: input.progress ? JSON.stringify(input.progress) : undefined,\n    //     updatedAt: new Date()\n    //   }\n    // });\n  },\n\n  /**\n   * Add a sync record\n   * TODO: Store in database when SyncRecord model is created\n   */\n  async addRecord(input: AddRecordInput): Promise<void> {\n    // Temporary implementation - just log\n    console.log('üìã Sync record added (temporary):', {\n      syncSessionId: input.syncSessionId,\n      entityType: input.entityType,\n      entityId: input.entityId,\n      oldServerId: input.oldServerId,\n      status: input.status,\n      logMessage: input.logMessage\n    });\n\n    // In production, create a database record:\n    // await prisma.syncRecord.create({\n    //   data: {\n    //     syncSessionId: input.syncSessionId,\n    //     entityType: input.entityType,\n    //     entityId: input.entityId,\n    //     oldServerId: input.oldServerId,\n    //     status: input.status,\n    //     logMessage: input.logMessage,\n    //     createdAt: new Date()\n    //   }\n    // });\n  }\n};\n\nexport { simplifiedSync };\n\n","/**\n * Comprehensive Audit Logging System\n * \n * This module provides a complete audit logging solution that tracks:\n * - Who made changes (user, role, context)\n * - What was changed (entity, fields, values)\n * - When changes occurred (timestamp, session)\n * - Where changes came from (IP, user agent)\n * - Why changes were made (business context)\n */\n\nimport { PrismaClient } from '@prisma/client';\n\n// Types for audit logging\nexport interface AuditContext {\n  userId?: number;\n  userEmail?: string;\n  userRole?: string;\n  merchantId?: number;\n  outletId?: number;\n  ipAddress?: string;\n  userAgent?: string;\n  sessionId?: string;\n  requestId?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface AuditLogData {\n  action: 'CREATE' | 'UPDATE' | 'DELETE' | 'LOGIN' | 'LOGOUT' | 'VIEW' | 'EXPORT' | 'IMPORT' | 'CUSTOM';\n  entityType: string;\n  entityId: string;\n  entityName?: string;\n  oldValues?: Record<string, any>;\n  newValues?: Record<string, any>;\n  changes?: Record<string, { old: any; new: any }>;\n  severity?: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL';\n  category?: 'GENERAL' | 'SECURITY' | 'BUSINESS' | 'SYSTEM' | 'COMPLIANCE';\n  description?: string;\n  context: AuditContext;\n}\n\nexport interface AuditLogFilter {\n  action?: string;\n  entityType?: string;\n  entityId?: string;\n  userId?: number;\n  merchantId?: number;\n  outletId?: number;\n  severity?: string;\n  category?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  offset?: number;\n}\n\n// Audit logger class\nexport class AuditLogger {\n  private prisma: PrismaClient;\n  private idCounter: number = 0;\n\n  constructor(prisma: PrismaClient) {\n    this.prisma = prisma;\n  }\n\n  // Get next public ID\n  private async getNextPublicId(): Promise<number> {\n    // Temporarily disabled - AuditLog model not in schema\n    return 1;\n  }\n\n  // Main logging method\n  async log(data: AuditLogData): Promise<void> {\n    try {\n      console.log('üîç AuditLogger.log - Starting audit log creation...');\n      const id = await this.getNextPublicId();\n      console.log('üîç AuditLogger.log - Got id:', id);\n      \n      // Validate foreign key IDs to prevent constraint violations\n      const validatedUserId = await this.validateUserId(data.context.userId);\n      const validatedMerchantId = await this.validateMerchantId(data.context.merchantId);\n      const validatedOutletId = await this.validateOutletId(data.context.outletId);\n      \n      console.log('üîç AuditLogger.log - About to create audit log with data:', {\n        id,\n        action: data.action,\n        entityType: data.entityType,\n        entityId: data.entityId,\n        userId: validatedUserId,\n        merchantId: validatedMerchantId,\n        outletId: validatedOutletId\n      });\n      \n      // Temporarily disabled - AuditLog model not in schema\n      console.log('üîç Audit log would be created:', {\n        id,\n        action: data.action,\n        entityType: data.entityType,\n        entityId: data.entityId\n      });\n      console.log('‚úÖ AuditLogger.log - Audit log created successfully');\n    } catch (error) {\n      // Don't throw errors from audit logging to avoid breaking main operations\n      console.error('‚ùå AuditLogger.log - Audit logging failed:', error);\n      console.error('‚ùå AuditLogger.log - Error details:', error instanceof Error ? error.message : String(error));\n      console.error('‚ùå AuditLogger.log - Error stack:', error instanceof Error ? error.stack : undefined);\n    }\n  }\n\n  // Validate foreign key IDs to prevent constraint violations\n  private async validateUserId(userId?: number): Promise<number | null> {\n    if (!userId) return null;\n    \n    try {\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        select: { id: true }\n      });\n      return user ? userId : null;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è AuditLogger - Failed to validate userId:', userId, error);\n      return null;\n    }\n  }\n\n  private async validateMerchantId(merchantId?: number): Promise<number | null> {\n    if (!merchantId) return null;\n    \n    try {\n      const merchant = await this.prisma.merchant.findUnique({\n        where: { id: merchantId },\n        select: { id: true }\n      });\n      return merchant ? merchantId : null;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è AuditLogger - Failed to validate merchantId:', merchantId, error);\n      return null;\n    }\n  }\n\n  private async validateOutletId(outletId?: number): Promise<number | null> {\n    if (!outletId) return null;\n    \n    try {\n      const outlet = await this.prisma.outlet.findUnique({\n        where: { id: outletId },\n        select: { id: true }\n      });\n      return outlet ? outletId : null;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è AuditLogger - Failed to validate outletId:', outletId, error);\n      return null;\n    }\n  }\n\n  // Convenience methods for common operations\n  async logCreate(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    newValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'CREATE',\n      entityType,\n      entityId,\n      entityName,\n      newValues,\n      description: description || `Created ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logUpdate(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    oldValues: Record<string, any>,\n    newValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    const changes = this.calculateChanges(oldValues, newValues);\n    \n    await this.log({\n      action: 'UPDATE',\n      entityType,\n      entityId,\n      entityName,\n      oldValues,\n      newValues,\n      changes,\n      description: description || `Updated ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logDelete(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    oldValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'DELETE',\n      entityType,\n      entityId,\n      entityName,\n      oldValues,\n      description: description || `Deleted ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logLogin(\n    userId: number,\n    userEmail: string,\n    userRole: string,\n    context: AuditContext,\n    success: boolean = true\n  ): Promise<void> {\n    await this.log({\n      action: 'LOGIN',\n      entityType: 'User',\n      entityId: userId.toString(),\n      entityName: userEmail,\n      newValues: { success, timestamp: new Date().toISOString() },\n      severity: success ? 'INFO' : 'WARNING',\n      category: 'SECURITY',\n      description: success ? `User logged in: ${userEmail}` : `Failed login attempt: ${userEmail}`,\n      context\n    });\n  }\n\n  async logLogout(\n    userId: number,\n    userEmail: string,\n    context: AuditContext\n  ): Promise<void> {\n    await this.log({\n      action: 'LOGOUT',\n      entityType: 'User',\n      entityId: userId.toString(),\n      entityName: userEmail,\n      category: 'SECURITY',\n      description: `User logged out: ${userEmail}`,\n      context\n    });\n  }\n\n  async logSecurityEvent(\n    event: string,\n    entityType: string,\n    entityId: string,\n    context: AuditContext,\n    severity: 'WARNING' | 'ERROR' | 'CRITICAL' = 'WARNING',\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'CUSTOM',\n      entityType,\n      entityId,\n      severity,\n      category: 'SECURITY',\n      description: description || `Security event: ${event}`,\n      context\n    });\n  }\n\n  // Calculate changes between old and new values\n  private calculateChanges(oldValues: Record<string, any>, newValues: Record<string, any>): Record<string, { old: any; new: any }> {\n    const changes: Record<string, { old: any; new: any }> = {};\n    \n    // Check for changed fields\n    const allKeys = new Set([...Object.keys(oldValues), ...Object.keys(newValues)]);\n    \n    for (const key of Array.from(allKeys)) {\n      const oldValue = oldValues[key];\n      const newValue = newValues[key];\n      \n      if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n        changes[key] = { old: oldValue, new: newValue };\n      }\n    }\n    \n    return changes;\n  }\n\n  // Query audit logs\n  async getAuditLogs(filter: AuditLogFilter = {}): Promise<{\n    logs: any[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const where: any = {};\n    \n    if (filter.action) where.action = filter.action;\n    if (filter.entityType) where.entityType = filter.entityType;\n    if (filter.entityId) where.entityId = filter.entityId;\n    if (filter.userId) where.userId = filter.userId;\n    if (filter.merchantId) where.merchantId = filter.merchantId;\n    if (filter.outletId) where.outletId = filter.outletId;\n    if (filter.severity) where.severity = filter.severity;\n    if (filter.category) where.category = filter.category;\n    \n    if (filter.startDate || filter.endDate) {\n      where.createdAt = {};\n      if (filter.startDate) where.createdAt.gte = filter.startDate;\n      if (filter.endDate) where.createdAt.lte = filter.endDate;\n    }\n\n    const limit = filter.limit || 50;\n    const offset = filter.offset || 0;\n\n    // Temporarily disabled - AuditLog model not in schema\n    const logs: any[] = [];\n    const total = 0;\n\n    // Transform logs to include parsed JSON fields\n    const transformedLogs = logs.map(log => ({\n      id: log.id,\n      action: log.action,\n      entityType: log.entityType,\n      entityId: log.entityId,\n      entityName: log.entityName,\n      user: log.user ? {\n        id: log.user.id,\n        email: log.user.email,\n        name: `${log.user.firstName} ${log.user.lastName}`,\n        role: log.user.role\n      } : null,\n      merchant: log.merchant ? {\n        id: log.merchant.id,\n        name: log.merchant.name\n      } : null,\n      outlet: log.outlet ? {\n        id: log.outlet.id,\n        name: log.outlet.name\n      } : null,\n      oldValues: log.oldValues ? JSON.parse(log.oldValues) : null,\n      newValues: log.newValues ? JSON.parse(log.newValues) : null,\n      changes: log.changes ? JSON.parse(log.changes) : null,\n      ipAddress: log.ipAddress,\n      userAgent: log.userAgent,\n      sessionId: log.sessionId,\n      requestId: log.requestId,\n      metadata: log.metadata ? JSON.parse(log.metadata) : null,\n      severity: log.severity,\n      category: log.category,\n      description: log.description,\n      createdAt: log.createdAt\n    }));\n\n    return {\n      logs: transformedLogs,\n      total,\n      hasMore: offset + limit < total\n    };\n  }\n\n  // Get audit statistics\n  async getAuditStats(filter: Partial<AuditLogFilter> = {}): Promise<{\n    totalLogs: number;\n    logsByAction: Record<string, number>;\n    logsByEntity: Record<string, number>;\n    logsBySeverity: Record<string, number>;\n    logsByCategory: Record<string, number>;\n    recentActivity: number; // Last 24 hours\n  }> {\n    const where: any = {};\n    \n    if (filter.merchantId) where.merchantId = filter.merchantId;\n    if (filter.outletId) where.outletId = filter.outletId;\n    if (filter.startDate || filter.endDate) {\n      where.createdAt = {};\n      if (filter.startDate) where.createdAt.gte = filter.startDate;\n      if (filter.endDate) where.createdAt.lte = filter.endDate;\n    }\n\n    // Temporarily disabled - AuditLog model not in schema\n    const totalLogs = 0;\n    const actionStats: any[] = [];\n    const entityStats: any[] = [];\n    const severityStats: any[] = [];\n    const categoryStats: any[] = [];\n    const recentActivity = 0;\n\n    return {\n      totalLogs,\n      logsByAction: actionStats.reduce((acc, item) => {\n        acc[item.action] = item._count.action;\n        return acc;\n      }, {} as Record<string, number>),\n      logsByEntity: entityStats.reduce((acc, item) => {\n        acc[item.entityType] = item._count.entityType;\n        return acc;\n      }, {} as Record<string, number>),\n      logsBySeverity: severityStats.reduce((acc, item) => {\n        acc[item.severity] = item._count.severity;\n        return acc;\n      }, {} as Record<string, number>),\n      logsByCategory: categoryStats.reduce((acc, item) => {\n        acc[item.category] = item._count.category;\n        return acc;\n      }, {} as Record<string, number>),\n      recentActivity\n    };\n  }\n}\n\n// Create singleton instance\nlet auditLogger: AuditLogger | null = null;\n\nexport function getAuditLogger(prisma?: PrismaClient): AuditLogger {\n  if (!auditLogger) {\n    if (!prisma) {\n      throw new Error('Prisma client is required for audit logging');\n    }\n    auditLogger = new AuditLogger(prisma);\n  }\n  return auditLogger;\n}\n\n// Helper function to extract audit context from request\nexport function extractAuditContext(request: Request, user?: any): AuditContext {\n  const headers = request.headers;\n  \n  return {\n    userId: user?.id,\n    userEmail: user?.email,\n    userRole: user?.role,\n    merchantId: user?.merchantId,\n    outletId: user?.outletId,\n    ipAddress: headers.get('x-forwarded-for') || headers.get('x-real-ip') || 'unknown',\n    userAgent: headers.get('user-agent') || 'unknown',\n    sessionId: headers.get('x-session-id') || undefined,\n    requestId: headers.get('x-request-id') || undefined,\n    metadata: {\n      method: request.method,\n      url: request.url,\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n","// ============================================================================\n// SMART REGISTRATION - HANDLES ALL USER ROLES\n// ============================================================================\n\nimport { prisma } from './client';\nimport { createUser } from './user';\nimport { createSubscription } from './subscription';\nimport { hashPassword } from '@rentalshop/auth';\nimport type { UserCreateInput } from '@rentalshop/types';\n\nexport interface RegistrationInput {\n  email: string;\n  password: string;\n  name: string;\n  phone?: string;\n  role?: 'ADMIN' | 'MERCHANT' | 'OUTLET_ADMIN' | 'OUTLET_STAFF';\n  // For merchant registration\n  businessName?: string;\n  outletName?: string;\n  // Business configuration (locked after registration)\n  businessType?: 'GENERAL' | 'VEHICLE' | 'CLOTHING' | 'EQUIPMENT';\n  pricingType?: 'FIXED' | 'HOURLY' | 'DAILY';\n  // Address fields for merchant registration\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  // For outlet staff/admin registration\n  merchantCode?: string;\n  outletCode?: string;\n}\n\nexport interface RegistrationResult {\n  success: boolean;\n  user: {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    role: string;\n    merchant?: {\n      id: number;\n      name: string;\n    };\n    outlet?: {\n      id: number;\n      name: string;\n    };\n  };\n  token: string;\n  message: string;\n}\n\n/**\n * Smart registration that handles all user roles\n * Based on role and provided data, creates appropriate account structure\n */\nexport async function registerUser(\n  data: RegistrationInput\n): Promise<RegistrationResult> {\n  try {\n    // Start transaction to ensure all operations succeed or fail together\n    const result = await prisma.$transaction(async (tx: any) => {\n      // 1. Check if user email already exists\n      const existingUser = await tx.user.findUnique({\n        where: { email: data.email }\n      });\n\n      if (existingUser) {\n        throw new Error('User with this email already exists');\n      }\n\n      // Determine registration type based on role and data\n      const registrationType = determineRegistrationType(data);\n\n      if (registrationType === 'MERCHANT') {\n        return await registerMerchant(tx, data);\n      } else if (registrationType === 'OUTLET_ADMIN' || registrationType === 'OUTLET_STAFF') {\n        return await registerOutletUser(tx, data);\n      } else {\n        return await registerBasicUser(tx, data);\n      }\n    });\n\n    return result;\n  } catch (error: any) {\n    console.error('Registration error:', error);\n    throw new Error(error.message || 'Registration failed');\n  }\n}\n\n/**\n * Determine registration type based on input data\n */\nfunction determineRegistrationType(data: RegistrationInput): 'MERCHANT' | 'OUTLET_ADMIN' | 'OUTLET_STAFF' | 'BASIC' {\n  // If role is explicitly set, use it\n  if (data.role === 'MERCHANT') {\n    return 'MERCHANT';\n  }\n  if (data.role === 'OUTLET_ADMIN' || data.role === 'OUTLET_STAFF') {\n    return data.role;\n  }\n\n  // If businessName is provided, assume merchant registration\n  if (data.businessName) {\n    return 'MERCHANT';\n  }\n\n  // If merchantCode is provided, assume outlet user registration\n  if (data.merchantCode) {\n    return 'OUTLET_STAFF'; // Default to staff, can be upgraded to admin\n  }\n\n  // Default to basic user registration\n  return 'BASIC';\n}\n\n/**\n * Register merchant with auto-created default outlet\n */\nasync function registerMerchant(tx: any, data: RegistrationInput) {\n  // 1. Check if merchant email already exists\n  const existingMerchant = await tx.merchant.findUnique({\n    where: { email: data.email }\n  });\n\n  if (existingMerchant) {\n    throw new Error('Merchant with this email already exists');\n  }\n\n  // 2. Get or create trial plan (modern SaaS pattern)\n  let trialPlan = await tx.plan.findFirst({\n    where: { \n      name: 'Trial',\n      isActive: true \n    }\n  });\n\n  if (!trialPlan) {\n    // Auto-create trial plan if none exists (modern SaaS pattern)\n    console.log('Creating trial plan automatically...');\n    \n    trialPlan = await tx.plan.create({\n      data: {\n        name: 'Trial',\n        description: 'Free trial plan for new merchants to test the platform',\n        basePrice: 0, // Free\n        currency: 'USD',\n        trialDays: 14,\n        limits: JSON.stringify({\n          outlets: 1,\n          users: 2,\n          products: 25,\n          customers: 50\n        }),\n        features: JSON.stringify([\n          'Basic inventory management',\n          'Customer management',\n          'Order processing (limited)',\n          'Basic reporting',\n          'Email support',\n          'Mobile app access',\n          '14-day free trial'\n        ]),\n        isActive: true,\n        isPopular: false,\n        sortOrder: 0 // Show first\n      }\n    });\n    console.log('‚úÖ Trial plan created automatically');\n  }\n\n  // 3. Create merchant (let DB autoincrement id)\n  const merchant = await tx.merchant.create({\n    data: {\n      name: data.businessName || `${data.name}'s Business`,\n      email: data.email,\n      phone: data.phone,\n      address: data.address,\n      city: data.city,\n      state: data.state,\n      zipCode: data.zipCode,\n      country: data.country,\n      isActive: true\n      // subscriptionStatus removed - will be set in subscription.status\n    }\n  });\n\n  // 4. Create default outlet with merchant information FIRST\n  const outlet = await tx.outlet.create({\n    data: {\n      name: data.outletName || 'Main Store',\n      // Always use merchant's information as primary source, with user input as fallback\n      address: merchant.address || data.address || 'Address to be updated',\n      phone: merchant.phone || data.phone,\n      city: merchant.city || data.city,\n      state: merchant.state || data.state,\n      zipCode: merchant.zipCode || data.zipCode,\n      country: merchant.country || data.country,\n      description: 'Default outlet created during registration',\n      merchantId: merchant.id,\n      isActive: true,\n      isDefault: true\n    }\n  });\n\n  // 5. Create default category for merchant\n  const defaultCategory = await tx.category.create({\n    data: {\n      name: 'General',\n      description: 'Default category for general products',\n      merchantId: merchant.id,\n      isActive: true\n    }\n  });\n\n  // 6. Create merchant user with outlet assignment\n  const hashedPassword = await hashPassword(data.password);\n  const user = await tx.user.create({\n    data: {\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: 'MERCHANT',\n      merchantId: merchant.id,\n      outletId: outlet.id, // Assign default outlet to merchant user\n      isActive: true,\n      emailVerified: false, // Email needs to be verified after registration\n      emailVerifiedAt: null\n    }\n  });\n\n  // 7. Create trial subscription\n  const subscriptionStartDate = new Date();\n  const endDate = new Date(subscriptionStartDate.getTime() + (trialPlan.trialDays * 24 * 60 * 60 * 1000));\n  const subscription = await tx.subscription.create({\n    data: {\n      merchantId: merchant.id,\n      planId: trialPlan.id,\n      status: 'trial',\n      amount: 0, // Free trial\n      currency: 'USD',\n      interval: 'month', // Default to monthly for trial\n      intervalCount: 1, // 1 month intervals\n      currentPeriodStart: subscriptionStartDate,\n      currentPeriodEnd: endDate,\n      trialStart: subscriptionStartDate,\n      trialEnd: endDate,\n      cancelAtPeriodEnd: false\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n      merchant: {\n        id: merchant.id,\n        name: merchant.name\n      },\n      outlet: {\n        id: outlet.id,\n        name: outlet.name\n      }\n    },\n    token: '', // Will be generated by auth service\n    message: 'Merchant account created successfully with default outlet'\n  };\n}\n\n/**\n * Register merchant with trial plan (wrapper function for API)\n */\nexport async function registerMerchantWithTrial(data: any) {\n  // Transform API data to RegistrationInput format\n  const registrationData: RegistrationInput = {\n    email: data.userEmail,\n    password: data.userPassword,\n    name: `${data.userFirstName} ${data.userLastName}`,\n    phone: data.userPhone,\n    role: 'MERCHANT',\n    businessName: data.merchantName,\n    outletName: data.outletName,\n    address: data.outletAddress\n  };\n\n  const result = await registerUser(registrationData);\n  \n  if (!result.success) {\n    throw new Error(result.message);\n  }\n\n  // Transform result to match expected API format\n  return {\n    merchant: {\n      id: result.user.merchant?.id,\n      name: result.user.merchant?.name,\n      email: result.user.email\n    },\n    user: {\n      id: result.user.id,\n      email: result.user.email,\n      firstName: result.user.firstName,\n      lastName: result.user.lastName,\n      role: result.user.role\n    },\n    outlet: {\n      id: result.user.outlet?.id,\n      name: result.user.outlet?.name\n    },\n    subscription: {\n      planName: 'Trial',\n      trialEnd: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000) // 14 days from now\n    }\n  };\n}\n\n/**\n * Register outlet admin/staff with merchant/outlet lookup\n */\nasync function registerOutletUser(tx: any, data: RegistrationInput) {\n  if (!data.merchantCode) {\n    throw new Error('Merchant code is required for outlet user registration');\n  }\n\n  // 1. Find merchant by code (assuming merchantCode is the merchant's id)\n  const merchant = await tx.merchant.findUnique({\n    where: { id: parseInt(data.merchantCode) }\n  });\n\n  if (!merchant) {\n    throw new Error('Invalid merchant code. Please check with your manager.');\n  }\n\n  // 2. Find outlet if outletCode provided\n  let outlet = null;\n  if (data.outletCode) {\n    outlet = await tx.outlet.findUnique({\n      where: { \n        id: parseInt(data.outletCode),\n        merchantId: merchant.id \n      }\n    });\n\n    if (!outlet) {\n      throw new Error('Invalid outlet code. Please check with your manager.');\n    }\n  } else {\n    // Find default outlet for this merchant\n    outlet = await tx.outlet.findFirst({\n      where: { \n        merchantId: merchant.id,\n        isDefault: true \n      }\n    });\n\n    if (!outlet) {\n      // Create a default outlet if none exists\n      outlet = await tx.outlet.create({\n        data: {\n          name: `${merchant.name} - Main Store`,\n          address: merchant.address || 'Address to be updated',\n          phone: merchant.phone,\n          city: merchant.city,\n          state: merchant.state,\n          zipCode: merchant.zipCode,\n          country: merchant.country,\n          description: 'Default outlet for staff',\n          merchantId: merchant.id,\n          isActive: true,\n          isDefault: true\n        }\n      });\n    }\n  }\n\n  // 3. Create outlet user\n  const hashedPassword = await hashPassword(data.password);\n  const user = await tx.user.create({\n    data: {\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: data.role || 'OUTLET_STAFF',\n      merchantId: merchant.id,\n      outletId: outlet.id,\n      isActive: true\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n      merchant: {\n        id: merchant.id,\n        name: merchant.name\n      },\n      outlet: {\n        id: outlet.id,\n        name: outlet.name\n      }\n    },\n    token: '', // Will be generated by auth service\n    message: `${data.role === 'OUTLET_ADMIN' ? 'Outlet admin' : 'Staff'} account created successfully`\n  };\n}\n\n/**\n * Register basic user (CLIENT, SHOP_OWNER, ADMIN)\n */\nasync function registerBasicUser(tx: any, data: RegistrationInput) {\n  const hashedPassword = await hashPassword(data.password);\n  const user = await tx.user.create({\n    data: {\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: data.role || 'CLIENT',\n      isActive: true\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n    },\n    token: '', // Will be generated by auth service\n    message: 'User account created successfully'\n  };\n}\n","// ============================================================================\n// EMAIL VERIFICATION DATABASE OPERATIONS\n// ============================================================================\n\nimport { prisma } from './client';\nimport { randomBytes } from 'crypto';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface EmailVerificationToken {\n  id: number;\n  userId: number;\n  token: string;\n  email: string;\n  verified: boolean;\n  verifiedAt: Date | null;\n  expiresAt: Date;\n  createdAt: Date;\n}\n\n// ============================================================================\n// EMAIL VERIFICATION OPERATIONS\n// ============================================================================\n\n/**\n * Generate a secure random token for email verification\n */\nexport function generateVerificationToken(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Create email verification record\n */\nexport async function createEmailVerification(\n  userId: number,\n  email: string,\n  expiresInHours: number = 24\n): Promise<EmailVerificationToken> {\n  const token = generateVerificationToken();\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + expiresInHours);\n\n  // Invalidate any existing unverified tokens for this user\n  // Explicitly construct data object to prevent any extra fields (like 'status') from being passed\n  const updateData: {\n    verified: boolean;\n    verifiedAt: Date;\n  } = {\n    verified: true, // Mark as used/invalid\n    verifiedAt: new Date(),\n  };\n  \n  await prisma.emailVerification.updateMany({\n    where: {\n      userId,\n      verified: false,\n      expiresAt: { gt: new Date() }, // Not expired yet\n    },\n    data: updateData,\n  });\n\n  // Create new verification token\n  const verification = await prisma.emailVerification.create({\n    data: {\n      userId,\n      token,\n      email,\n      expiresAt,\n    },\n  });\n\n  return verification;\n}\n\n/**\n * Verify email using token\n */\nexport async function verifyEmailByToken(\n  token: string\n): Promise<{ success: boolean; user?: { id: number; email: string }; error?: string }> {\n  const verification = await prisma.emailVerification.findUnique({\n    where: { token },\n    include: { user: true },\n  });\n\n  if (!verification) {\n    return {\n      success: false,\n      error: 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i',\n    };\n  }\n\n  if (verification.verified) {\n    return {\n      success: false,\n      error: 'Token ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng',\n    };\n  }\n\n  if (new Date() > verification.expiresAt) {\n    return {\n      success: false,\n      error: 'Token ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu g·ª≠i l·∫°i email x√°c th·ª±c',\n    };\n  }\n\n  // Update verification record\n  await prisma.emailVerification.update({\n    where: { id: verification.id },\n    data: {\n      verified: true,\n      verifiedAt: new Date(),\n    },\n  });\n\n  // Update user email verified status\n  const user = await prisma.user.update({\n    where: { id: verification.userId },\n    data: {\n      emailVerified: true,\n      emailVerifiedAt: new Date(),\n    } as any,\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n    },\n  };\n}\n\n/**\n * Get verification token by userId\n */\nexport async function getVerificationTokenByUserId(\n  userId: number\n): Promise<EmailVerificationToken | null> {\n  const verification = await prisma.emailVerification.findFirst({\n    where: {\n      userId,\n      verified: false,\n      expiresAt: { gt: new Date() }, // Not expired\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  return verification;\n}\n\n/**\n * Resend verification email (create new token)\n */\nexport async function resendVerificationToken(\n  userId: number,\n  email: string\n): Promise<EmailVerificationToken> {\n  return await createEmailVerification(userId, email);\n}\n\n/**\n * Check if user's email is verified\n */\nexport async function isEmailVerified(userId: number): Promise<boolean> {\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: { emailVerified: true } as any,\n  });\n\n  return (user as any)?.emailVerified || false;\n}\n\n/**\n * Delete expired verification tokens (cleanup job)\n */\nexport async function deleteExpiredTokens(): Promise<number> {\n  const result = await prisma.emailVerification.deleteMany({\n    where: {\n      expiresAt: { lt: new Date() },\n      verified: false,\n    },\n  });\n\n  return result.count;\n}\n\n","// ============================================================================\n// PASSWORD RESET DATABASE OPERATIONS\n// ============================================================================\n\nimport { prisma } from './client';\nimport { randomBytes } from 'crypto';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface PasswordResetToken {\n  id: number;\n  userId: number;\n  token: string;\n  email: string;\n  used: boolean;\n  usedAt: Date | null;\n  expiresAt: Date;\n  createdAt: Date;\n}\n\n// ============================================================================\n// PASSWORD RESET OPERATIONS\n// ============================================================================\n\n/**\n * Generate a secure random token for password reset\n */\nexport function generatePasswordResetToken(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Create password reset record\n */\nexport async function createPasswordResetToken(\n  userId: number,\n  email: string,\n  expiresInHours: number = 24\n): Promise<PasswordResetToken> {\n  const token = generatePasswordResetToken();\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + expiresInHours);\n\n  // Invalidate any existing unused tokens for this user\n  await prisma.passwordReset.updateMany({\n    where: {\n      userId,\n      used: false,\n      expiresAt: { gt: new Date() }, // Not expired yet\n    },\n    data: {\n      used: true, // Mark as used/invalid\n      usedAt: new Date(),\n    },\n  });\n\n  // Create new password reset token\n  const passwordReset = await prisma.passwordReset.create({\n    data: {\n      userId,\n      token,\n      email,\n      expiresAt,\n    },\n  });\n\n  return passwordReset;\n}\n\n/**\n * Verify password reset token\n */\nexport async function verifyPasswordResetToken(\n  token: string\n): Promise<{ success: boolean; user?: { id: number; email: string }; error?: string }> {\n  const passwordReset = await prisma.passwordReset.findUnique({\n    where: { token },\n    include: { user: true },\n  });\n\n  if (!passwordReset) {\n    return {\n      success: false,\n      error: 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c kh√¥ng t·ªìn t·∫°i',\n    };\n  }\n\n  if (passwordReset.used) {\n    return {\n      success: false,\n      error: 'Token ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng',\n    };\n  }\n\n  if (new Date() > passwordReset.expiresAt) {\n    return {\n      success: false,\n      error: 'Token ƒë√£ h·∫øt h·∫°n. Vui l√≤ng y√™u c·∫ßu g·ª≠i l·∫°i email ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u',\n    };\n  }\n\n  return {\n    success: true,\n    user: {\n      id: passwordReset.userId,\n      email: passwordReset.email,\n    },\n  };\n}\n\n/**\n * Mark password reset token as used\n */\nexport async function markTokenAsUsed(token: string): Promise<void> {\n  await prisma.passwordReset.update({\n    where: { token },\n    data: {\n      used: true,\n      usedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Get password reset token by userId\n */\nexport async function getPasswordResetTokenByUserId(\n  userId: number\n): Promise<PasswordResetToken | null> {\n  const passwordReset = await prisma.passwordReset.findFirst({\n    where: {\n      userId,\n      used: false,\n      expiresAt: { gt: new Date() }, // Not expired\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  return passwordReset;\n}\n\n/**\n * Delete expired password reset tokens (cleanup job)\n */\nexport async function deleteExpiredPasswordResetTokens(): Promise<number> {\n  const result = await prisma.passwordReset.deleteMany({\n    where: {\n      expiresAt: { lt: new Date() },\n      used: false,\n    },\n  });\n\n  return result.count;\n}\n\n","/**\n * Query Builder Helper\n * Simplifies common database query patterns (pagination, sorting, filtering)\n */\n\nimport { prisma } from './client';\nimport { removeVietnameseDiacritics } from '@rentalshop/utils';\n\nexport interface QueryOptions {\n  page?: number;\n  limit?: number;\n  offset?: number;\n  sortBy?: string;\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface SearchOptions extends QueryOptions {\n  search?: string;\n  searchFields?: string[];\n}\n\n/**\n * Calculate skip value from page/offset\n */\nexport function calculateSkip(page?: number, limit: number = 20, offset?: number): number {\n  if (offset !== undefined) return offset;\n  return ((page || 1) - 1) * limit;\n}\n\n/**\n * Build orderBy clause from sort options\n */\nexport function buildOrderBy(\n  sortBy?: string,\n  sortOrder: 'asc' | 'desc' = 'desc',\n  validFields: string[] = ['createdAt']\n): any {\n  const field = validFields.includes(sortBy || '') ? (sortBy || validFields[0]) : (validFields[0] || 'createdAt');\n  return { [field]: sortOrder };\n}\n\n/**\n * Build search where clause (case-insensitive and diacritics-insensitive contains)\n */\nexport function buildSearchWhere(\n  search?: string,\n  searchFields: string[] = ['name']\n): any {\n  if (!search || !search.trim()) return undefined;\n\n  const searchTerm = search.trim();\n  const normalizedTerm = removeVietnameseDiacritics(searchTerm);\n  \n  if (searchFields.length === 1) {\n    const conditions: any[] = [\n      { [searchFields[0]]: { contains: searchTerm, mode: 'insensitive' } }\n    ];\n    \n    // Add normalized search if different from original\n    if (normalizedTerm !== searchTerm) {\n      conditions.push({\n        [searchFields[0]]: { contains: normalizedTerm, mode: 'insensitive' }\n      });\n  }\n\n    return conditions.length === 1 ? conditions[0] : { OR: conditions };\n  }\n\n  const conditions: any[] = searchFields.map(field => ({\n      [field]: { contains: searchTerm, mode: 'insensitive' }\n  }));\n  \n  // Add normalized search if different from original\n  if (normalizedTerm !== searchTerm) {\n    conditions.push(...searchFields.map(field => ({\n      [field]: { contains: normalizedTerm, mode: 'insensitive' }\n    })));\n  }\n\n  return { OR: conditions };\n}\n\n/**\n * Build exact match where clause (for barcode, etc.)\n */\nexport function buildExactMatchWhere(field: string, value: any): any {\n  if (value === undefined || value === null) return undefined;\n  return { [field]: { equals: value } };\n}\n\n/**\n * Build range where clause (for numbers, dates)\n */\nexport function buildRangeWhere(\n  field: string,\n  min?: number | Date,\n  max?: number | Date\n): any {\n  if (min === undefined && max === undefined) return undefined;\n  \n  const range: any = {};\n  if (min !== undefined) range.gte = min;\n  if (max !== undefined) range.lte = max;\n  \n  return { [field]: range };\n}\n\n/**\n * Convert public ID to CUID for a model\n * Helper for dual ID system\n */\nexport async function convertPublicIdToCuid(\n  model: string,\n  publicId: number\n): Promise<string | null> {\n  try {\n    const record = await (prisma as any)[model].findUnique({\n      where: { id: publicId },\n      select: { id: true }\n    });\n    return record?.id || null;\n  } catch (error) {\n    console.error(`Error converting public ID to CUID for ${model}:`, error);\n    return null;\n  }\n}\n\n/**\n * Build where clause with merchant isolation (dual ID system)\n */\nexport async function buildMerchantWhere(\n  merchantId?: number,\n  where: any = {}\n): Promise<any> {\n  if (!merchantId) return where;\n  \n  const merchantCuid = await convertPublicIdToCuid('merchant', merchantId);\n  if (merchantCuid) {\n    where.merchantId = merchantCuid;\n  }\n  \n  return where;\n}\n\n/**\n * Build where clause with outlet filter (dual ID system)\n */\nexport async function buildOutletWhere(\n  outletId?: number,\n  where: any = {}\n): Promise<any> {\n  if (!outletId) return where;\n  \n  const outletCuid = await convertPublicIdToCuid('outlet', outletId);\n  if (outletCuid) {\n    where.outletId = outletCuid;\n  }\n  \n  return where;\n}\n\n/**\n * Generic search function builder\n * Creates a reusable search function for any model\n */\nexport function createSearchFunction<T extends { id: any }>(config: {\n  model: string;\n  validSortFields: string[];\n  defaultSortField?: string;\n  searchFields?: string[];\n  include?: any;\n  select?: any;\n}) {\n  return async (filters: SearchOptions & Record<string, any>) => {\n    const {\n      page = 1,\n      limit = 20,\n      offset,\n      sortBy,\n      sortOrder = 'desc',\n      search,\n      ...otherFilters\n    } = filters;\n\n    const skip = calculateSkip(page, limit, offset);\n    const orderBy = buildOrderBy(\n      sortBy,\n      sortOrder,\n      config.validSortFields\n    );\n\n    // Build where clause\n    const where: any = { ...otherFilters };\n\n    // Add search if provided\n    if (search && config.searchFields) {\n      const searchWhere = buildSearchWhere(search, config.searchFields);\n      if (searchWhere) {\n        Object.assign(where, searchWhere);\n      }\n    }\n\n    // Execute query\n    const [data, total] = await Promise.all([\n      (prisma as any)[config.model].findMany({\n        where,\n        ...(config.include ? { include: config.include } : {}),\n        ...(config.select ? { select: config.select } : {}),\n        orderBy,\n        skip,\n        take: limit\n      }),\n      (prisma as any)[config.model].count({ where })\n    ]);\n\n    return {\n      data,\n      total,\n      page: offset !== undefined ? Math.floor(offset / limit) + 1 : page,\n      limit,\n      offset: skip,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  };\n}\n\n\n"],"mappings":"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","names":["search","import_utils","generateOrderNumber","import_utils","import_utils","updateOutletStockForOrder","search","import_utils","import_utils","import_utils","import_utils","findById","search","randomBytes","count","count","findById","findFirst","create","update","search","getStats","findMany","getStats","findFirst","create","findMany","getStats","findFirst","create","update","prisma","import_crypto","import_crypto","import_utils","search","conditions","generateOrderNumber"]}