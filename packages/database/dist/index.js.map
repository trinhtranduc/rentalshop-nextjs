{"version":3,"sources":["../src/main-db.ts","../src/tenant-db.ts","../src/subdomain-utils.ts","../src/index.ts","../src/client.ts","../src/user.ts","../src/customer.ts","../src/product.ts","../src/order.ts","../src/payment.ts","../src/outlet.ts","../src/plan.ts","../src/subscription.ts","../src/subscription-activity.ts","../src/order-number-generator.ts","../src/category.ts","../src/audit-logs.ts","../src/order-items.ts","../src/sessions.ts","../src/audit.ts","../src/registration.ts","../src/email-verification.ts"],"sourcesContent":["import { Client } from 'pg';\n\n// âœ… Raw SQL queries ONLY for Main DB\n// NO Prisma client generation - avoids conflicts\n\n/**\n * Get Main DB client connection\n */\nexport async function getMainDbClient(): Promise<Client> {\n  if (!process.env.MAIN_DATABASE_URL) {\n    throw new Error('MAIN_DATABASE_URL environment variable is required');\n  }\n  \n  const url = new URL(process.env.MAIN_DATABASE_URL);\n  const client = new Client({\n    host: url.hostname,\n    port: parseInt(url.port || '5432'),\n    user: url.username,\n    password: url.password,\n    database: url.pathname.slice(1)\n  });\n  await client.connect();\n  return client;\n}\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface Tenant {\n  id: string;\n  subdomain: string;\n  name: string;\n  email: string;\n  phone: string | null;\n  address: string | null;\n  city: string | null;\n  state: string | null;\n  zipCode: string | null;\n  country: string | null;\n  taxId: string | null;\n  businessType: string | null;\n  website: string | null;\n  description: string | null;\n  databaseUrl: string;\n  status: string;\n  planId: number | null;\n  subscriptionStatus: string | null;\n  currentPeriodStart: Date | null;\n  currentPeriodEnd: Date | null;\n  trialStart: Date | null;\n  trialEnd: Date | null;\n  canceledAt: Date | null;\n  cancelReason: string | null;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Plan {\n  id: number;\n  name: string;\n  description: string;\n  basePrice: number;\n  currency: string;\n  trialDays: number;\n  limits: string;\n  features: string;\n  isActive: boolean;\n  isPopular: boolean;\n  sortOrder: number;\n  createdAt: Date;\n  updatedAt: Date;\n  deletedAt: Date | null;\n}\n\n// ============================================================================\n// TENANT OPERATIONS\n// ============================================================================\n\n/**\n * Get tenant by subdomain\n */\nexport async function getTenantBySubdomain(subdomain: string): Promise<Tenant | null> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      `SELECT id, subdomain, name, email, phone, address, city, state, \"zipCode\", country, \n              \"taxId\", \"businessType\", website, description, \"databaseUrl\", status, \n              \"planId\", \"subscriptionStatus\", \"currentPeriodStart\", \"currentPeriodEnd\", \n              \"trialStart\", \"trialEnd\", \"canceledAt\", \"cancelReason\", \"createdAt\", \"updatedAt\" \n       FROM \"Tenant\" WHERE subdomain = $1`,\n      [subdomain]\n    );\n    if (result.rows.length === 0) return null;\n    return result.rows[0] as Tenant;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * Get tenant by ID\n */\nexport async function getTenantById(id: string): Promise<Tenant | null> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      `SELECT id, subdomain, name, email, phone, address, city, state, \"zipCode\", country, \n              \"taxId\", \"businessType\", website, description, \"databaseUrl\", status, \n              \"planId\", \"subscriptionStatus\", \"currentPeriodStart\", \"currentPeriodEnd\", \n              \"trialStart\", \"trialEnd\", \"canceledAt\", \"cancelReason\", \"createdAt\", \"updatedAt\" \n       FROM \"Tenant\" WHERE id = $1`,\n      [id]\n    );\n    if (result.rows.length === 0) return null;\n    return result.rows[0] as Tenant;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * Check if subdomain exists\n */\nexport async function subdomainExists(subdomain: string): Promise<boolean> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      'SELECT 1 FROM \"Tenant\" WHERE subdomain = $1 LIMIT 1',\n      [subdomain]\n    );\n    return result.rows.length > 0;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * Check if email exists\n */\nexport async function tenantEmailExists(email: string): Promise<boolean> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      'SELECT 1 FROM \"Tenant\" WHERE email = $1 LIMIT 1',\n      [email]\n    );\n    return result.rows.length > 0;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * Create tenant\n */\nexport async function createTenant(data: {\n  id?: string;\n  subdomain: string;\n  name: string;\n  email: string;\n  phone?: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  taxId?: string;\n  businessType?: string;\n  website?: string;\n  description?: string;\n  databaseUrl: string;\n  status?: string;\n  planId?: number;\n  subscriptionStatus?: string;\n  trialStart?: Date;\n  trialEnd?: Date;\n}): Promise<Tenant> {\n  const client = await getMainDbClient();\n  try {\n    // Generate CUID-like ID if not provided\n    const id = data.id || `tenant_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const result = await client.query(\n      `INSERT INTO \"Tenant\" (\n        id, subdomain, name, email, phone, address, city, state, \"zipCode\", country,\n        \"taxId\", \"businessType\", website, description, \"databaseUrl\", status,\n        \"planId\", \"subscriptionStatus\", \"trialStart\", \"trialEnd\", \"createdAt\", \"updatedAt\"\n      ) VALUES (\n        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, NOW(), NOW()\n      ) RETURNING *`,\n      [\n        id,\n        data.subdomain,\n        data.name,\n        data.email,\n        data.phone || null,\n        data.address || null,\n        data.city || null,\n        data.state || null,\n        data.zipCode || null,\n        data.country || null,\n        data.taxId || null,\n        data.businessType || null,\n        data.website || null,\n        data.description || null,\n        data.databaseUrl,\n        data.status || 'active',\n        data.planId || null,\n        data.subscriptionStatus || 'trial',\n        data.trialStart || null,\n        data.trialEnd || null\n      ]\n    );\n    return result.rows[0] as Tenant;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * Update tenant\n */\nexport async function updateTenant(id: string, data: Partial<Tenant>): Promise<Tenant> {\n  const client = await getMainDbClient();\n  try {\n    const updates: string[] = [];\n    const values: any[] = [];\n    let paramIndex = 1;\n\n    // Basic info\n    if (data.name !== undefined) {\n      updates.push(`name = $${paramIndex++}`);\n      values.push(data.name);\n    }\n    if (data.email !== undefined) {\n      updates.push(`email = $${paramIndex++}`);\n      values.push(data.email);\n    }\n    if (data.phone !== undefined) {\n      updates.push(`phone = $${paramIndex++}`);\n      values.push(data.phone);\n    }\n\n    // Address fields\n    if (data.address !== undefined) {\n      updates.push(`address = $${paramIndex++}`);\n      values.push(data.address);\n    }\n    if (data.city !== undefined) {\n      updates.push(`city = $${paramIndex++}`);\n      values.push(data.city);\n    }\n    if (data.state !== undefined) {\n      updates.push(`state = $${paramIndex++}`);\n      values.push(data.state);\n    }\n    if (data.zipCode !== undefined) {\n      updates.push(`\"zipCode\" = $${paramIndex++}`);\n      values.push(data.zipCode);\n    }\n    if (data.country !== undefined) {\n      updates.push(`country = $${paramIndex++}`);\n      values.push(data.country);\n    }\n\n    // Business fields\n    if (data.taxId !== undefined) {\n      updates.push(`\"taxId\" = $${paramIndex++}`);\n      values.push(data.taxId);\n    }\n    if (data.businessType !== undefined) {\n      updates.push(`\"businessType\" = $${paramIndex++}`);\n      values.push(data.businessType);\n    }\n    if (data.website !== undefined) {\n      updates.push(`website = $${paramIndex++}`);\n      values.push(data.website);\n    }\n    if (data.description !== undefined) {\n      updates.push(`description = $${paramIndex++}`);\n      values.push(data.description);\n    }\n\n    // Status fields\n    if (data.status !== undefined) {\n      updates.push(`status = $${paramIndex++}`);\n      values.push(data.status);\n    }\n    if (data.subscriptionStatus !== undefined) {\n      updates.push(`\"subscriptionStatus\" = $${paramIndex++}`);\n      values.push(data.subscriptionStatus);\n    }\n\n    // Plan and subscription dates\n    if (data.planId !== undefined) {\n      updates.push(`\"planId\" = $${paramIndex++}`);\n      values.push(data.planId);\n    }\n    if (data.currentPeriodStart !== undefined) {\n      updates.push(`\"currentPeriodStart\" = $${paramIndex++}`);\n      values.push(data.currentPeriodStart);\n    }\n    if (data.currentPeriodEnd !== undefined) {\n      updates.push(`\"currentPeriodEnd\" = $${paramIndex++}`);\n      values.push(data.currentPeriodEnd);\n    }\n    if (data.trialStart !== undefined) {\n      updates.push(`\"trialStart\" = $${paramIndex++}`);\n      values.push(data.trialStart);\n    }\n    if (data.trialEnd !== undefined) {\n      updates.push(`\"trialEnd\" = $${paramIndex++}`);\n      values.push(data.trialEnd);\n    }\n    if (data.canceledAt !== undefined) {\n      updates.push(`\"canceledAt\" = $${paramIndex++}`);\n      values.push(data.canceledAt);\n    }\n    if (data.cancelReason !== undefined) {\n      updates.push(`\"cancelReason\" = $${paramIndex++}`);\n      values.push(data.cancelReason);\n    }\n    \n    // Always update updatedAt\n    updates.push(`\"updatedAt\" = NOW()`);\n    values.push(id);\n\n    // Check if there are any updates\n    if (updates.length === 1) {\n      // Only updatedAt, no actual updates\n      throw new Error('No fields to update');\n    }\n\n    const result = await client.query(\n      `UPDATE \"Tenant\" SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\n      values\n    );\n    \n    if (result.rows.length === 0) {\n      throw new Error(`Tenant with id ${id} not found`);\n    }\n    \n    return result.rows[0] as Tenant;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * List all tenants\n */\nexport async function listAllTenants(filters?: {\n  status?: string;\n  planId?: number;\n  limit?: number;\n  offset?: number;\n}): Promise<{ tenants: Tenant[]; total: number }> {\n  const client = await getMainDbClient();\n  try {\n    const where: string[] = [];\n    const values: any[] = [];\n    let paramIndex = 1;\n\n    if (filters?.status) {\n      where.push(`status = $${paramIndex++}`);\n      values.push(filters.status);\n    }\n    if (filters?.planId) {\n      where.push(`\"planId\" = $${paramIndex++}`);\n      values.push(filters.planId);\n    }\n\n    const whereClause = where.length > 0 ? `WHERE ${where.join(' AND ')}` : '';\n    \n    // Get total count\n    const countResult = await client.query(\n      `SELECT COUNT(*) as total FROM \"Tenant\" ${whereClause}`,\n      values\n    );\n    const total = parseInt(countResult.rows[0].total);\n\n    // Get tenants\n    const limit = filters?.limit || 50;\n    const offset = filters?.offset || 0;\n    values.push(limit, offset);\n    \n    const result = await client.query(\n      `SELECT * FROM \"Tenant\" ${whereClause} ORDER BY \"createdAt\" DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,\n      values\n    );\n\n    return {\n      tenants: result.rows as Tenant[],\n      total\n    };\n  } finally {\n    await client.end();\n  }\n}\n\n// ============================================================================\n// PLAN OPERATIONS\n// ============================================================================\n\n/**\n * Get plan by ID\n */\nexport async function getPlanById(id: number): Promise<Plan | null> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      'SELECT * FROM \"Plan\" WHERE id = $1 AND \"deletedAt\" IS NULL',\n      [id]\n    );\n    if (result.rows.length === 0) return null;\n    return result.rows[0] as Plan;\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * List all active plans\n */\nexport async function listActivePlans(): Promise<Plan[]> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      'SELECT * FROM \"Plan\" WHERE \"isActive\" = true AND \"deletedAt\" IS NULL ORDER BY \"sortOrder\" ASC, \"basePrice\" ASC'\n    );\n    return result.rows as Plan[];\n  } finally {\n    await client.end();\n  }\n}\n\n/**\n * Get default plan (lowest price active plan)\n */\nexport async function getDefaultPlan(): Promise<Plan | null> {\n  const client = await getMainDbClient();\n  try {\n    const result = await client.query(\n      'SELECT * FROM \"Plan\" WHERE \"isActive\" = true AND \"deletedAt\" IS NULL ORDER BY \"basePrice\" ASC LIMIT 1'\n    );\n    if (result.rows.length === 0) return null;\n    return result.rows[0] as Plan;\n  } finally {\n    await client.end();\n  }\n}\n","import { PrismaClient } from '@prisma/client';\nimport { getTenantBySubdomain } from './main-db';\nimport { Client } from 'pg';\nimport path from 'path';\nimport fs from 'fs';\n\n// âœ… In-memory cache for tenant Prisma clients\nconst tenantClients = new Map<string, PrismaClient>();\n\n/**\n * Get tenant DB connection (with caching)\n * Creates Prisma client connected to tenant's isolated database\n */\nexport async function getTenantDb(subdomain: string): Promise<PrismaClient> {\n  // Check cache first\n  if (tenantClients.has(subdomain)) {\n    return tenantClients.get(subdomain)!;\n  }\n  \n  // Get tenant info from Main DB (raw SQL)\n  const tenant = await getTenantBySubdomain(subdomain);\n  \n  if (!tenant || tenant.status !== 'active') {\n    throw new Error(`Tenant not found or inactive: ${subdomain}`);\n  }\n  \n  // Create Prisma client with tenant's database URL\n  const client = new PrismaClient({\n    datasources: { \n      db: { url: tenant.databaseUrl } \n    },\n    log: process.env.NODE_ENV === 'development' ? ['error', 'warn'] : ['error']\n  });\n  \n  // Cache for future requests\n  tenantClients.set(subdomain, client);\n  \n  return client;\n}\n\n/**\n * Create new tenant database\n * Creates isolated PostgreSQL database and runs Prisma migrations\n */\nexport async function createTenantDatabase(\n  subdomain: string\n): Promise<string> {\n  if (!process.env.MAIN_DATABASE_URL) {\n    throw new Error('MAIN_DATABASE_URL environment variable is required');\n  }\n  \n  const dbName = `${subdomain.replace(/-/g, '_')}_db`;\n  const mainDbUrl = process.env.MAIN_DATABASE_URL;\n  \n  const url = new URL(mainDbUrl);\n  \n  // Connect to PostgreSQL to create new database\n  const adminClient = new Client({\n    host: url.hostname,\n    port: parseInt(url.port || '5432'),\n    user: url.username,\n    password: url.password,\n    database: url.pathname.slice(1)\n  });\n  \n  await adminClient.connect();\n  \n  try {\n    // Drop if exists (for clean slate during development)\n    if (process.env.NODE_ENV === 'development') {\n      await adminClient.query(`DROP DATABASE IF EXISTS \"${dbName}\"`);\n    } else {\n      // In production, check if exists first\n      const existsResult = await adminClient.query(\n        `SELECT 1 FROM pg_database WHERE datname = $1`,\n        [dbName]\n      );\n      if (existsResult.rows.length > 0) {\n        throw new Error(`Database ${dbName} already exists`);\n      }\n    }\n    \n    // Create new database\n    await adminClient.query(`CREATE DATABASE \"${dbName}\"`);\n    \n    console.log(`âœ… Created database: ${dbName}`);\n    \n    // Build tenant database URL\n    const tenantDbUrl = `postgresql://${url.username}:${url.password}@${url.hostname}:${url.port}/${dbName}`;\n    \n    // Run migrations on tenant database\n    const { execSync } = require('child_process');\n    \n    // Find workspace root by looking for prisma/schema.prisma\n    // Start from current working directory and walk up\n    let rootDir = process.cwd();\n    while (rootDir !== path.dirname(rootDir)) {\n      const schemaPath = path.join(rootDir, 'prisma', 'schema.prisma');\n      if (fs.existsSync(schemaPath)) {\n        break;\n      }\n      rootDir = path.dirname(rootDir);\n    }\n    \n    const prismaSchemaPath = path.join(rootDir, 'prisma', 'schema.prisma');\n    \n    if (!fs.existsSync(prismaSchemaPath)) {\n      throw new Error(`Prisma schema not found at ${prismaSchemaPath}`);\n    }\n    \n    // Run db push to create schema (skip generate since client is already generated)\n    execSync(`npx prisma db push --schema=\"${prismaSchemaPath}\" --skip-generate`, {\n      stdio: 'inherit',\n      env: { \n        ...process.env, \n        DATABASE_URL: tenantDbUrl \n      },\n      cwd: rootDir\n    });\n    \n    console.log(`âœ… Migrated database: ${dbName}`);\n    \n    return tenantDbUrl;\n  } finally {\n    await adminClient.end();\n  }\n}\n\n/**\n * Clear tenant cache (useful for testing or when tenant DB changes)\n */\nexport function clearTenantCache(subdomain?: string) {\n  if (subdomain) {\n    const client = tenantClients.get(subdomain);\n    if (client) {\n      client.$disconnect().catch(console.error);\n      tenantClients.delete(subdomain);\n    }\n  } else {\n    // Clear all cached clients\n    for (const client of tenantClients.values()) {\n      client.$disconnect().catch(console.error);\n    }\n    tenantClients.clear();\n  }\n}\n\n/**\n * Get all cached tenant subdomains\n */\nexport function getCachedTenants(): string[] {\n  return Array.from(tenantClients.keys());\n}\n","/**\n * Subdomain utilities for multi-tenant routing\n */\n\n/**\n * Reserved subdomains that cannot be used\n */\nconst RESERVED_SUBDOMAINS = ['www', 'api', 'admin', 'app', 'mail', 'ftp', 'smtp', 'client', 'www2', 'test', 'demo', 'staging'];\n\n/**\n * Convert Vietnamese characters with diacritics to ASCII without diacritics\n * Ã¡, Ã , áº£, Ã£, áº¡, Äƒ, áº±, áº¯, áº³, áºµ, áº·, Ã¢, áº§, áº¥, áº©, áº«, áº­ â†’ a\n * Ä‘ â†’ d\n * Ã©, Ã¨, áº», áº½, áº¹, Ãª, á», áº¿, á»ƒ, á»…, á»‡ â†’ e\n * Ã­, Ã¬, á»‰, Ä©, á»‹ â†’ i\n * Ã³, Ã², á», Ãµ, á», Ã´, á»“, á»‘, á»•, á»—, á»™, Æ¡, á», á»›, á»Ÿ, á»¡, á»£ â†’ o\n * Ãº, Ã¹, á»§, Å©, á»¥, Æ°, á»«, á»©, á»­, á»¯, á»± â†’ u\n * Ã½, á»³, á»·, á»¹, á»µ â†’ y\n */\nfunction removeVietnameseDiacritics(str: string): string {\n  return str\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '') // Remove combining diacritical marks\n    .replace(/Ä‘/g, 'd')\n    .replace(/Ä/g, 'D');\n}\n\n/**\n * Sanitize subdomain from business name or user input\n * Converts Vietnamese characters to ASCII and removes spaces/special chars\n * Example: \"Ão dÃ i Pháº¡m\" â†’ \"aodaipham\"\n */\nexport function sanitizeSubdomain(input: string): string {\n  if (!input) return '';\n  \n  // Step 1: Remove Vietnamese diacritics\n  let sanitized = removeVietnameseDiacritics(input);\n  \n  // Step 2: Convert to lowercase and trim\n  sanitized = sanitized.toLowerCase().trim();\n  \n  // Step 3: Replace spaces and special characters with nothing (not dash)\n  // Only keep alphanumeric characters\n  sanitized = sanitized.replace(/[^a-z0-9]/g, '');\n  \n  // Step 4: Limit length\n  sanitized = sanitized.substring(0, 50);\n  \n  return sanitized;\n}\n\n/**\n * Validate subdomain format and reserved words\n */\nexport function validateSubdomain(subdomain: string): boolean {\n  if (!subdomain || subdomain.length === 0) return false;\n  \n  // Check reserved words\n  if (RESERVED_SUBDOMAINS.includes(subdomain.toLowerCase())) {\n    return false;\n  }\n  \n  // Format validation: must start and end with alphanumeric, can contain dashes\n  // Length: 1-50 characters\n  // Pattern: ^[a-z0-9]([a-z0-9-]{0,48}[a-z0-9])?$\n  const pattern = /^[a-z0-9]([a-z0-9-]{0,48}[a-z0-9])?$/;\n  \n  return pattern.test(subdomain) && subdomain.length >= 1 && subdomain.length <= 50;\n}\n\n/**\n * Generate subdomain from business name\n */\nexport function generateSubdomain(businessName: string): string {\n  return sanitizeSubdomain(businessName);\n}\n\n/**\n * Get root domain from environment\n */\nexport function getRootDomain(): string {\n  return process.env.NEXT_PUBLIC_ROOT_DOMAIN || 'localhost:3000';\n}\n\n/**\n * Get protocol (http or https) from environment\n */\nexport function getProtocol(): string {\n  if (process.env.NODE_ENV === 'production') {\n    return 'https';\n  }\n  return 'http';\n}\n\n/**\n * Build tenant URL from subdomain\n */\nexport function buildTenantUrl(subdomain: string): string {\n  const protocol = getProtocol();\n  const rootDomain = getRootDomain();\n  return `${protocol}://${subdomain}.${rootDomain}`;\n}\n\n/**\n * Extract subdomain from hostname\n * Edge Runtime compatible - no Node.js dependencies\n */\nexport function extractSubdomain(hostname: string): string | null {\n  if (!hostname) return null;\n  \n  // Remove port if present\n  const host = hostname.split(':')[0];\n  \n  // Split by dots\n  const parts = host.split('.');\n  \n  // For localhost subdomains: shop1.localhost\n  if (parts.length >= 2 && parts[parts.length - 1] === 'localhost') {\n    return parts[0];\n  }\n  \n  // For production: shop1.example.com\n  // Assuming root domain has 2 parts (example.com)\n  // Subdomain would be the first part\n  if (parts.length > 2) {\n    return parts[0];\n  }\n  \n  // For exact match with root domain (no subdomain)\n  const rootDomain = getRootDomain().split(':')[0];\n  if (host === rootDomain || host === `www.${rootDomain}`) {\n    return null;\n  }\n  \n  return null;\n}\n\n/**\n * Check if subdomain is reserved\n */\nexport function isReservedSubdomain(subdomain: string): boolean {\n  return RESERVED_SUBDOMAINS.includes(subdomain.toLowerCase());\n}\n\n/**\n * Get list of reserved subdomains\n */\nexport function getReservedSubdomains(): string[] {\n  return [...RESERVED_SUBDOMAINS];\n}\n","// ============================================================================\n// SIMPLIFIED DATABASE PACKAGE EXPORTS - NEW VERSION\n// ============================================================================\n// This is the new, simplified version that replaces the complex dual ID system\n// Goal: Reduce from 139 exports to ~10 simple functions\n\nimport { prisma } from './client';\nimport { simplifiedUsers } from './user';\nimport { simplifiedCustomers } from './customer';\nimport { simplifiedProducts } from './product';\nimport { simplifiedOrders } from './order';\nimport { simplifiedPayments } from './payment';\nimport { simplifiedOutlets } from './outlet';\nimport { simplifiedPlans } from './plan';\nimport { simplifiedSubscriptions } from './subscription';\nimport { simplifiedSubscriptionActivities } from './subscription-activity';\n// import { simplifiedMerchants } from './merchant'; // TEMPORARY: Disabled for multi-tenant migration\nimport { simplifiedOrderNumbers } from './order-number-generator';\nimport { simplifiedCategories } from './category';\nimport { simplifiedAuditLogs } from './audit-logs';\nimport { simplifiedOrderItems } from './order-items';\nimport { sessions } from './sessions';\n\n// Optimized order functions (temporarily disabled due to type issues)\n// export { \n//   searchOrdersOptimized, \n//   searchOrdersWithCursor, \n//   getOrderDetailsOptimized, \n//   getOrderSummary \n// } from './order-optimized';\n\n// Database client\nexport { prisma };\n\n// ============================================================================\n// TYPES FOR SIMPLIFIED API\n// ============================================================================\n\nexport interface SimpleFilters {\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n  outletId?: number;\n  isActive?: boolean;\n  search?: string;\n  page?: number;\n  limit?: number;\n}\n\nexport interface SimpleResponse<T> {\n  data: T[];\n  total: number;\n  page: number;\n  limit: number;\n  hasMore: boolean;\n}\n\n// ============================================================================\n// SIMPLIFIED DATABASE API\n// ============================================================================\n\n/**\n * Simplified database operations\n * Replaces the complex dual ID system with simple, consistent operations\n */\nconst db = {\n  // ============================================================================\n  // PRISMA CLIENT (for transactions)\n  // ============================================================================\n  prisma,\n\n  // ============================================================================\n  // USER OPERATIONS\n  // ============================================================================\n  users: simplifiedUsers,\n\n  // ============================================================================\n  // CUSTOMER OPERATIONS\n  // ============================================================================\n  customers: simplifiedCustomers,\n\n  // ============================================================================\n  // PRODUCT OPERATIONS\n  // ============================================================================\n  products: simplifiedProducts,\n\n  // ============================================================================\n  // ORDER OPERATIONS\n  // ============================================================================\n  orders: simplifiedOrders,\n\n  // ============================================================================\n  // PAYMENT OPERATIONS\n  // ============================================================================\n  payments: simplifiedPayments,\n\n  // ============================================================================\n  // OUTLET OPERATIONS\n  // ============================================================================\n  outlets: simplifiedOutlets,\n\n  // ============================================================================\n  // MERCHANT OPERATIONS\n  // ============================================================================\n  // merchants: simplifiedMerchants, // TEMPORARY: Disabled for multi-tenant migration\n\n  // ============================================================================\n  // PLAN OPERATIONS\n  // ============================================================================\n  plans: simplifiedPlans,\n\n  // ============================================================================\n  // CATEGORY OPERATIONS\n  // ============================================================================\n  categories: simplifiedCategories,\n\n  // ============================================================================\n  // AUDIT LOG OPERATIONS\n  // ============================================================================\n  auditLogs: simplifiedAuditLogs,\n\n  // ============================================================================\n  // ORDER ITEM OPERATIONS\n  // ============================================================================\n  orderItems: simplifiedOrderItems,\n\n  // ============================================================================\n  // SUBSCRIPTION OPERATIONS\n  // ============================================================================\n  subscriptions: simplifiedSubscriptions,\n\n  // ============================================================================\n  // ORDER NUMBER OPERATIONS\n  // ============================================================================\n  orderNumbers: simplifiedOrderNumbers,\n\n  // ============================================================================\n  // OUTLET STOCK OPERATIONS\n  // ============================================================================\n  outletStock: {\n    /**\n     * Aggregate outlet stock statistics\n     */\n    aggregate: async (options: any) => {\n      return await prisma.outletStock.aggregate(options);\n    }\n  },\n\n  // ============================================================================\n  // SUBSCRIPTION ACTIVITY OPERATIONS\n  // ============================================================================\n  subscriptionActivities: simplifiedSubscriptionActivities,\n\n  // ============================================================================\n  // SESSION OPERATIONS (Single Session Enforcement)\n  // ============================================================================\n  sessions\n};\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check database connection health\n */\nconst checkDatabaseConnection = async () => {\n  try {\n    await prisma.$queryRaw`SELECT 1`;\n    return { status: 'connected' };\n  } catch (error) {\n    return { status: 'disconnected', error: error instanceof Error ? error.message : 'Unknown error' };\n  }\n};\n\n/**\n * Generate next order number (simplified) - Random 8 digits\n */\nconst generateOrderNumber = async (outletId: number): Promise<string> => {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Generate random 8-digit number\n  const generateRandom8Digits = (): string => {\n    return Math.floor(10000000 + Math.random() * 90000000).toString();\n  };\n\n  const maxRetries = 10;\n  for (let i = 0; i < maxRetries; i++) {\n    const randomSequence = generateRandom8Digits();\n    const orderNumber = randomSequence; // Just 8 random digits, no prefix\n    \n    // Check if order number already exists\n    const existingOrder = await prisma.order.findUnique({\n      where: { orderNumber }\n    });\n\n    if (!existingOrder) {\n      return orderNumber;\n    }\n  }\n\n  throw new Error('Failed to generate unique order number after maximum retries');\n};\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport { db, checkDatabaseConnection, generateOrderNumber };\n\n// Export payment functions\nexport { simplifiedPayments } from './payment';\n\n// Export subscription activity functions\nexport { simplifiedSubscriptionActivities } from './subscription-activity';\n\n// Legacy exports for backward compatibility\n// Note: getSubscriptionByMerchantId removed - tenant databases are already isolated per tenant\nexport { createSubscriptionPayment, updateSubscription, getExpiredSubscriptions, getSubscriptionById } from './subscription';\nexport { AuditLogger, getAuditLogger, extractAuditContext } from './audit';\nexport type { AuditContext } from './audit';\nexport { getOutletOrderStats, createOrderNumberWithFormat } from './order-number-generator';\nexport { getDefaultOutlet } from './outlet';\nexport type { OrderNumberFormat } from './order-number-generator';\nexport { searchOrders } from './order'; // Legacy order search function\n\n// Registration functions\n// Note: registerMerchantWithTrial removed - use registerTenantWithTrial instead\nexport { registerUser, registerTenantWithTrial } from './registration';\nexport type { RegistrationInput, RegistrationResult } from './registration';\n\n// Email verification functions\nexport * from './email-verification';\n\n// Multi-tenant functions\nexport { \n  getTenantDb, \n  createTenantDatabase,\n  clearTenantCache,\n  getCachedTenants\n} from './tenant-db';\n\n// Main DB functions\nexport {\n  getMainDbClient,\n  getTenantBySubdomain,\n  getTenantById,\n  subdomainExists,\n  tenantEmailExists,\n  createTenant,\n  updateTenant,\n  listAllTenants,\n  getPlanById,\n  listActivePlans,\n  getDefaultPlan\n} from './main-db';\n\nexport type { Tenant, Plan } from './main-db';\n\n// Subdomain utilities\nexport {\n  sanitizeSubdomain,\n  validateSubdomain,\n  generateSubdomain,\n  getRootDomain,\n  getProtocol,\n  buildTenantUrl,\n  extractSubdomain,\n  isReservedSubdomain,\n  getReservedSubdomains\n} from './subdomain-utils';\n\n// ============================================================================\n// MIGRATION GUIDE\n// ============================================================================\n/*\nOLD WAY (139 exports):\nimport { \n  findOutletByPublicId, \n  convertOutletPublicIdToDatabaseId,\n  getCustomerByPublicId as getCustomerById,\n  getOutletByPublicId as getOutletById,\n  // ... 135 more exports\n} from '@rentalshop/database';\n\nNEW WAY (3 main exports):\nimport { db, prisma, checkDatabaseConnection } from '@rentalshop/database';\n\n// Usage examples:\nconst user = await db.users.findById(123);\nconst users = await db.users.search({ page: 1, limit: 20 }); // Note: merchantId not needed - tenant isolation\nconst product = await db.products.findByBarcode('123456789');\nconst orders = await db.orders.search({ outletId: 1, status: 'ACTIVE' });\n\nBENEFITS:\nâœ… 93% reduction in exports (139 â†’ 10)\nâœ… Consistent API across all entities\nâœ… No more dual ID complexity\nâœ… Better TypeScript support\nâœ… Easier to maintain and debug\nâœ… Better performance with optimized queries\n*/\n","import { PrismaClient } from '@prisma/client';\n\n// Global Prisma client instance for singleton pattern\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\n// Create a singleton Prisma client instance\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n});\n\n// Store the instance globally in development to prevent multiple instances\nif (process.env.NODE_ENV !== 'production') {\n  globalForPrisma.prisma = prisma;\n} ","// ============================================================================\n// USER FUNCTIONS\n// ============================================================================\n// This file contains user functions that use integer IDs:\n// - Input: id (number)\n// - Database: queries by id (auto-incrementing integer)\n// - Return: includes id (number)\n\nimport { prisma } from './client';\nimport type { UserCreateInput, UserUpdateInput } from '@rentalshop/types';\nimport { hashPassword } from '@rentalshop/auth';\n\n// ============================================================================\n// USER LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find user by ID\n */\nexport async function findUserById(id: number) {\n  return await prisma.user.findUnique({\n    where: { id },\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get user by ID\n */\nexport async function getUserById(id: number) {\n  return await prisma.user.findUnique({\n    where: { id },\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// USER CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new user - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\nexport async function createUser(input: UserCreateInput): Promise<any> {\n  // Generate next user id\n  const lastUser = await prisma.user.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastUser?.id || 0) + 1;\n\n  // Find outlet by id if provided\n  let outletId: number | undefined;\n  if (input.outletId) {\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: input.outletId }\n    });\n    if (!outlet) {\n      throw new Error(`Outlet with id ${input.outletId} not found`);\n    }\n    outletId = outlet.id;\n  }\n\n  // Create user\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n  const user = await prisma.user.create({\n    data: {\n      id: nextPublicId,\n      email: input.email,\n      password: input.password,\n      firstName: input.firstName,\n      lastName: input.lastName,\n      phone: input.phone,\n      role: input.role,\n      isActive: true,\n      outletId,\n    },\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return user;\n}\n\n// ============================================================================\n// USER UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update user - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateUser(\n  id: number,\n  input: UserUpdateInput\n): Promise<any> {\n  // Find user by id\n  const existingUser = await prisma.user.findUnique({\n    where: { id }\n  });\n\n  if (!existingUser) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  // Update user - only update fields that are provided\n  const updateData: any = {};\n  if (input.firstName !== undefined) updateData.firstName = input.firstName;\n  if (input.lastName !== undefined) updateData.lastName = input.lastName;\n  if (input.phone !== undefined) updateData.phone = input.phone;\n  // Note: email updates are disabled for security reasons\n\n  const updatedUser = await prisma.user.update({\n    where: { id },\n    data: updateData,\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          phone: true,\n          description: true,\n          isActive: true,\n          isDefault: true,\n          createdAt: true,\n        }\n      },\n    },\n  });\n\n  return updatedUser;\n}\n\n// ============================================================================\n// USER UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get all users\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getAllUsers() {\n  return await prisma.user.findMany({\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get users by outlet - follows dual ID system\n */\nexport async function getUsersByOutlet(outletId: number) {\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  return await prisma.user.findMany({\n    where: { outletId: outlet.id },\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n// ============================================================================\n// USER SOFT DELETE FUNCTIONS\n// ============================================================================\n\n/**\n * Soft delete user by public ID - follows dual ID system\n * Sets isActive to false and deletedAt to current timestamp\n */\nexport async function softDeleteUser(id: number): Promise<any> {\n  // Find user by id\n  const user = await prisma.user.findUnique({\n    where: { id },\n    select: { id: true, email: true, isActive: true, deletedAt: true }\n  });\n\n  if (!user) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  if (user.deletedAt) {\n    throw new Error(`User with id ${id} is already deleted`);\n  }\n\n  // Soft delete the user\n  const deletedUser = await prisma.user.update({\n    where: { id: user.id },\n    data: {\n      isActive: false,\n      deletedAt: new Date(),\n    },\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return deletedUser;\n}\n\n/**\n * Restore soft deleted user by public ID - follows dual ID system\n * Sets isActive to true and clears deletedAt\n */\nexport async function restoreUser(id: number): Promise<any> {\n  // Find user by id\n  const user = await prisma.user.findUnique({\n    where: { id },\n    select: { id: true, email: true, isActive: true, deletedAt: true }\n  });\n\n  if (!user) {\n    throw new Error(`User with id ${id} not found`);\n  }\n\n  if (!user.deletedAt) {\n    throw new Error(`User with id ${id} is not deleted`);\n  }\n\n  // Restore the user\n  const restoredUser = await prisma.user.update({\n    where: { id: user.id },\n    data: {\n      isActive: true,\n      deletedAt: null,\n    },\n    include: {\n      outlet: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return restoredUser;\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedUsers = {\n  /**\n   * Find user by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.user.findUnique({\n      where: { id },\n      include: {\n        outlet: { \n          select: { \n            id: true, \n            name: true,\n            address: true,\n            phone: true,\n            description: true,\n            isActive: true,\n            isDefault: true,\n            createdAt: true,\n          } \n        }\n      }\n    });\n  },\n\n  /**\n   * Find user by email (simplified API)\n   */\n  findByEmail: async (email: string) => {\n    return await prisma.user.findUnique({\n      where: { email },\n      select: {\n        id: true,\n        email: true,\n        password: true,\n        firstName: true,\n        lastName: true,\n        phone: true,\n        role: true,\n        isActive: true,\n        emailVerified: true,\n        emailVerifiedAt: true,\n        createdAt: true,\n        updatedAt: true,\n        outletId: true,\n        deletedAt: true,\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Find first user matching criteria (simplified API)\n   */\n  findFirst: async (where: any) => {\n    return await prisma.user.findFirst({\n      where,\n      include: {\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Create new user (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('ðŸ” simplifiedUsers.create called with data:', data);\n      \n      // Password should already be hashed when passed to this function\n      const userData = { ...data };\n      \n      // Note: merchantId removed - tenant databases are already isolated per tenant\n\n      // Validate outletId exists if provided\n      if (userData.outletId && typeof userData.outletId === 'number') {\n        const outlet = await prisma.outlet.findUnique({\n          where: { id: userData.outletId },\n          select: { id: true, name: true }\n        });\n        \n        if (!outlet) {\n          throw new Error(`Outlet with id ${userData.outletId} not found`);\n        }\n        \n        console.log('âœ… Outlet found:', outlet);\n      }\n\n      // Check for duplicate email globally\n      if (userData.email) {\n        const existingEmail = await prisma.user.findUnique({\n          where: { email: userData.email },\n          select: { id: true, email: true }\n        });\n        \n        if (existingEmail) {\n          throw new Error(`Email ${userData.email} is already registered`);\n        }\n      }\n\n      // Check for duplicate phone (tenant databases are already isolated)\n      if (userData.phone) {\n        const existingPhone = await prisma.user.findFirst({\n          where: { \n            phone: userData.phone,\n          },\n          select: { id: true, phone: true }\n        });\n        \n        if (existingPhone) {\n          throw new Error(`Phone number ${userData.phone} is already registered`);\n        }\n      }\n\n      // Generate next user id\n      const lastUser = await prisma.user.findFirst({\n        orderBy: { id: 'desc' },\n        select: { id: true }\n      });\n      const nextPublicId = (lastUser?.id || 0) + 1;\n      userData.id = nextPublicId;\n\n      const user = await prisma.user.create({\n        data: userData,\n        include: {\n          outlet: { \n            select: { \n              id: true, \n              name: true,\n              address: true,\n              phone: true,\n              description: true,\n              isActive: true,\n              isDefault: true,\n              createdAt: true,\n            } \n          }\n        }\n      });\n      \n      console.log('âœ… User created successfully:', user);\n      return user;\n    } catch (error) {\n      console.error('âŒ Error in simplifiedUsers.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update user (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.user.update({\n      where: { id },\n      data,\n      include: {\n        outlet: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Delete user (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.user.update({\n      where: { id },\n      data: { \n        isActive: false,\n        deletedAt: new Date()\n      }\n    });\n  },\n\n  /**\n   * Search users with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (whereFilters.outletId) where.outletId = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    \n    // Handle role filtering - roles array has priority over single role\n    if (whereFilters.roles && Array.isArray(whereFilters.roles)) {\n      where.role = { in: whereFilters.roles };\n    } else if (whereFilters.role) {\n      where.role = whereFilters.role;\n    }\n    \n    // Text search (case-insensitive)\n    if (whereFilters.search) {\n      where.OR = [\n        { firstName: { contains: whereFilters.search, mode: 'insensitive' } },\n        { lastName: { contains: whereFilters.search, mode: 'insensitive' } },\n        { email: { contains: whereFilters.search, mode: 'insensitive' } }\n      ];\n    }\n\n    // âœ… Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [users, total] = await Promise.all([\n      prisma.user.findMany({\n        where,\n        include: {\n          outlet: { select: { id: true, name: true } }\n        },\n        orderBy, // âœ… Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.user.count({ where })\n    ]);\n\n    console.log(`ðŸ“Š db.users.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, users=${users.length}`);\n\n    return {\n      data: users,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.user.count({ where });\n  },\n\n  /**\n   * Get user statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.user.count({ where });\n  }\n};\n","// ============================================================================\n// NEW: CORRECT DUAL ID CUSTOMER FUNCTIONS\n// ============================================================================\n// This file contains only the correct customer functions that follow the dual ID system:\n// - Input: id (number)\n// - Database: queries by id, uses CUIDs for relationships\n// - Return: includes both id (CUID) and id (number)\n\nimport { prisma } from './client';\nimport type { \n  CustomerInput, \n  CustomerUpdateInput, \n  CustomerSearchFilter,\n  CustomerSearchResult,\n  CustomerSearchResponse \n} from '@rentalshop/types';\n\n// ============================================================================\n// CUSTOMER LOOKUP FUNCTIONS (BY PUBLIC ID)\n// ============================================================================\n\n/**\n * Get customer by public ID - follows dual ID system\n * Input: id (number), Output: Customer with relations\n * Note: Tenant databases are already isolated per tenant, merchantId not needed\n */\nexport async function getCustomerByPublicId(id: number) {\n  return await prisma.customer.findFirst({\n    where: { id },\n    include: {\n      orders: {\n        select: {\n          id: true,\n          orderNumber: true,\n          status: true,\n          totalAmount: true,\n          createdAt: true,\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get customer by email\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getCustomerByEmail(email: string) {\n  return await prisma.customer.findFirst({\n    where: { email },\n  });\n}\n\n/**\n * Get customer by phone\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getCustomerByPhone(phone: string) {\n  return await prisma.customer.findFirst({\n    where: { phone },\n  });\n}\n\n// ============================================================================\n// CUSTOMER CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new customer - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n * Note: Tenant databases are already isolated per tenant, merchantId not needed\n */\nexport async function createCustomer(input: CustomerInput): Promise<any> {\n  // Generate next customer id\n  const lastCustomer = await prisma.customer.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastCustomer?.id || 0) + 1;\n\n  // Create customer\n  const customer = await prisma.customer.create({\n    data: {\n      id: nextPublicId,\n      firstName: input.firstName,\n      lastName: input.lastName,\n      email: input.email && input.email.trim() !== '' ? input.email : null,\n      phone: input.phone,\n      address: input.address,\n      city: input.city,\n      state: input.state,\n      zipCode: input.zipCode,\n      country: input.country,\n      dateOfBirth: input.dateOfBirth,\n      idNumber: input.idNumber,\n      idType: input.idType,\n      notes: input.notes,\n      isActive: true, // Default to true\n    },\n  });\n\n  return customer;\n}\n\n// ============================================================================\n// CUSTOMER UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update customer - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateCustomer(\n  id: number,\n  input: CustomerUpdateInput\n): Promise<any> {\n  // Find customer by id\n  const existingCustomer = await prisma.customer.findUnique({\n    where: { id }\n  });\n\n  if (!existingCustomer) {\n    throw new Error(`Customer with id ${id} not found`);\n  }\n\n  // Update customer\n  const updatedCustomer = await prisma.customer.update({\n    where: { id },\n    data: {\n      firstName: input.firstName,\n      lastName: input.lastName,\n      email: input.email,\n      phone: input.phone,\n      address: input.address,\n      city: input.city,\n      state: input.state,\n      zipCode: input.zipCode,\n      country: input.country,\n      dateOfBirth: input.dateOfBirth,\n      idNumber: input.idNumber,\n      idType: input.idType,\n      notes: input.notes,\n      isActive: input.isActive,\n    },\n  });\n\n  return updatedCustomer;\n}\n\n// ============================================================================\n// CUSTOMER SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Build order by clause for customer queries\n */\nfunction buildCustomerOrderByClause(sortBy?: string, sortOrder?: string): any {\n  const validSortFields = [\n    'createdAt', 'updatedAt', 'firstName', 'lastName', 'email', 'phone'\n  ];\n  \n  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';\n  const order = sortOrder === 'asc' ? 'asc' : 'desc';\n  \n  return { [field as string]: order };\n}\n\n/**\n * Search customers - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchCustomers(\n  filters: CustomerSearchFilter\n): Promise<CustomerSearchResponse> {\n  const {\n    q,\n    isActive,\n    city,\n    state,\n    country,\n    idType,\n    limit = 20,\n    offset = 0,\n    sortBy,\n    sortOrder\n  } = filters;\n\n  // Build where conditions\n  const where: any = {};\n\n  // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n\n  // Default to active customers only\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  } else {\n    where.isActive = true;\n  }\n\n  if (city) {\n    where.city = { contains: city.toLowerCase() };\n  }\n\n  if (state) {\n    where.state = { contains: state.toLowerCase() };\n  }\n\n  if (country) {\n    where.country = { contains: country.toLowerCase() };\n  }\n\n  if (idType) {\n    where.idType = idType;\n  }\n\n  // Search query for name, email, phone, or idNumber (case-insensitive)\n  if (q && q.trim()) {\n    const searchQuery = q.trim();\n    where.OR = [\n      { firstName: { contains: searchQuery, mode: 'insensitive' } },\n      { lastName: { contains: searchQuery, mode: 'insensitive' } },\n      { email: { contains: searchQuery, mode: 'insensitive' } },\n      { phone: { contains: searchQuery } } // Phone numbers are usually exact match\n    ];\n  }\n\n  // Get total count\n  const total = await prisma.customer.count({ where });\n\n  // Get customers with pagination\n  const customers = await prisma.customer.findMany({\n    where,\n    orderBy: buildCustomerOrderByClause(sortBy, sortOrder),\n    take: limit,\n    skip: offset\n  });\n\n  // Transform to match CustomerSearchResult type\n  const transformedCustomers: CustomerSearchResult[] = customers.map((customer: any) => ({\n    id: customer.id, // Use id (number) as required by CustomerSearchResult\n    firstName: customer.firstName,\n    lastName: customer.lastName,\n    email: customer.email || '',\n    phone: customer.phone,\n    address: customer.address || undefined,\n    city: customer.city || undefined,\n    state: customer.state || undefined,\n    zipCode: customer.zipCode || undefined,\n    country: customer.country || undefined,\n    dateOfBirth: customer.dateOfBirth || undefined,\n    idNumber: customer.idNumber || undefined,\n    idType: customer.idType as any,\n    notes: customer.notes || undefined,\n    isActive: customer.isActive,\n    createdAt: customer.createdAt,\n    updatedAt: customer.updatedAt,\n  }));\n\n  return {\n    success: true,\n    data: {\n      customers: transformedCustomers as any, // Type assertion to handle CustomerWithMerchant mismatch\n      total,\n      page: Math.floor(offset / limit) + 1,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n      totalPages: Math.ceil(total / limit),\n    },\n  };\n}\n\n// ============================================================================\n// CUSTOMER UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get all customers\n * Note: Tenant databases are already isolated per tenant, merchantId not needed\n * This function replaces getCustomersByMerchant\n */\nexport async function getAllCustomers() {\n  return await prisma.customer.findMany({\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Check if customer exists by email\n * Note: Tenant databases are already isolated per tenant, merchantId not needed\n */\nexport async function customerExistsByEmail(email: string): Promise<boolean> {\n  const customer = await prisma.customer.findFirst({\n    where: {\n      email: email,\n    },\n  });\n\n  return !!customer;\n}\n\n/**\n * Check if customer exists by phone\n * Note: Tenant databases are already isolated per tenant, merchantId not needed\n */\nexport async function customerExistsByPhone(phone: string): Promise<boolean> {\n  const customer = await prisma.customer.findFirst({\n    where: {\n      phone: phone,\n    },\n  });\n\n  return !!customer;\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedCustomers = {\n  /**\n   * Find customer by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.customer.findUnique({\n      where: { id },\n      include: {\n        orders: {\n          select: { id: true, orderNumber: true, totalAmount: true, status: true, createdAt: true },\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new customer (simplified API)\n   */\n  create: async (data: any) => {\n    // Handle optional email field - convert empty string to null\n    const customerData = {\n      ...data,\n      email: data.email && data.email.trim() !== '' ? data.email : null\n    };\n    \n    // Remove merchant connection from data since it's handled by Prisma relations\n    delete customerData.merchant;\n    \n    return await prisma.customer.create({\n      data: customerData,\n    });\n  },\n\n  /**\n   * Update customer (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.customer.update({\n      where: { id },\n      data,\n    });\n  },\n\n  /**\n   * Search customers with pagination (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (whereFilters.outletId) where.outletId = whereFilters.outletId;\n    // Default to active customers only unless explicitly requesting all\n    if (whereFilters.isActive !== undefined) {\n      where.isActive = whereFilters.isActive;\n    } else {\n      where.isActive = true; // Default: only show active customers\n    }\n    \n    // Text search across multiple fields (case-insensitive)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      where.OR = [\n        { firstName: { contains: searchTerm, mode: 'insensitive' } },\n        { lastName: { contains: searchTerm, mode: 'insensitive' } },\n        { email: { contains: searchTerm, mode: 'insensitive' } },\n        { phone: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n    }\n\n    // Specific field filters (case-insensitive)\n    if (whereFilters.firstName) where.firstName = { contains: whereFilters.firstName, mode: 'insensitive' };\n    if (whereFilters.lastName) where.lastName = { contains: whereFilters.lastName, mode: 'insensitive' };\n    if (whereFilters.email) where.email = { contains: whereFilters.email, mode: 'insensitive' };\n    if (whereFilters.phone) where.phone = { contains: whereFilters.phone, mode: 'insensitive' };\n    if (whereFilters.city) where.city = { contains: whereFilters.city, mode: 'insensitive' };\n    if (whereFilters.state) where.state = { contains: whereFilters.state, mode: 'insensitive' };\n    if (whereFilters.country) where.country = { contains: whereFilters.country, mode: 'insensitive' };\n\n    // âœ… Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email' || sortBy === 'phone') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [customers, total] = await Promise.all([\n      prisma.customer.findMany({\n        where,\n        include: {\n          _count: {\n            select: { orders: true }\n          }\n        },\n        orderBy, // âœ… Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.customer.count({ where })\n    ]);\n\n    console.log(`ðŸ“Š db.customers.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, customers=${customers.length}`);\n\n    return {\n      data: customers,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Delete customer (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.customer.update({\n      where: { id },\n      data: { isActive: false },\n      select: {\n        id: true,\n        firstName: true,\n        lastName: true,\n        email: true,\n        phone: true,\n        address: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true\n      }\n    });\n  },\n\n  /**\n   * Find first customer matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.customer.findFirst({\n      where,\n      select: {\n        id: true,\n        firstName: true,\n        lastName: true,\n        email: true,\n        phone: true,\n        address: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true\n      }\n    });\n  },\n\n  /**\n   * Get customer statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.customer.count({ where });\n  }\n};\n","// ============================================================================\n// NEW: CORRECT DUAL ID PRODUCT FUNCTIONS\n// ============================================================================\n// This file contains only the correct product functions that follow the dual ID system:\n// - Input: id (number)\n// - Database: queries by id, uses CUIDs for relationships\n// - Return: includes both id (CUID) and id (number)\n\nimport { prisma } from './client';\nimport type { ProductSearchFilter } from '@rentalshop/types';\n\n// ============================================================================\n// PRODUCT LOOKUP FUNCTIONS (BY PUBLIC ID)\n// ============================================================================\n\n/**\n * Get product by id\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getProductById(id: number) {\n  return await prisma.product.findUnique({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      outletStock: {\n        select: {\n          id: true,\n          stock: true,\n          available: true,\n          renting: true,\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n              address: true,\n            },\n          },\n        },\n      },\n    },\n  });\n}\n\n/**\n * Get product by barcode\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getProductByBarcode(barcode: string) {\n  return await prisma.product.findFirst({\n    where: { barcode },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n}\n\n// ============================================================================\n// PRODUCT SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Build order by clause for product queries\n */\nfunction buildProductOrderByClause(sortBy?: string, sortOrder?: string): any {\n  const validSortFields = [\n    'createdAt', 'updatedAt', 'name', 'rentPrice', 'salePrice', 'totalStock'\n  ];\n  \n  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';\n  const order = sortOrder === 'asc' ? 'asc' : 'desc';\n  \n  return { [field as string]: order };\n}\n\n/**\n * Search products - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchProducts(filters: ProductSearchFilter) {\n  const {\n    merchantId,\n    outletId,\n    categoryId,\n    search,\n    q, // Add q parameter support\n    page = 1,\n    limit = 20,\n    offset, // Add offset support\n    isActive = true,\n    available,\n    minPrice,\n    maxPrice,\n    sortBy,\n    sortOrder\n  } = filters;\n\n  // Use offset if provided, otherwise calculate from page\n  const skip = offset !== undefined ? offset : (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {\n    isActive,\n  };\n\n  // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n\n  if (categoryId) {\n    // Find category by id\n    const category = await prisma.category.findUnique({\n      where: { id: categoryId },\n      select: { id: true }\n    });\n    \n    if (category) {\n      where.categoryId = category.id; // Use CUID\n    }\n  }\n\n  // Handle search query - use 'q' parameter first, fallback to 'search' for backward compatibility (case-insensitive)\n  const searchQuery = q || search;\n  if (searchQuery) {\n    const searchTerm = searchQuery.trim();\n    where.OR = [\n      { name: { contains: searchTerm, mode: 'insensitive' } },\n      { description: { contains: searchTerm, mode: 'insensitive' } },\n      { barcode: { equals: searchTerm } } // Barcode is usually exact match\n    ];\n  }\n\n  // If outletId is specified, only show products that have stock at that outlet\n  if (outletId) {\n    // Find outlet by id\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: outletId },\n      select: { id: true }\n    });\n    \n    if (outlet) {\n      where.outletStock = {\n        some: {\n          outletId: outlet.id, // Use CUID\n          stock: { gt: 0 }\n        }\n      };\n    }\n  }\n\n  // Add availability filter\n  if (available !== undefined) {\n    if (available) {\n      where.outletStock = {\n        some: {\n          available: { gt: 0 }\n        }\n      };\n    } else {\n      where.outletStock = {\n        none: {\n          available: { gt: 0 }\n        }\n      };\n    }\n  }\n\n  // Add price range filters\n  if (minPrice !== undefined || maxPrice !== undefined) {\n    where.rentPrice = {};\n    if (minPrice !== undefined) where.rentPrice.gte = minPrice;\n    if (maxPrice !== undefined) where.rentPrice.lte = maxPrice;\n  }\n\n  const [products, total] = await Promise.all([\n    prisma.product.findMany({\n      where,\n      select: {\n      id: true,\n        name: true,\n        description: true,\n        barcode: true,\n        totalStock: true,\n        rentPrice: true,\n        salePrice: true,\n        deposit: true,\n        images: true,\n        isActive: true,\n        createdAt: true,\n        updatedAt: true,\n        category: {\n          select: {\n      id: true,\n            name: true\n          }\n        },\n        outletStock: {\n          select: {\n            id: true,\n            stock: true,\n            available: true,\n            renting: true,\n            outlet: {\n              select: {\n      id: true,\n                name: true,\n                address: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: buildProductOrderByClause(sortBy, sortOrder),\n      take: limit,\n      skip: skip\n    }),\n    prisma.product.count({ where })\n  ]);\n\n  // Transform to match expected types\n  const transformedProducts = products.map((product: any) => ({\n    id: product.id, // Return id (number) for external use\n    name: product.name,\n    description: product.description,\n    barcode: product.barcode,\n    totalStock: product.totalStock,\n    rentPrice: product.rentPrice,\n    salePrice: product.salePrice,\n    deposit: product.deposit,\n    images: product.images,\n    isActive: product.isActive,\n    createdAt: product.createdAt,\n    updatedAt: product.updatedAt,\n    category: {\n      id: product.category.id, // Return id (number)\n      name: product.category.name,\n    },\n    outletStock: product.outletStock.map((stock: any) => ({\n      id: stock.id, // Keep CUID for internal use\n      stock: stock.stock,\n      available: stock.available,\n      renting: stock.renting,\n      outlet: {\n        id: stock.outlet.id, // Return id (number)\n        name: stock.outlet.name,\n        address: stock.outlet.address,\n      },\n    })),\n  }));\n\n  return {\n    products: transformedProducts,\n    total,\n    page: offset !== undefined ? Math.floor(offset / limit) + 1 : page,\n    limit,\n    offset: skip,\n    hasMore: skip + limit < total,\n    totalPages: Math.ceil(total / limit),\n  };\n}\n\n// ============================================================================\n// DEFAULT CATEGORY FUNCTIONS\n// ============================================================================\n\n/**\n * Get or create default category\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nasync function getOrCreateDefaultCategory(): Promise<any> {\n  // First try to find existing default category\n  const existingDefault = await prisma.category.findFirst({\n    where: {\n      name: 'General',\n      isActive: true\n    }\n  });\n\n  if (existingDefault) {\n    console.log('âœ… Found existing default category:', existingDefault.id);\n    return existingDefault;\n  }\n\n  // Create default category if not exists\n  console.log('ðŸ”§ Creating default category');\n  \n  // Generate next category id\n  const lastCategory = await prisma.category.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastCategory?.id || 0) + 1;\n\n  const defaultCategory = await prisma.category.create({\n    data: {\n      id: nextPublicId,\n      name: 'General',\n      description: 'Default category for general products',\n      isActive: true\n    }\n  });\n\n  console.log('âœ… Created default category:', defaultCategory.id);\n  return defaultCategory;\n}\n\n// ============================================================================\n// PRODUCT CREATION FUNCTIONS\n// ============================================================================\n\n/**\n * Create new product - follows dual ID system\n * Input: ids (numbers), Output: id (number)\n */\n/**\n * Create new product\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function createProduct(input: any): Promise<any> {\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n\n  // Find category by id if provided\n  let category = null;\n  if (input.categoryId) {\n    category = await prisma.category.findUnique({\n      where: { id: input.categoryId }\n    });\n    \n    if (!category) {\n      throw new Error(`Category with id ${input.categoryId} not found`);\n    }\n  }\n\n  // Generate next product id\n  const lastProduct = await prisma.product.findFirst({\n    orderBy: { id: 'desc' },\n    select: { id: true }\n  });\n  const nextPublicId = (lastProduct?.id || 0) + 1;\n\n  // Create product\n  const productData: any = {\n    id: nextPublicId,\n    name: input.name,\n    description: input.description,\n    barcode: input.barcode,\n    totalStock: input.totalStock || 0,\n    rentPrice: input.rentPrice,\n    salePrice: input.salePrice,\n    deposit: input.deposit || 0,\n    images: input.images,\n    isActive: input.isActive ?? true,\n  };\n\n  // Only add categoryId if category is provided\n  if (category) {\n    productData.categoryId = category.id;\n  }\n\n  const product = await prisma.product.create({\n    data: productData,\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return product;\n}\n\n// ============================================================================\n// PRODUCT UPDATE FUNCTIONS\n// ============================================================================\n\n/**\n * Update product - follows dual ID system\n * Input: id (number), Output: id (number)\n */\nexport async function updateProduct(\n  id: number,\n  input: any\n): Promise<any> {\n  // Find product by id\n  const existingProduct = await prisma.product.findUnique({\n    where: { id }\n  });\n\n  if (!existingProduct) {\n    throw new Error(`Product with id ${id} not found`);\n  }\n\n  // Handle category update if categoryId is provided\n  let categoryId = undefined;\n  if (input.categoryId !== undefined) {\n    if (input.categoryId === null || input.categoryId === 0) {\n      // Remove category\n      categoryId = null;\n    } else {\n      // Find category by id\n      const category = await prisma.category.findUnique({\n        where: { id: input.categoryId }\n      });\n      \n      if (!category) {\n        throw new Error(`Category with id ${input.categoryId} not found`);\n      }\n      \n      categoryId = category.id; // Use CUID for database\n    }\n  }\n\n  // Prepare update data\n  const updateData: any = {};\n  \n  // Only update fields that are provided\n  if (input.name !== undefined) updateData.name = input.name;\n  if (input.description !== undefined) updateData.description = input.description;\n  if (input.barcode !== undefined) updateData.barcode = input.barcode;\n  if (input.totalStock !== undefined) updateData.totalStock = input.totalStock;\n  if (input.rentPrice !== undefined) updateData.rentPrice = input.rentPrice;\n  if (input.salePrice !== undefined) updateData.salePrice = input.salePrice;\n  if (input.deposit !== undefined) updateData.deposit = input.deposit;\n  if (input.images !== undefined) updateData.images = input.images;\n  if (input.isActive !== undefined) updateData.isActive = input.isActive;\n  if (categoryId !== undefined) updateData.categoryId = categoryId;\n\n  // Update product\n  const updatedProduct = await prisma.product.update({\n    where: { id },\n    data: updateData,\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  return updatedProduct;\n}\n\n// ============================================================================\n// PRODUCT UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get all products\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getAllProducts() {\n  return await prisma.product.findMany({\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Get products by category - follows dual ID system\n */\nexport async function getProductsByCategory(categoryId: number) {\n  // Find category by id\n  const category = await prisma.category.findUnique({\n    where: { id: categoryId },\n    select: { id: true }\n  });\n  \n  if (!category) {\n    throw new Error(`Category with id ${categoryId} not found`);\n  }\n\n  return await prisma.product.findMany({\n    where: { categoryId: category.id }, // Use CUID\n    include: {\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n}\n\n/**\n * Update product stock - follows dual ID system\n */\nexport async function updateProductStock(\n  productId: number,\n  outletId: number,\n  stockChange: number\n): Promise<any> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id: productId },\n    select: { id: true }\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${productId} not found`);\n  }\n\n  // Find outlet by id\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n  \n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  // Update or create outlet stock\n  const outletStock = await prisma.outletStock.upsert({\n    where: {\n      productId_outletId: {\n        productId: product.id, // Use CUID\n        outletId: outlet.id, // Use CUID\n      },\n    },\n    update: {\n      stock: { increment: stockChange },\n      available: { increment: stockChange },\n    },\n    create: {\n      productId: product.id, // Use CUID\n      outletId: outlet.id, // Use CUID\n      stock: stockChange,\n      available: stockChange,\n      renting: 0,\n    },\n  });\n\n  return outletStock;\n}\n\n/**\n * Delete product - follows dual ID system\n * Input: id (number), Output: deleted product data\n */\nexport async function deleteProduct(id: number): Promise<any> {\n  // Find product by id\n  const product = await prisma.product.findUnique({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n  \n  if (!product) {\n    throw new Error(`Product with id ${id} not found`);\n  }\n\n  // Delete the product (this will cascade to outletStock due to Prisma schema)\n  const deletedProduct = await prisma.product.delete({\n    where: { id },\n    include: {\n      category: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n      merchant: {\n        select: {\n          id: true,\n          name: true,\n        },\n      },\n    },\n  });\n\n  // Transform to match expected types\n  return {\n    id: deletedProduct.id,\n    name: deletedProduct.name,\n    description: deletedProduct.description,\n    barcode: deletedProduct.barcode,\n    totalStock: deletedProduct.totalStock,\n    rentPrice: deletedProduct.rentPrice,\n    salePrice: deletedProduct.salePrice,\n    deposit: deletedProduct.deposit,\n    images: deletedProduct.images,\n    isActive: deletedProduct.isActive,\n    createdAt: deletedProduct.createdAt,\n    updatedAt: deletedProduct.updatedAt,\n    category: {\n      id: deletedProduct.category.id,\n      name: deletedProduct.category.name,\n    },\n    merchant: {\n      id: deletedProduct.merchant.id,\n      name: deletedProduct.merchant.name,\n    },\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedProducts = {\n  /**\n   * Find product by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.product.findUnique({\n      where: { id },\n      include: {\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Find product by barcode (simplified API)\n   */\n  findByBarcode: async (barcode: string) => {\n    return await prisma.product.findUnique({\n      where: { barcode },\n      include: {\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new product (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('ðŸ” simplifiedProducts.create called with data:', data);\n      \n      // If no categoryId provided, get or create default category\n      // Note: merchantId removed - tenant databases are already isolated per tenant\n      if (!data.categoryId) {\n        const defaultCategory = await getOrCreateDefaultCategory();\n        \n        // Add category connection to data\n        data.category = { connect: { id: defaultCategory.id } };\n        console.log('âœ… Using default category:', defaultCategory.id);\n      }\n      \n      const product = await prisma.product.create({\n        data,\n        include: {\n          category: { select: { id: true, name: true } },\n          outletStock: {\n            include: {\n              outlet: { select: { id: true, name: true } }\n            }\n          }\n        }\n      });\n      \n      console.log('âœ… Product created successfully:', product.id);\n      return product;\n    } catch (error) {\n      console.error('âŒ Error in simplifiedProducts.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update product (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.product.update({\n      where: { id },\n      data,\n      include: {\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Delete product (soft delete) (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.product.update({\n      where: { id },\n      data: { isActive: false }\n    });\n  },\n\n  /**\n   * Find first product matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.product.findFirst({\n      where,\n      include: {\n        category: { select: { id: true, name: true } },\n        outletStock: {\n          include: {\n            outlet: { select: { id: true, name: true } }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get product statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.product.count({ where });\n  },\n\n  /**\n   * Search products with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (whereFilters.categoryId) where.categoryId = whereFilters.categoryId;\n    // Default to active products only unless explicitly requesting all\n    if (whereFilters.isActive !== undefined) {\n      where.isActive = whereFilters.isActive;\n    } else {\n      where.isActive = true; // Default: only show active products\n    }\n    \n    // Text search (case-insensitive)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      where.OR = [\n        { name: { contains: searchTerm, mode: 'insensitive' } },\n        { description: { contains: searchTerm, mode: 'insensitive' } },\n        { barcode: { contains: searchTerm, mode: 'insensitive' } }\n      ];\n    }\n\n    // Price range\n    if (whereFilters.minPrice !== undefined || whereFilters.maxPrice !== undefined) {\n      where.rentPrice = {};\n      if (whereFilters.minPrice !== undefined) where.rentPrice.gte = whereFilters.minPrice;\n      if (whereFilters.maxPrice !== undefined) where.rentPrice.lte = whereFilters.maxPrice;\n    }\n\n    const [products, total] = await Promise.all([\n      prisma.product.findMany({\n        where,\n        include: {\n          category: { select: { id: true, name: true } },\n          outletStock: {\n            include: {\n              outlet: { select: { id: true, name: true } }\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit\n      }),\n      prisma.product.count({ where })\n    ]);\n\n    return {\n      data: products,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.product.count({ where });\n  }\n};\n","import { prisma } from './client';\nimport type { Prisma } from '@prisma/client';\nimport type { \n  OrderSearchFilter,\n  OrderSearchResult,\n  OrderSearchResponse\n} from '@rentalshop/types';\n\nexport interface OrderWithRelations {\n  id: number\n  orderNumber: string\n  orderType: string\n  status: string\n  totalAmount: number\n  depositAmount: number\n  securityDeposit: number\n  damageFee: number\n  lateFee: number\n  discountType?: string\n  discountValue: number\n  discountAmount: number\n  pickupPlanAt?: Date\n  returnPlanAt?: Date\n  pickedUpAt?: Date\n  returnedAt?: Date\n  rentalDuration?: number\n  isReadyToDeliver: boolean\n  collateralType?: string\n  collateralDetails?: string\n  notes?: string\n  pickupNotes?: string\n  returnNotes?: string\n  damageNotes?: string\n  createdAt: Date\n  updatedAt: Date\n  outletId: number\n  customerId?: number\n  createdById: number\n  // Relations\n  customer?: {\n    id: number\n    firstName: string\n    lastName: string\n    phone?: string\n    email?: string\n    address?: string\n    idNumber?: string\n  }\n  outlet?: {\n    id: number\n    name: string\n    address: string\n  }\n  createdBy?: {\n    id: number\n    firstName?: string\n    email: string\n  }\n  orderItems?: Array<{\n    id: number\n    quantity: number\n    unitPrice: number\n    totalPrice: number\n    productId: number\n    product?: {\n      id: number\n      name: string\n    }\n  }>\n  payments?: Array<{\n    id: number\n    amount: number\n    method: string\n    status: string\n    processedAt?: Date\n  }>\n}\n\nconst orderSelect = {\n  id: true,\n  orderNumber: true,\n  orderType: true,\n  status: true,\n  totalAmount: true,\n  depositAmount: true,\n  securityDeposit: true,\n  damageFee: true,\n  lateFee: true,\n  discountType: true,\n  discountValue: true,\n  discountAmount: true,\n  pickupPlanAt: true,\n  returnPlanAt: true,\n  pickedUpAt: true,\n  returnedAt: true,\n  rentalDuration: true,\n  isReadyToDeliver: true,\n  collateralType: true,\n  collateralDetails: true,\n  notes: true,\n  pickupNotes: true,\n  returnNotes: true,\n  damageNotes: true,\n  createdAt: true,\n  updatedAt: true,\n  outletId: true,\n  customerId: true,\n  createdById: true,\n} satisfies Prisma.OrderSelect\n\nconst orderInclude = {\n  customer: {\n    select: {\n      id: true,\n      firstName: true,\n      lastName: true,\n      phone: true,\n      email: true,\n      address: true,\n      idNumber: true,\n    }\n  },\n  outlet: {\n    select: {\n      id: true,\n      name: true,\n      address: true,\n    }\n  },\n  createdBy: {\n    select: {\n      id: true,\n      firstName: true,\n      email: true,\n    }\n  },\n  orderItems: {\n    select: {\n      id: true,\n      quantity: true,\n      unitPrice: true,\n      totalPrice: true,\n      productId: true,\n      product: {\n        select: {\n          id: true,\n          name: true,\n        }\n      }\n    }\n  },\n  payments: {\n    select: {\n      id: true,\n      amount: true,\n      method: true,\n      status: true,\n      processedAt: true,\n    }\n  }\n} satisfies Prisma.OrderInclude\n\nfunction transformOrder(order: any): OrderWithRelations {\n  return {\n    id: order.id,\n    orderNumber: order.orderNumber,\n    orderType: order.orderType,\n    status: order.status,\n    totalAmount: order.totalAmount,\n    depositAmount: order.depositAmount ?? 0,\n    securityDeposit: order.securityDeposit ?? 0,\n    damageFee: order.damageFee ?? 0,\n    lateFee: order.lateFee ?? 0,\n    discountType: order.discountType || undefined,\n    discountValue: order.discountValue ?? 0,\n    discountAmount: order.discountAmount ?? 0,\n    pickupPlanAt: order.pickupPlanAt || undefined,\n    returnPlanAt: order.returnPlanAt || undefined,\n    pickedUpAt: order.pickedUpAt || undefined,\n    returnedAt: order.returnedAt || undefined,\n    rentalDuration: order.rentalDuration || undefined,\n    isReadyToDeliver: order.isReadyToDeliver ?? false,\n    collateralType: order.collateralType || undefined,\n    collateralDetails: order.collateralDetails || undefined,\n    notes: order.notes || undefined,\n    pickupNotes: order.pickupNotes || undefined,\n    returnNotes: order.returnNotes || undefined,\n    damageNotes: order.damageNotes || undefined,\n    createdAt: order.createdAt,\n    updatedAt: order.updatedAt,\n    outletId: order.outletId,\n    customerId: order.customerId || undefined,\n    createdById: order.createdById,\n    // Relations\n    customer: order.customer,\n    outlet: order.outlet,\n    createdBy: order.createdBy,\n    orderItems: order.orderItems,\n    payments: order.payments,\n  }\n}\n\nexport async function getOrderById(id: number): Promise<OrderWithRelations | null> {\n  const order = await prisma.order.findUnique({\n    where: { id },\n    include: orderInclude,\n  })\n\n  if (!order) return null\n  return transformOrder(order)\n}\n\nexport async function getOrderByNumber(orderNumber: string): Promise<OrderWithRelations | null> {\n  const order = await prisma.order.findUnique({\n    where: { orderNumber },\n    include: orderInclude,\n  })\n\n  if (!order) return null\n  return transformOrder(order)\n}\n\nexport async function getOrdersByOutlet(outletId: number, limit = 50, offset = 0) {\n  const orders = await prisma.order.findMany({\n    where: { outletId },\n    include: orderInclude,\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: offset,\n  })\n\n  return orders.map(transformOrder)\n}\n\nexport async function getOrdersByCustomer(customerId: number, limit = 50, offset = 0) {\n  const orders = await prisma.order.findMany({\n    where: { customerId },\n    include: orderInclude,\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: offset,\n  })\n\n  return orders.map(transformOrder)\n}\n\nexport async function createOrder(data: {\n  orderNumber: string\n  orderType: string\n  status?: string\n  totalAmount: number\n  depositAmount?: number\n  securityDeposit?: number\n  damageFee?: number\n  lateFee?: number\n  discountType?: string\n  discountValue?: number\n  discountAmount?: number\n  pickupPlanAt?: Date\n  returnPlanAt?: Date\n  rentalDuration?: number\n  isReadyToDeliver?: boolean\n  collateralType?: string\n  collateralDetails?: string\n  notes?: string\n  pickupNotes?: string\n  outletId: number\n  customerId?: number\n  createdById: number\n}): Promise<OrderWithRelations> {\n  const order = await prisma.order.create({\n    data: {\n      orderNumber: data.orderNumber,\n      orderType: data.orderType,\n      status: data.status ?? 'RESERVED',\n      totalAmount: data.totalAmount,\n      depositAmount: data.depositAmount ?? 0,\n      securityDeposit: data.securityDeposit ?? 0,\n      damageFee: data.damageFee ?? 0,\n      lateFee: data.lateFee ?? 0,\n      discountType: data.discountType,\n      discountValue: data.discountValue ?? 0,\n      discountAmount: data.discountAmount ?? 0,\n      pickupPlanAt: data.pickupPlanAt,\n      returnPlanAt: data.returnPlanAt,\n      rentalDuration: data.rentalDuration,\n      isReadyToDeliver: data.isReadyToDeliver ?? false,\n      collateralType: data.collateralType,\n      collateralDetails: data.collateralDetails,\n      notes: data.notes,\n      pickupNotes: data.pickupNotes,\n      outletId: data.outletId,\n      customerId: data.customerId,\n      createdById: data.createdById,\n    },\n    include: orderInclude,\n  })\n\n  return transformOrder(order)\n}\n\nexport async function updateOrder(\n  id: number,\n  data: Partial<{\n    orderType: string\n    status: string\n    totalAmount: number\n    depositAmount: number\n    securityDeposit: number\n    damageFee: number\n    lateFee: number\n    discountType: string\n    discountValue: number\n    discountAmount: number\n    pickupPlanAt: Date\n    returnPlanAt: Date\n    pickedUpAt: Date\n    returnedAt: Date\n    rentalDuration: number\n    isReadyToDeliver: boolean\n    collateralType: string\n    collateralDetails: string\n    notes: string\n    pickupNotes: string\n    returnNotes: string\n    damageNotes: string\n    customerId: number\n    outletId: number\n    orderItems?: Array<{\n      productId: number\n      quantity: number\n      unitPrice: number\n      totalPrice: number\n      deposit?: number\n      notes?: string\n      rentalDays?: number\n    }>\n  }>\n): Promise<OrderWithRelations> {\n  console.log('ðŸ”§ updateOrder called with id:', id);\n  console.log('ðŸ”§ updateOrder data keys:', Object.keys(data));\n  console.log('ðŸ”§ updateOrder has orderItems?:', !!data.orderItems, 'length:', data.orderItems?.length);\n  \n  // Extract relationship IDs and orderItems from data\n  const { \n    orderItems, \n    customerId, \n    outletId,\n    ...allFields \n  } = data;\n  \n  // WHITELIST: Only valid Order model fields from schema\n  const validFields: (keyof typeof allFields)[] = [\n    'orderType', 'status', 'totalAmount', 'depositAmount', \n    'securityDeposit', 'damageFee', 'lateFee', 'discountType', \n    'discountValue', 'discountAmount', 'pickupPlanAt', 'returnPlanAt',\n    'pickedUpAt', 'returnedAt', 'rentalDuration', 'isReadyToDeliver',\n    'collateralType', 'collateralDetails', 'notes', 'pickupNotes',\n    'returnNotes', 'damageNotes'\n  ];\n  \n  // Build update data - filter to only valid fields\n  const updateData: any = {};\n  validFields.forEach(field => {\n    if (field in allFields && allFields[field as keyof typeof allFields] !== undefined) {\n      updateData[field] = allFields[field as keyof typeof allFields];\n    }\n  });\n  \n  console.log('ðŸ”§ Filtered update fields:', Object.keys(updateData));\n  \n  // Handle customer relationship if provided\n  if (customerId !== undefined) {\n    if (customerId === null) {\n      updateData.customer = { disconnect: true };\n    } else {\n      updateData.customer = { connect: { id: customerId } };\n    }\n  }\n  \n  // Handle outlet relationship if provided (should not change usually)\n  if (outletId !== undefined) {\n    updateData.outlet = { connect: { id: outletId } };\n  }\n  \n  // Handle order items separately if provided\n  if (orderItems && orderItems.length > 0) {\n    console.log('ðŸ”§ Processing', orderItems.length, 'order items');\n    updateData.orderItems = {\n      // Delete all existing order items\n      deleteMany: {},\n      // Create new order items\n      create: orderItems.map(item => ({\n        productId: item.productId,\n        quantity: item.quantity,\n        unitPrice: item.unitPrice,\n        totalPrice: item.totalPrice || (item.quantity * item.unitPrice),\n        deposit: item.deposit || 0,\n        notes: item.notes,\n        rentalDays: item.rentalDays\n      }))\n    }\n    console.log('ðŸ”§ Converted orderItems to nested write format');\n  }\n  \n  console.log('ðŸ”§ Final update data structure:', {\n    hasOrderItems: !!updateData.orderItems,\n    hasCustomer: !!updateData.customer,\n    hasOutlet: !!updateData.outlet\n  });\n  \n  const order = await prisma.order.update({\n    where: { id },\n    data: updateData,\n    include: orderInclude,\n  })\n\n  console.log('âœ… Order updated successfully');\n  return transformOrder(order)\n}\n\nexport async function deleteOrder(id: number): Promise<boolean> {\n  try {\n    await prisma.order.delete({\n      where: { id },\n    })\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport async function getOrderCount(outletId?: number, status?: string): Promise<number> {\n  const where: Prisma.OrderWhereInput = {}\n  if (outletId) where.outletId = outletId\n  if (status) where.status = status\n\n  return prisma.order.count({ where })\n}\n\nexport async function generateOrderNumber(outletId: number): Promise<string> {\n  const today = new Date()\n  const year = today.getFullYear()\n  const month = String(today.getMonth() + 1).padStart(2, '0')\n  const day = String(today.getDate()).padStart(2, '0')\n  \n  const prefix = `${year}${month}${day}`\n  \n  const latestOrder = await prisma.order.findFirst({\n    where: {\n      orderNumber: {\n        startsWith: prefix,\n      },\n      outletId,\n    },\n    orderBy: {\n      orderNumber: 'desc',\n    },\n    select: {\n      orderNumber: true,\n    },\n  })\n\n  let sequence = 1\n  if (latestOrder?.orderNumber) {\n    const lastSequence = parseInt(latestOrder.orderNumber.split('-').pop() || '0')\n    sequence = lastSequence + 1\n  }\n\n  return `${prefix}-${String(sequence).padStart(4, '0')}`\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\n// ============================================================================\n// LEGACY ORDER SEARCH (for backward compatibility)\n// ============================================================================\n\n/**\n * Search orders with filters (legacy function)\n * @deprecated Use simplifiedOrders.search instead\n */\nexport async function searchOrders(filters: OrderSearchFilter): Promise<OrderSearchResponse> {\n  \n  const {\n    q,\n    outletId,\n    customerId,\n    userId,\n    orderType,\n    status,\n    startDate,\n    endDate,\n    pickupDate,\n    returnDate,\n    limit = 20,\n    offset = 0\n  } = filters;\n\n  const where: any = {};\n\n  // Text search\n  if (q) {\n    where.OR = [\n      { orderNumber: { contains: q, mode: 'insensitive' } },\n      { customer: { firstName: { contains: q, mode: 'insensitive' } } },\n      { customer: { lastName: { contains: q, mode: 'insensitive' } } },\n      { customer: { phone: { contains: q, mode: 'insensitive' } } },\n    ];\n  }\n\n  // Filter by outlet\n  if (outletId) {\n    where.outletId = outletId;\n  }\n\n  // Filter by customer\n  if (customerId) {\n    where.customerId = customerId;\n  }\n\n  // Filter by user (created by)\n  if (userId) {\n    where.createdById = userId;  \n  }\n\n  // Filter by order type\n  if (orderType) {\n    where.orderType = orderType;\n  }\n\n  // Filter by status\n  if (status) {\n    where.status = status;\n  }\n\n  // Date filters\n  if (startDate || endDate) {\n    where.createdAt = {};\n    if (startDate) {\n      where.createdAt.gte = new Date(startDate);\n    }\n    if (endDate) {\n      where.createdAt.lte = new Date(endDate);\n    }\n  }\n\n  // Pickup date filter\n  if (pickupDate) {\n    where.pickupPlanAt = {\n      gte: new Date(pickupDate),\n      lt: new Date(new Date(pickupDate).getTime() + 24 * 60 * 60 * 1000)\n    };\n  }\n\n  // Return date filter\n  if (returnDate) {\n    where.returnPlanAt = {\n      gte: new Date(returnDate), \n      lt: new Date(new Date(returnDate).getTime() + 24 * 60 * 60 * 1000)\n    };\n  }\n\n  const [orders, total] = await Promise.all([\n    prisma.order.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset,\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        createdAt: true,\n        updatedAt: true,\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n          }\n        }\n      }\n    }),\n    prisma.order.count({ where })\n  ]);\n\n  const totalPages = Math.ceil(total / limit);\n  const page = Math.floor(offset / limit) + 1;\n\n  const transformedOrders: OrderSearchResult[] = orders.map(order => ({\n    id: order.id,\n    orderNumber: order.orderNumber,\n    orderType: order.orderType as any,\n    status: order.status as any,\n    totalAmount: order.totalAmount,\n    depositAmount: order.depositAmount,\n    pickupPlanAt: order.pickupPlanAt,\n    returnPlanAt: order.returnPlanAt,\n    pickedUpAt: order.pickedUpAt,\n    returnedAt: order.returnedAt,\n    isReadyToDeliver: false,\n    customer: order.customer ? {\n      id: order.customer.id,\n      firstName: order.customer.firstName,\n      lastName: order.customer.lastName,\n      email: order.customer.email,\n      phone: order.customer.phone || '',\n    } : null,\n    outlet: {\n      id: order.outlet?.id || 0,\n      name: order.outlet?.name || '',\n    },\n    orderItems: [],\n    createdAt: order.createdAt,\n    updatedAt: order.updatedAt,\n  }));\n\n  return {\n    success: true,\n    data: {\n      orders: transformedOrders,\n      total,\n      page,\n      limit,\n      offset,\n      hasMore: offset + limit < total,\n      totalPages\n    }\n  };\n}\n\nexport const simplifiedOrders = {\n  /**\n   * Find order by ID (simplified API) - OPTIMIZED for performance\n   */\n  findById: async (id: number) => {\n    return await prisma.order.findUnique({\n      where: { id },\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { select: { id: true, name: true } },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            productId: true,\n            notes: true,\n            rentalDays: true,\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Find order by order number (simplified API)\n   */\n  findByNumber: async (orderNumber: string) => {\n    return await prisma.order.findUnique({\n      where: { orderNumber },\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { \n          select: { \n            id: true, \n            name: true,\n          } \n        },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            productId: true,\n            notes: true,\n            rentalDays: true,\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Create new order (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.order.create({\n      data,\n      include: {\n        customer: { select: { id: true, firstName: true, lastName: true, phone: true, email: true } },\n        outlet: { select: { id: true, name: true } },\n        createdBy: { select: { id: true, firstName: true, lastName: true } },\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            productId: true,\n            notes: true,\n            rentalDays: true,\n            product: { select: { id: true, name: true, barcode: true } }\n          }\n        },\n        payments: true\n      }\n    });\n  },\n\n  /**\n   * Update order (simplified API) - Now uses proper updateOrder function\n   */\n  update: async (id: number, data: any) => {\n    return await updateOrder(id, data);\n  },\n\n  /**\n   * Delete order (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.order.delete({\n      where: { id }\n    });\n  },\n\n  /**\n   * Search orders with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { \n      page = 1, \n      limit = 20, \n      sortBy = 'createdAt', \n      sortOrder = 'desc',\n      where: whereClause, \n      ...whereFilters \n    } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause - start with provided where clause if any\n    const where: any = whereClause || {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    // Handle outlet-level filtering                                                                            \n    if (whereFilters.outletId) {\n      // Support both simple values and complex objects like { in: [...] }\n      where.outletId = whereFilters.outletId;\n    }\n    \n    if (whereFilters.customerId) where.customerId = whereFilters.customerId;\n    if (whereFilters.status) where.status = whereFilters.status;\n    if (whereFilters.orderType) where.orderType = whereFilters.orderType;\n    \n    // Filter by product (through order items)\n    if (whereFilters.productId) {\n      where.orderItems = {\n        some: {\n          productId: whereFilters.productId\n        }\n      };\n    }\n    \n    // Date range\n    if (whereFilters.startDate || whereFilters.endDate) {\n      where.createdAt = {};\n      if (whereFilters.startDate) where.createdAt.gte = whereFilters.startDate;\n      if (whereFilters.endDate) where.createdAt.lte = whereFilters.endDate;\n    }\n\n    // Text search (case-insensitive)\n    if (whereFilters.search) {\n      const searchTerm = whereFilters.search.trim();\n      where.OR = [\n        { orderNumber: { contains: searchTerm, mode: 'insensitive' } },\n        { customer: { firstName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { phone: { contains: searchTerm, mode: 'insensitive' } } }\n      ];\n    }\n\n    // âœ… Build dynamic orderBy clause\n    const orderBy: any = {};\n    if (sortBy === 'orderNumber') {\n      orderBy.orderNumber = sortOrder;\n    } else if (sortBy === 'totalAmount') {\n      orderBy.totalAmount = sortOrder;\n    } else if (sortBy === 'customer') {\n      orderBy.customer = { firstName: sortOrder };\n    } else {\n      // Default: createdAt\n      orderBy.createdAt = sortOrder;\n    }\n\n    const [orders, total] = await Promise.all([\n      // OPTIMIZED: Use select instead of include for better performance\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          pickupPlanAt: true,\n          returnPlanAt: true,\n          pickedUpAt: true,\n          returnedAt: true,\n          createdAt: true,\n          updatedAt: true,\n          customer: { \n            select: { \n              id: true, \n              firstName: true, \n              lastName: true, \n              phone: true, \n              email: true \n            } \n          },\n          outlet: { \n            select: { \n              id: true, \n              name: true\n            } \n          },\n          createdBy: { \n            select: { \n              id: true, \n              firstName: true, \n              lastName: true \n            } \n          },\n          // OPTIMIZED: Count instead of loading all items\n          _count: {\n            select: {\n              orderItems: true,\n              payments: true\n            }\n          }\n        },\n        orderBy, // âœ… Dynamic sorting\n        skip,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    console.log(`ðŸ“Š db.orders.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, orders=${orders.length}`);\n\n    return {\n      data: orders,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Find first order matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.order.findFirst({\n      where,\n      include: {\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true\n          }\n        },\n        orderItems: {\n          include: {\n            product: {\n              select: {\n                id: true,\n                name: true,\n                barcode: true\n              }\n            }\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get order statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.order.count({ where });\n  },\n\n  /**\n   * Group orders by field (simplified API)\n   */\n  groupBy: async (args: any) => {\n    return await prisma.order.groupBy(args);\n  },\n\n  /**\n   * Aggregate orders (simplified API)\n   */\n  aggregate: async (args: any) => {\n    return await prisma.order.aggregate(args);\n  },\n\n  // ============================================================================\n  // PERFORMANCE OPTIMIZED METHODS FOR LARGE DATASETS\n  // ============================================================================\n\n  /**\n   * Get orders list with minimal data for performance (for large datasets)\n   * Only essential fields for list view - no nested objects\n   */\n  /**\n   * Search orders with orderItems included (for calendar API)\n   */\n  searchWithItems: async (filters: {\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    productId?: number;\n    startDate?: Date;\n    endDate?: Date;\n    search?: string;\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n    where?: any;\n  } = {}) => {\n    const {\n      // Note: merchantId removed - tenant databases are already isolated per tenant\n      outletId,\n      status,\n      orderType,\n      productId,\n      startDate,\n      endDate,\n      search,\n      page = 1,\n      limit = 1000,\n      sortBy = 'createdAt',\n      sortOrder = 'desc',\n      where: whereClause\n    } = filters;\n\n    // Build where clause\n    const where: any = whereClause || {};\n    \n    console.log('ðŸ” searchWithItems - Original whereClause:', JSON.stringify(whereClause, null, 2));\n\n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    // Remove merchantId from where clause if present (for backward compatibility)\n    if (where.merchantId) {\n      delete where.merchantId;\n    }\n\n    // Handle outlet-level filtering (overrides merchant filter if both are present)\n    if (outletId) {\n      where.outletId = outletId;\n      // Remove outlet filter if outletId is specified\n      delete where.outlet;\n    }\n\n    if (status) where.status = status;\n    if (orderType) where.orderType = orderType;\n\n    // Filter by product (through order items)\n    if (productId) {\n      where.orderItems = {\n        some: {\n          productId: productId\n        }\n      };\n    }\n\n    // Date range\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    // Text search\n    if (search) {\n      where.OR = [\n        { orderNumber: { contains: search } },\n        { customer: { firstName: { contains: search } } },\n        { customer: { lastName: { contains: search } } },\n        { customer: { phone: { contains: search } } }\n      ];\n    }\n\n    const [orders, total] = await Promise.all([\n      prisma.order.findMany({\n        where,\n        include: {\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              email: true,\n            }\n          },\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n            }\n          },\n          orderItems: {\n            include: {\n              product: {\n                select: {\n                  id: true,\n                  name: true,\n                  barcode: true,\n                  images: true,\n                  rentPrice: true,\n                  deposit: true\n                }\n              }\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip: (page - 1) * limit,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    return {\n      data: orders,\n      total,\n      page,\n      limit,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  findManyMinimal: async (filters: {\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    startDate?: Date;\n    endDate?: Date;\n    search?: string;\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  } = {}) => {\n    const {\n      // Note: merchantId removed - tenant databases are already isolated per tenant\n      outletId,\n      status,\n      orderType,\n      startDate,\n      endDate,\n      search,\n      page = 1,\n      limit = 20,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = filters;\n\n    // Build where clause\n    const where: any = {};\n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (outletId) where.outletId = outletId;\n    if (status) where.status = status;\n    if (orderType) where.orderType = orderType;\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n    if (search) {\n      where.OR = [\n        { orderNumber: { contains: search, mode: 'insensitive' } },\n        { customer: { firstName: { contains: search, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: search, mode: 'insensitive' } } },\n        { customer: { phone: { contains: search, mode: 'insensitive' } } }\n      ];\n    }\n\n    const [orders, total] = await Promise.all([\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          notes: true,\n          createdAt: true,\n          updatedAt: true,\n          outletId: true,\n          customerId: true,\n          createdById: true,\n          // Minimal customer data\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              email: true\n            }\n          },\n          // Minimal outlet data\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n              address: true,\n            }\n          },\n          // Minimal createdBy data\n          createdBy: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              email: true\n            }\n          }\n        },\n        orderBy: { [sortBy]: sortOrder },\n        skip: (page - 1) * limit,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    // Get item counts for each order\n    const orderIds = orders.map(order => order.id);\n    const itemCounts = await prisma.orderItem.groupBy({\n      by: ['orderId'],\n      where: { orderId: { in: orderIds } },\n      _count: { id: true }\n    });\n    const itemCountMap = new Map(itemCounts.map(item => [item.orderId, item._count.id]));\n\n    // Get payment counts and totals\n    const paymentCounts = await prisma.payment.groupBy({\n      by: ['orderId'],\n      where: { orderId: { in: orderIds } },\n      _count: { id: true },\n      _sum: { amount: true }\n    });\n    const paymentCountMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._count.id]));\n    const totalPaidMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._sum.amount || 0]));\n\n    // Enhance orders with calculated fields and flattened structure\n    const enhancedOrders = orders.map(order => ({\n      id: order.id,\n      orderNumber: order.orderNumber,\n      orderType: order.orderType,\n      status: order.status,\n      totalAmount: order.totalAmount,\n      depositAmount: order.depositAmount,\n      notes: order.notes,\n      createdAt: order.createdAt,\n      updatedAt: order.updatedAt,\n      \n      // Flatten customer data\n      customerId: order.customerId,\n      customerName: order.customer ? `${order.customer.firstName} ${order.customer.lastName}` : null,\n      customerPhone: order.customer?.phone || null,\n      customerEmail: order.customer?.email || null,\n      \n      // Flatten outlet data\n      outletId: order.outletId,\n      outletName: order.outlet?.name || null,\n      outletAddress: order.outlet?.address || null,\n      \n      // Flatten createdBy data\n      createdById: order.createdById,\n      createdByName: order.createdBy ? `${order.createdBy.firstName} ${order.createdBy.lastName}` : null,\n      createdByEmail: order.createdBy?.email || null,\n      \n      // Calculated fields\n      itemCount: itemCountMap.get(order.id) || 0,\n      paymentCount: paymentCountMap.get(order.id) || 0,\n      totalPaid: totalPaidMap.get(order.id) || 0\n    }));\n\n    return {\n      data: enhancedOrders,\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit)\n      }\n    };\n  },\n\n  /**\n   * Get orders list with complete order information for performance (for large datasets)\n   * Includes all order fields, customer, outlet, createdBy, and products\n   */\n  findManyLightweight: async (filters: {\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    productId?: number;\n    startDate?: Date;\n    endDate?: Date;\n    search?: string;\n    page?: number;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  }) => {\n    const {\n      // Note: merchantId removed - tenant databases are already isolated per tenant\n      outletId,\n      status,\n      orderType,\n      productId,\n      startDate,\n      endDate,\n      search,\n      page = 1,\n      limit = 20,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = filters;\n\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (outletId) {\n      where.outletId = outletId;\n    }\n    if (status) {\n      where.status = status;\n    }\n    if (orderType) {\n      where.orderType = orderType;\n    }\n    \n    // Filter by product (through order items)\n    if (productId) {\n      where.orderItems = {\n        some: {\n          productId: productId\n        }\n      };\n    }\n    \n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    // Search functionality: search in order number, customer name, and customer phone\n    if (search) {\n      const searchTerm = search.trim();\n      where.OR = [\n        { orderNumber: { contains: searchTerm, mode: 'insensitive' } },\n        { customer: { firstName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { lastName: { contains: searchTerm, mode: 'insensitive' } } },\n        { customer: { phone: { contains: searchTerm, mode: 'insensitive' } } }\n      ];\n    }\n\n    const [orders, total] = await Promise.all([\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          depositAmount: true,\n          securityDeposit: true,\n          damageFee: true,\n          lateFee: true,\n          discountType: true,\n          discountValue: true,\n          discountAmount: true,\n          pickupPlanAt: true,\n          returnPlanAt: true,\n          pickedUpAt: true,\n          returnedAt: true,\n          rentalDuration: true,\n          isReadyToDeliver: true,\n          collateralType: true,\n          collateralDetails: true,\n          notes: true,\n          pickupNotes: true,\n          returnNotes: true,\n          damageNotes: true,\n          createdAt: true,\n          updatedAt: true,\n          outletId: true,\n          customerId: true,\n          createdById: true,\n          // Customer data\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true,\n              email: true,\n              address: true,\n              city: true,\n              state: true,\n              zipCode: true,\n              country: true\n            }\n          },\n          // Outlet data\n          outlet: {\n            select: {\n              id: true,\n              name: true,\n              address: true,\n              phone: true,\n              city: true,\n              state: true,\n              zipCode: true,\n              country: true,\n            }\n          },\n          // CreatedBy data\n          createdBy: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              email: true\n            }\n          },\n          // Include products for list view\n          orderItems: {\n            select: {\n              id: true,\n              quantity: true,\n              unitPrice: true,\n              totalPrice: true,\n              notes: true,\n              product: {\n                select: {\n                  id: true,\n                  name: true,\n                  barcode: true,\n                  images: true,\n                  rentPrice: true,\n                  deposit: true\n                }\n              }\n            }\n          }\n        },\n        orderBy: { [sortBy]: sortOrder },\n        skip: (page - 1) * limit,\n        take: limit\n      }),\n      prisma.order.count({ where })\n    ]);\n\n    // Get summary counts for order items and payments (separate queries for performance)\n    const orderIds = orders.map(o => o.id);\n    const [itemCounts, paymentCounts] = await Promise.all([\n      prisma.orderItem.groupBy({\n        by: ['orderId'],\n        where: { orderId: { in: orderIds } },\n        _count: { id: true }\n      }),\n      prisma.payment.groupBy({\n        by: ['orderId'],\n        where: { \n          orderId: { in: orderIds },\n          status: 'COMPLETED'\n        },\n        _sum: { amount: true },\n        _count: { id: true }\n      })\n    ]);\n\n    // Create lookup maps for performance\n    const itemCountMap = new Map(itemCounts.map(item => [item.orderId, item._count.id]));\n    const paymentCountMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._count.id]));\n    const totalPaidMap = new Map(paymentCounts.map(payment => [payment.orderId, payment._sum.amount || 0]));\n\n    // Enhance orders with calculated fields and flattened structure\n    const enhancedOrders = orders.map(order => ({\n      id: order.id,\n      orderNumber: order.orderNumber,\n      orderType: order.orderType,\n      status: order.status,\n      totalAmount: order.totalAmount,\n      depositAmount: order.depositAmount,\n      securityDeposit: order.securityDeposit,\n      damageFee: order.damageFee,\n      lateFee: order.lateFee,\n      discountType: order.discountType,\n      discountValue: order.discountValue,\n      discountAmount: order.discountAmount,\n      pickupPlanAt: order.pickupPlanAt,\n      returnPlanAt: order.returnPlanAt,\n      pickedUpAt: order.pickedUpAt,\n      returnedAt: order.returnedAt,\n      rentalDuration: order.rentalDuration,\n      isReadyToDeliver: order.isReadyToDeliver,\n      collateralType: order.collateralType,\n      collateralDetails: order.collateralDetails,\n      notes: order.notes,\n      pickupNotes: order.pickupNotes,\n      returnNotes: order.returnNotes,\n      damageNotes: order.damageNotes,\n      createdAt: order.createdAt,\n      updatedAt: order.updatedAt,\n      \n      // Flatten customer data (simplified)\n      customerId: order.customerId,\n      customerName: order.customer ? `${order.customer.firstName} ${order.customer.lastName}` : null,\n      customerPhone: order.customer?.phone || null,\n      \n      // Flatten outlet data (simplified)\n      outletId: order.outletId,\n      outletName: order.outlet?.name || null,\n      \n      // Flatten createdBy data\n      createdById: order.createdById,\n      createdByName: order.createdBy ? `${order.createdBy.firstName} ${order.createdBy.lastName}` : null,\n      \n      // Order items with flattened product data\n      orderItems: order.orderItems?.map(item => ({\n        id: item.id,\n        quantity: item.quantity,\n        unitPrice: item.unitPrice,\n        totalPrice: item.totalPrice,\n        notes: item.notes,\n        // Flatten product data\n        productId: item.product?.id,\n        productName: item.product?.name,\n        productBarcode: item.product?.barcode,\n        productImages: item.product?.images ? \n          (Array.isArray(item.product.images) ? item.product.images : []) : [],\n        productRentPrice: item.product?.rentPrice,\n        productDeposit: item.product?.deposit\n      })) || [],\n      \n      // Calculated fields\n      itemCount: itemCountMap.get(order.id) || 0,\n      paymentCount: paymentCountMap.get(order.id) || 0,\n      totalPaid: totalPaidMap.get(order.id) || 0\n    }));\n\n    return {\n      data: enhancedOrders,\n      total,\n      page,\n      limit,\n      hasMore: page * limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  /**\n   * Get order by ID with full detail data\n   * Includes all order fields, customer, outlet, products, payments, and timeline\n   */\n  findByIdDetail: async (id: number) => {\n    const order = await prisma.order.findUnique({\n      where: { id },\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        securityDeposit: true,\n        damageFee: true,\n        lateFee: true,\n        discountType: true,\n        discountValue: true,\n        discountAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        rentalDuration: true,\n        isReadyToDeliver: true,\n        collateralType: true,\n        collateralDetails: true,\n        notes: true,\n        pickupNotes: true,\n        returnNotes: true,\n        damageNotes: true,\n        createdAt: true,\n        updatedAt: true,\n        outletId: true,\n        customerId: true,\n        createdById: true,\n        \n        // Full customer data\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n            address: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            dateOfBirth: true,\n            notes: true,\n            createdAt: true,\n            updatedAt: true\n          }\n        },\n        \n        // Full outlet data\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n            address: true,\n            phone: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n            isActive: true,\n          }\n        },\n        \n        // Full createdBy data\n        createdBy: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true,\n            phone: true,\n            role: true,\n            isActive: true,\n            createdAt: true\n          }\n        },\n        \n        // Full order items with products\n        orderItems: {\n          select: {\n            id: true,\n            orderId: true,\n            productId: true,\n            productName: true,\n            productBarcode: true,\n            productImages: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            deposit: true,\n            notes: true,\n            rentalDays: true,\n            product: {\n              select: {\n                id: true,\n                name: true,\n                barcode: true,\n                images: true,\n                rentPrice: true,\n                deposit: true,\n                description: true,\n                isActive: true,\n                category: {\n                  select: {\n                    id: true,\n                    name: true,\n                    description: true\n                  }\n                }\n              }\n            }\n          }\n        },\n        \n        // Full payments data\n        payments: {\n          select: {\n            id: true,\n            amount: true,\n            method: true,\n            status: true,\n            reference: true,\n            notes: true,\n            processedAt: true,\n            createdAt: true,\n            updatedAt: true\n          },\n          orderBy: { createdAt: 'desc' }\n        }\n      }\n    });\n\n    if (!order) return null;\n\n    // Get order timeline/audit log (if exists)\n    let timeline: any[] = [];\n    try {\n      timeline = await (prisma as any).orderAuditLog?.findMany({\n        where: { orderId: id },\n        select: {\n          id: true,\n          action: true,\n          description: true,\n          oldValues: true,\n          newValues: true,\n          createdAt: true,\n          createdBy: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              email: true\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' }\n      }) || [];\n    } catch (error) {\n      // OrderAuditLog table might not exist\n      console.log('OrderAuditLog table not found, skipping timeline');\n    }\n\n    // Calculate additional fields\n    const itemCount = (order as any).orderItems?.length || 0;\n    const paymentCount = (order as any).payments?.length || 0;\n    const totalPaid = (order as any).payments\n      ?.filter((p: any) => p.status === 'COMPLETED')\n      .reduce((sum: number, p: any) => sum + p.amount, 0) || 0;\n\n    return {\n      ...order,\n      // Calculated fields\n      itemCount,\n      paymentCount,\n      totalPaid,\n      // Timeline\n      timeline\n    };\n  },\n\n  /**\n   * Get order detail with optimized loading\n   * Loads related data only when needed\n   */\n  findByIdOptimized: async (id: number, options: {\n    includeItems?: boolean;\n    includePayments?: boolean;\n    includeCustomer?: boolean;\n    includeOutlet?: boolean;\n  } = {}) => {\n    const {\n      includeItems = true,\n      includePayments = true,\n      includeCustomer = true,\n      includeOutlet = true\n    } = options;\n\n    const select: any = {\n      id: true,\n      orderNumber: true,\n      orderType: true,\n      status: true,\n      totalAmount: true,\n      depositAmount: true,\n      securityDeposit: true,\n      damageFee: true,\n      lateFee: true,\n      discountType: true,\n      discountValue: true,\n      discountAmount: true,\n      pickupPlanAt: true,\n      returnPlanAt: true,\n      pickedUpAt: true,\n      returnedAt: true,\n      rentalDuration: true,\n      isReadyToDeliver: true,\n      collateralType: true,\n      collateralDetails: true,\n      notes: true,\n      pickupNotes: true,\n      returnNotes: true,\n      damageNotes: true,\n      createdAt: true,\n      updatedAt: true,\n      outletId: true,\n      customerId: true,\n      createdById: true\n    };\n\n    // Conditionally include relations based on options\n    if (includeCustomer) {\n      select.customer = {\n        select: {\n          id: true,\n          firstName: true,\n          lastName: true,\n          phone: true,\n          email: true,\n          address: true,\n          city: true,\n          state: true,\n          zipCode: true,\n          country: true,\n          dateOfBirth: true,\n          idNumber: true,\n          idType: true\n        }\n      };\n    }\n\n    if (includeOutlet) {\n      select.outlet = {\n        select: {\n          id: true,\n          name: true,\n          address: true,\n          phone: true,\n          city: true,\n          state: true,\n          zipCode: true,\n          country: true\n        }\n      };\n    }\n\n    select.createdBy = {\n      select: {\n        id: true,\n        firstName: true,\n        lastName: true,\n        email: true\n      }\n    };\n\n    if (includeItems) {\n      select.orderItems = {\n        select: {\n          id: true,\n          quantity: true,\n          unitPrice: true,\n          totalPrice: true,\n          deposit: true,\n          productId: true,\n          notes: true,\n          rentalDays: true,\n          product: {\n            select: {\n              id: true,\n              name: true,\n              barcode: true,\n              description: true,\n              images: true,\n              category: {\n                select: {\n                  id: true,\n                  name: true\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n\n    if (includePayments) {\n      select.payments = {\n        select: {\n          id: true,\n          amount: true,\n          currency: true,\n          method: true,\n          type: true,\n          status: true,\n          reference: true,\n          transactionId: true,\n          invoiceNumber: true,\n          description: true,\n          notes: true,\n          failureReason: true,\n          processedAt: true,\n          processedBy: true,\n          createdAt: true\n        }\n      };\n    }\n\n    return await prisma.order.findUnique({\n      where: { id },\n      select\n    });\n  },\n\n  /**\n   * Search orders with cursor-based pagination for large datasets\n   * More efficient than offset-based pagination for large datasets\n   * Includes complete order information and products\n   */\n  searchWithCursor: async (filters: {\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    outletId?: number;\n    status?: string;\n    orderType?: string;\n    startDate?: Date;\n    endDate?: Date;\n    cursor?: string;\n    limit?: number;\n    sortBy?: string;\n    sortOrder?: 'asc' | 'desc';\n  }) => {\n    const {\n      // Note: merchantId removed - tenant databases are already isolated per tenant\n      outletId,\n      status,\n      orderType,\n      startDate,\n      endDate,\n      cursor,\n      limit = 20,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = filters;\n\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (outletId) {\n      where.outletId = outletId;\n    }\n    if (status) {\n      where.status = status;\n    }\n    if (orderType) {\n      where.orderType = orderType;\n    }\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    // Add cursor condition for pagination\n    if (cursor) {\n      const cursorCondition = sortOrder === 'desc' \n        ? { [sortBy]: { lt: new Date(cursor) } }\n        : { [sortBy]: { gt: new Date(cursor) } };\n      where.AND = [cursorCondition];\n    }\n\n    const orders = await prisma.order.findMany({\n      where,\n      select: {\n        id: true,\n        orderNumber: true,\n        orderType: true,\n        status: true,\n        totalAmount: true,\n        depositAmount: true,\n        securityDeposit: true,\n        damageFee: true,\n        lateFee: true,\n        discountType: true,\n        discountValue: true,\n        discountAmount: true,\n        pickupPlanAt: true,\n        returnPlanAt: true,\n        pickedUpAt: true,\n        returnedAt: true,\n        rentalDuration: true,\n        isReadyToDeliver: true,\n        collateralType: true,\n        collateralDetails: true,\n        notes: true,\n        pickupNotes: true,\n        returnNotes: true,\n        damageNotes: true,\n        createdAt: true,\n        updatedAt: true,\n        outletId: true,\n        customerId: true,\n        createdById: true,\n        customer: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            phone: true,\n            email: true,\n            address: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true\n          }\n        },\n        outlet: {\n          select: {\n            id: true,\n            name: true,\n            address: true,\n            phone: true,\n            city: true,\n            state: true,\n            zipCode: true,\n            country: true,\n          }\n        },\n        createdBy: {\n          select: {\n            id: true,\n            firstName: true,\n            lastName: true,\n            email: true\n          }\n        },\n        // Include products for list view\n        orderItems: {\n          select: {\n            id: true,\n            quantity: true,\n            unitPrice: true,\n            totalPrice: true,\n            notes: true,\n            product: {\n              select: {\n                id: true,\n                name: true,\n                barcode: true,\n                images: true,\n                rentPrice: true,\n                deposit: true\n              }\n            }\n          }\n        }\n      },\n      orderBy: { [sortBy]: sortOrder },\n      take: limit + 1 // Take one extra to check if there are more\n    });\n\n    const hasMore = orders.length > limit;\n    if (hasMore) {\n      orders.pop(); // Remove the extra item\n    }\n\n    const nextCursor = hasMore && orders.length > 0 \n      ? orders[orders.length - 1][sortBy as keyof typeof orders[0]]?.toString()\n      : null;\n\n    return {\n      data: orders,\n      hasMore,\n      nextCursor\n    };\n  },\n\n  /**\n   * Get order statistics for dashboard (optimized aggregation)\n   */\n  getStatistics: async (filters: {\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    outletId?: number;\n    startDate?: Date;\n    endDate?: Date;\n  }) => {\n    const { \n      // Note: merchantId removed - tenant databases are already isolated per tenant\n      outletId, \n      startDate, \n      endDate \n    } = filters;\n\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (outletId) {\n      where.outletId = outletId;\n    }\n    if (startDate || endDate) {\n      where.createdAt = {};\n      if (startDate) where.createdAt.gte = startDate;\n      if (endDate) where.createdAt.lte = endDate;\n    }\n\n    const [\n      totalOrders,\n      totalRevenue,\n      statusBreakdown,\n      typeBreakdown,\n      recentOrders\n    ] = await Promise.all([\n      // Total orders count\n      prisma.order.count({ where }),\n      \n      // Total revenue\n      prisma.order.aggregate({\n        where,\n        _sum: { totalAmount: true }\n      }),\n      \n      // Status breakdown\n      prisma.order.groupBy({\n        by: ['status'],\n        where,\n        _count: { id: true }\n      }),\n      \n      // Type breakdown\n      prisma.order.groupBy({\n        by: ['orderType'],\n        where,\n        _count: { id: true }\n      }),\n      \n      // Recent orders (last 10)\n      prisma.order.findMany({\n        where,\n        select: {\n          id: true,\n          orderNumber: true,\n          orderType: true,\n          status: true,\n          totalAmount: true,\n          createdAt: true,\n          customer: {\n            select: {\n              id: true,\n              firstName: true,\n              lastName: true,\n              phone: true\n            }\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        take: 10\n      })\n    ]);\n\n    return {\n      totalOrders,\n      totalRevenue: totalRevenue._sum.totalAmount || 0,\n      statusBreakdown: statusBreakdown.reduce((acc, item) => {\n        acc[item.status] = item._count.id;\n        return acc;\n      }, {} as Record<string, number>),\n      typeBreakdown: typeBreakdown.reduce((acc, item) => {\n        acc[item.orderType] = item._count.id;\n        return acc;\n      }, {} as Record<string, number>),\n      recentOrders\n    };\n  }\n};","import { prisma } from './client';\nimport type { Prisma } from '@prisma/client';\n\n/**\n * Create payment\n */\nexport async function createPayment(data: Prisma.PaymentCreateInput) {\n  return await prisma.payment.create({\n    data,\n    include: {\n      order: {\n        include: {\n          customer: { select: { firstName: true, lastName: true } },\n          outlet: { select: { name: true } }\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find payment by ID\n */\nexport async function findById(id: number) {\n  return await prisma.payment.findUnique({\n    where: { id },\n    include: {\n      order: {\n        include: {\n          customer: { select: { firstName: true, lastName: true } },\n          outlet: { select: { name: true } }\n        }\n      }\n    }\n  });\n}\n\n/**\n * Find payments by subscription ID\n */\nexport async function findBySubscriptionId(subscriptionId: number, options: { limit?: number } = {}) {\n  const { limit = 20 } = options;\n  \n  return await prisma.payment.findMany({\n    where: { subscriptionId },\n    orderBy: { createdAt: 'desc' },\n    take: limit\n  });\n}\n\n/**\n * Search payments with pagination\n */\nexport async function searchPayments(filters: any) {\n  const { where, include, orderBy, take = 20, skip = 0 } = filters;\n  \n  const [payments, total] = await Promise.all([\n    prisma.payment.findMany({\n      where,\n      include,\n      orderBy,\n      take,\n      skip\n    }),\n    prisma.payment.count({ where })\n  ]);\n\n  return {\n    data: payments,\n    total,\n    page: Math.floor(skip / take) + 1,\n    limit: take,\n    hasMore: skip + take < total\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED PAYMENTS API\n// ============================================================================\n\nexport const simplifiedPayments = {\n  /**\n   * Create payment (simplified API)\n   */\n  create: createPayment,\n\n  /**\n   * Find payment by ID (simplified API)\n   */\n  findById,\n\n  /**\n   * Find payments by subscription ID (simplified API)\n   */\n  findBySubscriptionId,\n\n  /**\n   * Search payments (simplified API)\n   */\n  search: searchPayments,\n\n  /**\n   * Find first payment matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.payment.findFirst({\n      where,\n      include: {\n        order: {\n          select: {\n            id: true,\n            orderNumber: true,\n            totalAmount: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get payment statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.payment.count({ where });\n  },\n\n  /**\n   * Group payments by field (simplified API)\n   */\n  groupBy: async (args: any) => {\n    return await prisma.payment.groupBy(args);\n  },\n\n  /**\n   * Aggregate payments (simplified API)\n   */\n  aggregate: async (args: any) => {\n    return await prisma.payment.aggregate(args);\n  }\n};\n","// ============================================================================\n// OUTLET DATABASE FUNCTIONS\n// ============================================================================\n// This file contains outlet functions that use integer ID system:\n// - Input: id (number)\n// - Database: queries by id (integer), uses integer IDs for relationships\n// - Return: includes id (number)\n\nimport { prisma } from './client';\nimport type { \n  OutletCreateInput, \n  OutletUpdateInput, \n  OutletSearchFilter,\n  OutletSearchResponse \n} from '@rentalshop/types';\n\n// ============================================================================\n// OUTLET SEARCH FUNCTIONS\n// ============================================================================\n\n/**\n * Get default outlet\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getDefaultOutlet(): Promise<any> {\n  const outlet = await prisma.outlet.findFirst({\n    where: {\n      isDefault: true,\n      isActive: true\n    },\n    select: {\n      id: true,\n      name: true,\n    }\n  });\n\n  if (!outlet) {\n    throw new Error(`No default outlet found`);\n  }\n\n  return outlet;\n}\n\n/**\n * Search outlets - follows dual ID system\n * Input: ids (numbers), Output: ids (numbers)\n */\nexport async function searchOutlets(filters: OutletSearchFilter): Promise<OutletSearchResponse> {\n  const {\n    outletId, // Add outletId filter for outlet-level users\n    isActive,\n    search,\n    page = 1,\n    limit = 20\n  } = filters;\n\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {};\n\n  // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n\n  // Outlet-level filtering: Users can only see their assigned outlet\n  if (outletId) {\n    // Find outlet by id\n    const outlet = await prisma.outlet.findUnique({\n      where: { id: outletId },\n      select: { id: true }\n    });\n    \n    if (outlet) {\n      where.id = outlet.id;\n    }\n  }\n\n  // Only filter by isActive if explicitly provided\n  if (isActive !== undefined) {\n    where.isActive = isActive;\n  }\n\n  if (search) {\n    where.OR = [\n      { name: { contains: search, mode: 'insensitive' } },\n      { address: { contains: search, mode: 'insensitive' } },\n      { description: { contains: search, mode: 'insensitive' } }\n    ];\n  }\n\n  // Get total count\n  const total = await prisma.outlet.count({ where });\n\n  // Get outlets with pagination\n  const outlets = await prisma.outlet.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n    },\n    orderBy: { createdAt: 'desc' },\n    take: limit,\n    skip: skip\n  });\n\n  // Transform to match expected types\n  const transformedOutlets = outlets.map((outlet: any) => ({\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    isDefault: outlet.isDefault || false,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n  }));\n\n  return {\n    outlets: transformedOutlets,\n    total,\n    page,\n    limit,\n    totalPages: Math.ceil(total / limit),\n    hasMore: skip + limit < total,\n  };\n}\n\n/**\n * Get all outlets\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function getAllOutlets() {\n  const outlets = await prisma.outlet.findMany({\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  // Transform to match expected types\n  return outlets.map((outlet: any) => ({\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    isDefault: outlet.isDefault || false,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n  }));\n}\n\n/**\n * Get outlet by public ID - follows dual ID system\n */\nexport async function getOutletByPublicId(id: number) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n    }\n  });\n\n  if (!outlet) return null;\n\n  // Transform to match expected types\n  return {\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address,\n    phone: outlet.phone,\n    description: outlet.description,\n    isActive: outlet.isActive,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n  };\n}\n\n/**\n * Create outlet\n * Note: In multi-tenant setup, tenant databases are already isolated per tenant\n */\nexport async function createOutlet(input: OutletCreateInput) {\n  // Generate unique id\n  const id = Math.floor(Math.random() * 1000000) + 100000;\n\n  const outlet = await prisma.outlet.create({\n    data: {\n      id,\n      name: input.name.trim(),\n      address: input.address?.trim(),\n      phone: input.phone?.trim(),\n      description: input.description?.trim(),\n      isActive: true\n    },\n    select: {\n      id: true,\n      name: true,\n      address: true,\n      phone: true,\n      description: true,\n      isActive: true,\n      createdAt: true,\n      updatedAt: true,\n    }\n  });\n\n  // Transform to match expected types\n  return {\n    id: outlet.id, // Return id as \"id\" to frontend\n    name: outlet.name,\n    address: outlet.address || undefined,\n    phone: outlet.phone || undefined,\n    description: outlet.description || undefined,\n    isActive: outlet.isActive,\n    createdAt: outlet.createdAt,\n    updatedAt: outlet.updatedAt,\n  };\n}\n\n/**\n * Update outlet - follows dual ID system\n */\nexport async function updateOutlet(id: number, input: OutletUpdateInput) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: { id: true, name: true, isDefault: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${id} not found`);\n  }\n\n  // Prevent disabling default outlets\n  if (outlet.isDefault && input.isActive === false) {\n    throw new Error('Default outlet cannot be disabled');\n  }\n\n  const updatedOutlet = await prisma.outlet.update({\n    where: { id: outlet.id },\n    data: {\n      ...(input.name !== undefined && { name: input.name.trim() }),\n      ...(input.address !== undefined && { address: input.address?.trim() }),\n      ...(input.phone !== undefined && { phone: input.phone?.trim() }),\n      ...(input.city !== undefined && { city: input.city?.trim() }),\n      ...(input.state !== undefined && { state: input.state?.trim() }),\n      ...(input.zipCode !== undefined && { zipCode: input.zipCode?.trim() }),\n      ...(input.country !== undefined && { country: input.country?.trim() }),\n      ...(input.description !== undefined && { description: input.description?.trim() }),\n      ...(input.isActive !== undefined && { isActive: input.isActive })\n    },\n  });\n\n  // Transform to match expected types\n  return {\n    id: updatedOutlet.id, // Return id as \"id\" to frontend\n    name: updatedOutlet.name,\n    address: updatedOutlet.address || undefined,\n    phone: updatedOutlet.phone || undefined,\n    city: (updatedOutlet as any).city || undefined,\n    state: (updatedOutlet as any).state || undefined,\n    zipCode: (updatedOutlet as any).zipCode || undefined,\n    country: (updatedOutlet as any).country || undefined,\n    description: updatedOutlet.description || undefined,\n    isActive: updatedOutlet.isActive,\n    createdAt: updatedOutlet.createdAt,\n    updatedAt: updatedOutlet.updatedAt,\n  };\n}\n\n/**\n * Delete outlet - follows dual ID system\n */\nexport async function deleteOutlet(id: number) {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${id} not found`);\n  }\n\n  await prisma.outlet.delete({\n    where: { id: outlet.id }\n  });\n\n  return { success: true };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedOutlets = {\n  /**\n   * Find outlet by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.outlet.findUnique({\n      where: { id },\n      include: {\n        _count: {\n          select: { \n            users: true,\n            orders: true,\n            products: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new outlet (simplified API)\n   */\n  create: async (data: any) => {\n    try {\n      console.log('ðŸ” simplifiedOutlets.create called with data:', data);\n      \n      // Remove merchant connection if present (not needed in tenant DBs)\n      const { merchant, ...outletData } = data;\n      \n      const outlet = await prisma.outlet.create({\n        data: outletData,\n      });\n      \n      console.log('âœ… Outlet created successfully:', outlet);\n      return outlet;\n    } catch (error) {\n      console.error('âŒ Error in simplifiedOutlets.create:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Update outlet (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    // Remove merchant connection if present (not needed in tenant DBs)\n    const { merchant, ...outletData } = data;\n    return await prisma.outlet.update({\n      where: { id },\n      data: outletData,\n    });\n  },\n\n  /**\n   * Find first outlet matching criteria (simplified API)\n   */\n  findFirst: async (where: any) => {\n    return await prisma.outlet.findFirst({\n      where,\n      include: {\n        _count: {\n          select: { \n            users: true,\n            orders: true,\n            products: true\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Get outlet statistics (simplified API)\n   */\n  getStats: async (options: any) => {\n    return await prisma.outlet.count(options.where);\n  },\n\n  /**\n   * Update multiple outlets (simplified API)\n   */\n  updateMany: async (where: any, data: any) => {\n    return await prisma.outlet.updateMany({\n      where,\n      data\n    });\n  },\n\n  /**\n   * Search outlets with pagination (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc', ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    console.log('ðŸ” DB outlet.search - Received filters:', filters);\n    console.log('ðŸ” DB outlet.search - whereFilters:', whereFilters);\n\n    // Build where clause\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (whereFilters.outletId) where.id = whereFilters.outletId;\n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.status) where.status = whereFilters.status;\n    \n    // Text search across multiple fields - ONLY search by name\n    const searchTerm = whereFilters.search?.trim();\n    console.log('ðŸ” DB outlet.search - searchTerm:', searchTerm, 'length:', searchTerm?.length);\n    \n    if (searchTerm && searchTerm.length > 0) {\n      where.name = { \n        contains: searchTerm, \n        mode: 'insensitive' \n      };\n      console.log('âœ… DB outlet.search - Added name filter:', where.name);\n    } else {\n      console.log('âš ï¸ DB outlet.search - No search term, will return all outlets for this merchant');\n    }\n    \n    console.log('ðŸ” DB outlet.search - Final where clause:', JSON.stringify(where, null, 2));\n\n    // Specific field filters (not used in current implementation)\n    if (whereFilters.name) where.name = { contains: whereFilters.name, mode: 'insensitive' };\n    if (whereFilters.address) where.address = { contains: whereFilters.address, mode: 'insensitive' };\n    if (whereFilters.phone) where.phone = { contains: whereFilters.phone, mode: 'insensitive' };\n\n    // Build orderBy based on sortBy and sortOrder\n    const orderBy: any = {};\n    if (sortBy === 'name' || sortBy === 'createdAt' || sortBy === 'updatedAt') {\n      orderBy[sortBy] = sortOrder;\n    } else {\n      orderBy.createdAt = 'desc'; // Default\n    }\n\n    const [outlets, total] = await Promise.all([\n      prisma.outlet.findMany({\n        where,\n        include: {\n          _count: {\n            select: { \n              users: true,\n              orders: true\n            }\n          }\n        },\n        orderBy,\n        skip,\n        take: limit\n      }),\n      prisma.outlet.count({ where })\n    ]);\n\n    console.log(`ðŸ“Š db.outlets.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, outlets=${outlets.length}`);\n\n    return {\n      data: outlets,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total,\n      totalPages: Math.ceil(total / limit)\n    };\n  },\n\n  count: async (options?: { where?: any }) => {\n    const where = options?.where || {};\n    return await prisma.outlet.count({ where });\n  }\n};\n","// ============================================================================\n// PLAN DATABASE FUNCTIONS - MODERN SUBSCRIPTION SYSTEM\n// ============================================================================\n\nimport { prisma } from './client';\nimport type { Plan, PlanCreateInput, PlanUpdateInput, PlanFilters } from '@rentalshop/types';\nimport { calculatePlanPricing } from './subscription';\n\n/**\n * Helper function to generate pricing object for a plan\n */\nfunction generatePlanPricing(basePrice: number) {\n  return {\n    monthly: {\n      price: basePrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: basePrice * 3 * 0.95, // 5% discount for quarterly\n      discount: 5,\n      savings: basePrice * 3 * 0.05\n    },\n    yearly: {\n      price: basePrice * 12 * 0.85, // 15% discount for yearly\n      discount: 15,\n      savings: basePrice * 12 * 0.15\n    }\n  };\n}\n\n/**\n * Get plan by public ID\n */\nexport async function getPlanById(id: number): Promise<Plan | null> {\n  try {\n    const plan = await prisma.plan.findUnique({\n      where: { id }\n    });\n\n    if (!plan) return null;\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error getting plan by public ID:', error);\n    throw error;\n  }\n}\n\n/**\n * Get all plans\n */\nexport async function getAllPlans(): Promise<Plan[]> {\n  try {\n    const plans = await prisma.plan.findMany({\n      where: { isActive: true },\n      orderBy: { sortOrder: 'asc' }\n    });\n\n    return plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Error getting all plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Search plans with filters\n */\nexport async function searchPlans(filters: PlanFilters = {}): Promise<{ plans: Plan[]; total: number; hasMore: boolean }> {\n  try {\n    const where: any = {};\n\n    // Apply filters\n    if (filters.search) {\n      where.OR = [\n        { name: { contains: filters.search, mode: 'insensitive' } },\n        { description: { contains: filters.search, mode: 'insensitive' } }\n      ];\n    }\n\n    if (filters.isActive !== undefined) {\n      where.isActive = filters.isActive;\n    }\n\n    if (filters.isPopular !== undefined) {\n      where.isPopular = filters.isPopular;\n    }\n\n    // Get total count\n    const total = await prisma.plan.count({ where });\n\n    // Get plans with pagination\n    const plans = await prisma.plan.findMany({\n      where,\n      orderBy: { sortOrder: 'asc' },\n      take: filters.limit || 20,\n      skip: filters.offset || 0\n    });\n\n    const transformedPlans = plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n\n    return {\n      plans: transformedPlans,\n      total,\n      hasMore: (filters.offset || 0) + (filters.limit || 20) < total\n    };\n  } catch (error) {\n    console.error('Error searching plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Create a new plan\n */\nexport async function createPlan(data: PlanCreateInput): Promise<Plan> {\n  try {\n    const plan = await prisma.plan.create({\n      data: {\n        name: data.name,\n        description: data.description,\n        basePrice: data.basePrice,\n        currency: data.currency || 'USD',\n        trialDays: data.trialDays,\n        limits: JSON.stringify(data.limits),\n        features: JSON.stringify(data.features),\n        isActive: data.isActive ?? true,\n        isPopular: data.isPopular ?? false,\n        sortOrder: data.sortOrder ?? 0\n      }\n    });\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error creating plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Update a plan\n */\nexport async function updatePlan(id: number, data: PlanUpdateInput): Promise<Plan | null> {\n  try {\n    const plan = await prisma.plan.update({\n      where: { id },\n      data: {\n        ...(data.name && { name: data.name }),\n        ...(data.description && { description: data.description }),\n        ...(data.basePrice && { basePrice: data.basePrice }),\n        ...(data.currency && { currency: data.currency }),\n        ...(data.trialDays && { trialDays: data.trialDays }),\n        ...(data.limits && {\n          limits: JSON.stringify(data.limits)\n        }),\n        ...(data.features && { features: JSON.stringify(data.features) }),\n        ...(data.isActive !== undefined && { isActive: data.isActive }),\n        ...(data.isPopular !== undefined && { isPopular: data.isPopular }),\n        ...(data.sortOrder !== undefined && { sortOrder: data.sortOrder })\n      }\n    });\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    };\n  } catch (error) {\n    console.error('Error updating plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Delete a plan (soft delete)\n */\nexport async function deletePlan(id: number): Promise<boolean> {\n  try {\n    await prisma.plan.update({\n      where: { id },\n      data: { \n        isActive: false,\n        deletedAt: new Date()\n      }\n    });\n    return true;\n  } catch (error) {\n    console.error('Error deleting plan:', error);\n    throw error;\n  }\n}\n\n/**\n * Get active plans\n */\nexport async function getActivePlans(): Promise<Plan[]> {\n  try {\n    const plans = await prisma.plan.findMany({\n      where: { \n        isActive: true,\n        deletedAt: null\n      },\n      orderBy: { sortOrder: 'asc' }\n    });\n\n    return plans.map((plan: any) => ({\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n    }));\n  } catch (error) {\n    console.error('Error getting active plans:', error);\n    throw error;\n  }\n}\n\n/**\n * Get plan statistics\n */\nexport async function getPlanStats() {\n  try {\n    const [totalPlans, activePlans, popularPlans] = await Promise.all([\n      prisma.plan.count(),\n      prisma.plan.count({ where: { isActive: true } }),\n      prisma.plan.count({ where: { isPopular: true } })\n    ]);\n\n    return {\n      totalPlans,\n      activePlans,\n      popularPlans\n    };\n  } catch (error) {\n    console.error('Error getting plan stats:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedPlans = {\n  /**\n   * Find plan by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.plan.findUnique({\n      where: { id }\n    });\n  },\n\n  /**\n   * Find plan by name (simplified API)\n   */\n  findByName: async (name: string) => {\n    return await prisma.plan.findFirst({\n      where: { \n        name,\n        isActive: true \n      }\n    });\n  },\n\n  /**\n   * Create new plan (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.plan.create({\n      data\n    });\n  },\n\n  /**\n   * Update plan (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.plan.update({\n      where: { id },\n      data\n    });\n  },\n\n  /**\n   * Delete plan (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.plan.delete({\n      where: { id }\n    });\n  },\n\n  /**\n   * Search plans with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;\n    if (whereFilters.isPopular !== undefined) where.isPopular = whereFilters.isPopular;\n    \n    // Text search\n    if (whereFilters.search) {\n      where.OR = [\n        { name: { contains: whereFilters.search } },\n        { description: { contains: whereFilters.search } }\n      ];\n    }\n\n    // Price range\n    if (whereFilters.minPrice !== undefined || whereFilters.maxPrice !== undefined) {\n      where.basePrice = {};\n      if (whereFilters.minPrice !== undefined) where.basePrice.gte = whereFilters.minPrice;\n      if (whereFilters.maxPrice !== undefined) where.basePrice.lte = whereFilters.maxPrice;\n    }\n\n    const [plans, total] = await Promise.all([\n      prisma.plan.findMany({\n        where,\n        orderBy: { sortOrder: 'asc' },\n        skip,\n        take: limit\n      }),\n      prisma.plan.count({ where })\n    ]);\n\n    return {\n      data: plans,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  /**\n   * Find first plan matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    const plan = await prisma.plan.findFirst({\n      where,\n      include: {\n        subscriptions: {\n          select: {\n            id: true,\n            // Note: merchantId removed - tenant databases are already isolated per tenant\n            status: true\n          }\n        }\n      }\n    });\n\n    if (!plan) return null;\n\n    return {\n      id: plan.id,\n      name: plan.name,\n      description: plan.description,\n      basePrice: plan.basePrice,\n      currency: plan.currency,\n      trialDays: plan.trialDays,\n      limits: JSON.parse(plan.limits as string),\n      features: JSON.parse(plan.features || '[]'),\n      isActive: plan.isActive,\n      isPopular: plan.isPopular,\n      sortOrder: plan.sortOrder,\n      pricing: generatePlanPricing(plan.basePrice),\n      createdAt: plan.createdAt,\n      updatedAt: plan.updatedAt,\n      subscriptions: plan.subscriptions\n    };\n  },\n\n  /**\n   * Get plan statistics (simplified API)\n   */\n  getStats: async () => {\n    const [totalPlans, activePlans, popularPlans] = await Promise.all([\n      prisma.plan.count(),\n      prisma.plan.count({ where: { isActive: true } }),\n      prisma.plan.count({ where: { isPopular: true } })\n    ]);\n\n    return {\n      totalPlans,\n      activePlans,\n      popularPlans\n    };\n  }\n};","// ============================================================================\n// SIMPLIFIED SUBSCRIPTION DATABASE FUNCTIONS\n// ============================================================================\n\nimport { prisma } from './client';\nimport { calculateSubscriptionPrice, getPricingBreakdown } from '@rentalshop/utils';\nimport type { \n  Subscription, \n  Plan, \n  PlanLimits,\n  SubscriptionCreateInput, \n  SubscriptionUpdateInput,\n  SubscriptionStatus,\n  BillingInterval\n} from '@rentalshop/types';\n\n// ============================================================================\n// PRICING UTILITIES\n// ============================================================================\n\n/**\n * Generate pricing object from base price\n */\nfunction generatePricingFromBasePrice(basePrice: number) {\n  const monthlyPrice = basePrice;\n  const quarterlyPrice = monthlyPrice * 3;\n  const sixMonthsPrice = monthlyPrice * 6;\n  const yearlyPrice = monthlyPrice * 12;\n  \n  return {\n    monthly: {\n      price: monthlyPrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: quarterlyPrice,\n      discount: 5, // 5% discount for quarterly\n      savings: quarterlyPrice * 0.05\n    },\n    sixMonths: {\n      price: sixMonthsPrice,\n      discount: 10, // 10% discount for 6 months\n      savings: sixMonthsPrice * 0.10\n    },\n    yearly: {\n      price: yearlyPrice,\n      discount: 15, // 15% discount for yearly\n      savings: yearlyPrice * 0.15\n    }\n  };\n}\n\n/**\n * Convert Prisma plan object to our Plan type\n */\nfunction convertPrismaPlanToPlan(prismaPlan: any): Plan {\n  return {\n    id: prismaPlan.id,\n    name: prismaPlan.name,\n    description: prismaPlan.description,\n    basePrice: prismaPlan.basePrice,\n    currency: prismaPlan.currency,\n    trialDays: prismaPlan.trialDays,\n    limits: JSON.parse(prismaPlan.limits as string) as PlanLimits,\n    features: JSON.parse(prismaPlan.features as string) as string[],\n    isActive: prismaPlan.isActive,\n    isPopular: prismaPlan.isPopular,\n    sortOrder: prismaPlan.sortOrder,\n    pricing: generatePricingFromBasePrice(prismaPlan.basePrice),\n    createdAt: prismaPlan.createdAt,\n    updatedAt: prismaPlan.updatedAt,\n    deletedAt: prismaPlan.deletedAt || undefined\n  };\n}\n\n/**\n * Helper function to generate pricing object for a plan\n */\nfunction generatePlanPricing(basePrice: number) {\n  return {\n    monthly: {\n      price: basePrice,\n      discount: 0,\n      savings: 0\n    },\n    quarterly: {\n      price: basePrice * 3 * 0.95, // 5% discount for quarterly\n      discount: 5,\n      savings: basePrice * 3 * 0.05\n    },\n    sixMonths: {\n      price: basePrice * 6 * 0.90, // 10% discount for 6 months\n      discount: 10,\n      savings: basePrice * 6 * 0.10\n    },\n    yearly: {\n      price: basePrice * 12 * 0.85, // 15% discount for yearly\n      discount: 15,\n      savings: basePrice * 12 * 0.15\n    }\n  };\n}\n\n/**\n * Helper function to transform database plan to Plan type\n */\nfunction transformPlanFromDb(plan: any): Plan {\n  return {\n    id: plan.id,\n    name: plan.name,\n    description: plan.description,\n    basePrice: plan.basePrice,\n    currency: plan.currency,\n    trialDays: plan.trialDays,\n    limits: typeof plan.limits === 'string' ? JSON.parse(plan.limits) : plan.limits,\n    features: typeof plan.features === 'string' ? JSON.parse(plan.features) : plan.features,\n    isActive: plan.isActive,\n    isPopular: plan.isPopular,\n    sortOrder: plan.sortOrder,\n    pricing: generatePlanPricing(plan.basePrice),\n    createdAt: plan.createdAt,\n    updatedAt: plan.updatedAt,\n    ...(plan.deletedAt && { deletedAt: plan.deletedAt })\n  };\n}\n\nexport function calculatePlanPricing(plan: Plan): Record<BillingInterval, number> {\n  const pricing: Record<BillingInterval, number> = {} as any;\n  \n  const intervals: BillingInterval[] = ['monthly', 'quarterly', 'sixMonths', 'yearly'];\n  \n  for (const interval of intervals) {\n    pricing[interval] = calculateSubscriptionPrice(plan, interval);\n  }\n  \n  return pricing;\n}\n\nexport function calculatePeriodEnd(startDate: Date, billingInterval: BillingInterval): Date {\n  const endDate = new Date(startDate);\n  \n  switch (billingInterval) {\n    case 'monthly':\n      endDate.setMonth(endDate.getMonth() + 1);\n      break;\n    case 'quarterly':\n      endDate.setMonth(endDate.getMonth() + 3);\n      break;\n    case 'sixMonths':\n      endDate.setMonth(endDate.getMonth() + 6);\n      break;\n    case 'yearly':\n      endDate.setFullYear(endDate.getFullYear() + 1);\n      break;\n    default:\n      endDate.setMonth(endDate.getMonth() + 1);\n  }\n  \n  return endDate;\n}\n\n// ============================================================================\n// SUBSCRIPTION QUERIES\n// ============================================================================\n\n/**\n * Get subscription by ID\n * Note: In multi-tenant setup, subscriptions are in the main database, not tenant databases\n * This function is kept for backward compatibility but should use main DB functions instead\n */\nexport async function getSubscriptionById(subscriptionId: number): Promise<Subscription | null> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId },\n    include: {\n      plan: true\n    }\n  });\n\n  if (!subscription) return null;\n\n  return {\n    id: subscription.id,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\n/**\n * Get all subscriptions\n * Note: In multi-tenant setup, subscriptions are in the main database\n */\nexport async function getAllSubscriptions(): Promise<Subscription[]> {\n  const subscriptions = await prisma.subscription.findMany({\n    include: {\n      plan: true\n    },\n    orderBy: { createdAt: 'desc' }\n  });\n\n  return subscriptions.map((sub: any) => ({\n    id: sub.id,\n    planId: sub.planId,\n    status: sub.status as SubscriptionStatus,\n    billingInterval: sub.interval as BillingInterval,\n    currentPeriodStart: sub.currentPeriodStart,\n    currentPeriodEnd: sub.currentPeriodEnd,\n    amount: sub.amount,\n    createdAt: sub.createdAt,\n    updatedAt: sub.updatedAt,\n    plan: convertPrismaPlanToPlan(sub.plan)\n  }));\n}\n\n// ============================================================================\n// SUBSCRIPTION SEARCH\n// ============================================================================\n\nexport async function searchSubscriptions(filters: {\n  search?: string;\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n  planId?: number;\n  status?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  offset?: number;\n}): Promise<{ subscriptions: Subscription[]; total: number; hasMore: boolean }> {\n  const where: any = {};\n\n  // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n  // Search functionality removed as subscriptions don't have merchant relations in tenant DBs\n\n  if (filters.planId) {\n    where.planId = filters.planId;\n  }\n\n  if (filters.status) {\n    where.status = filters.status;\n  }\n\n  if (filters.startDate || filters.endDate) {\n    where.currentPeriodStart = {};\n    if (filters.startDate) where.currentPeriodStart.gte = filters.startDate;\n    if (filters.endDate) where.currentPeriodStart.lte = filters.endDate;\n  }\n\n  // Get total count\n  const total = await prisma.subscription.count({ where });\n\n  // Get subscriptions with pagination\n  const subscriptions = await prisma.subscription.findMany({\n    where,\n    include: {\n      plan: true\n    },\n    orderBy: { createdAt: 'desc' },\n    take: filters.limit || 20,\n    skip: filters.offset || 0\n  });\n\n  const hasMore = (filters.offset || 0) + (filters.limit || 20) < total;\n\n  return {\n    subscriptions: subscriptions.map((sub: any) => ({\n      id: sub.id,\n      planId: sub.planId,\n      status: sub.status as SubscriptionStatus,\n      billingInterval: sub.interval as BillingInterval,\n      currentPeriodStart: sub.currentPeriodStart,\n      currentPeriodEnd: sub.currentPeriodEnd,\n      amount: sub.amount,\n      createdAt: sub.createdAt,\n      updatedAt: sub.updatedAt,\n      plan: {\n        id: sub.plan.id,\n        name: sub.plan.name,\n        description: sub.plan.description,\n        basePrice: sub.plan.basePrice,\n        currency: sub.plan.currency,\n        trialDays: sub.plan.trialDays,\n        limits: JSON.parse(sub.plan.limits as string) as PlanLimits,\n        features: JSON.parse(sub.plan.features as string) as string[],\n        isActive: sub.plan.isActive,\n        isPopular: sub.plan.isPopular,\n        sortOrder: sub.plan.sortOrder,\n        pricing: generatePricingFromBasePrice(sub.plan.basePrice),\n        createdAt: sub.plan.createdAt,\n        updatedAt: sub.plan.updatedAt\n      }\n    })),\n    total,\n    hasMore\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION MUTATIONS\n// ============================================================================\n\n/**\n * Create subscription\n * Note: In multi-tenant setup, subscriptions should be in the main database\n * This function is kept for backward compatibility\n */\nexport async function createSubscription(data: SubscriptionCreateInput): Promise<Subscription> {\n  // Note: merchantId removed - subscriptions don't have merchant relations in tenant DBs\n\n  // Get plan by id\n  const plan = await prisma.plan.findUnique({\n    where: { id: data.planId }\n  });\n\n  if (!plan) {\n    throw new Error('Plan not found');\n  }\n\n  // Calculate pricing based on billing interval\n  const billingInterval = data.billingInterval || 'monthly';\n  const convertedPlan = convertPrismaPlanToPlan(plan);\n  const amount = calculateSubscriptionPrice(convertedPlan, billingInterval);\n  \n  // Calculate dates\n  const startDate = data.startDate || new Date();\n  const currentPeriodEnd = calculatePeriodEnd(startDate, billingInterval);\n\n  const subscription = await prisma.subscription.create({\n    data: {\n      planId: plan.id,\n      status: data.status || 'trial',\n      interval: billingInterval,\n      currentPeriodStart: startDate,\n      currentPeriodEnd: currentPeriodEnd,\n      amount: amount\n    },\n    include: {\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\n// ============================================================================\n// PLAN FUNCTIONS\n// ============================================================================\n\nexport async function getAllPlans(): Promise<Plan[]> {\n  const plans = await prisma.plan.findMany({\n    where: { isActive: true },\n    orderBy: { sortOrder: 'asc' }\n  });\n\n  return plans.map((plan: any) => convertPrismaPlanToPlan(plan));\n}\n\nexport async function getPlanById(planId: number): Promise<Plan | null> {\n  const plan = await prisma.plan.findUnique({\n    where: { id: planId }\n  });\n\n  if (!plan) return null;\n\n  return {\n    id: plan.id,\n    name: plan.name,\n    description: plan.description,\n    basePrice: plan.basePrice,\n    currency: plan.currency,\n    trialDays: plan.trialDays,\n    limits: JSON.parse(plan.limits as string) as PlanLimits,\n    features: JSON.parse(plan.features as string) as string[],\n    isActive: plan.isActive,\n    isPopular: plan.isPopular,\n    sortOrder: plan.sortOrder,\n    pricing: generatePricingFromBasePrice(plan.basePrice),\n    createdAt: plan.createdAt,\n    updatedAt: plan.updatedAt,\n    deletedAt: plan.deletedAt || undefined\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION ACTIONS\n// ============================================================================\n\nexport async function changePlan(\n  subscriptionId: number, \n  newPlanId: number, \n  billingInterval: BillingInterval = 'monthly'\n): Promise<Subscription> {\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const plan = await prisma.plan.findUnique({\n    where: { id: newPlanId }\n  });\n\n  if (!plan) {\n    throw new Error('Plan not found');\n  }\n\n  const convertedPlan = convertPrismaPlanToPlan(plan);\n  const amount = calculateSubscriptionPrice(convertedPlan, billingInterval);\n\n  // Calculate new period dates based on billing interval\n  const now = new Date();\n  const newPeriodStart = now;\n  \n  // Calculate period duration in days based on billing interval\n  const getPeriodDays = (interval: BillingInterval): number => {\n    switch (interval) {\n      case 'monthly': return 30;\n      case 'quarterly': return 90;\n      case 'sixMonths': return 180;\n      case 'yearly': return 365;\n      default: return 30;\n    }\n  };\n  \n  const periodDays = getPeriodDays(billingInterval);\n  const newPeriodEnd = new Date(now.getTime() + periodDays * 24 * 60 * 60 * 1000);\n\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n  const updatedSubscription = await prisma.subscription.update({\n    where: { id: subscription.id },\n    data: {\n      planId: plan.id,\n      interval: billingInterval,\n      amount: amount,\n      currentPeriodStart: newPeriodStart,\n      currentPeriodEnd: newPeriodEnd,\n      updatedAt: new Date()\n    },\n    include: {\n      plan: true\n    }\n  });\n\n  return {\n    id: updatedSubscription.id,\n    planId: updatedSubscription.planId,\n    status: updatedSubscription.status as SubscriptionStatus,\n    billingInterval: updatedSubscription.interval as BillingInterval,\n    currentPeriodStart: updatedSubscription.currentPeriodStart,\n    currentPeriodEnd: updatedSubscription.currentPeriodEnd,\n    amount: updatedSubscription.amount,\n    createdAt: updatedSubscription.createdAt,\n    updatedAt: updatedSubscription.updatedAt,\n    // Enhanced subscription period information\n    subscriptionPeriod: {\n      startDate: updatedSubscription.currentPeriodStart,\n      endDate: updatedSubscription.currentPeriodEnd,\n      duration: updatedSubscription.interval,\n      isActive: updatedSubscription.status === 'active',\n      daysRemaining: Math.ceil((updatedSubscription.currentPeriodEnd.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)),\n      nextBillingDate: updatedSubscription.currentPeriodEnd\n    },\n    plan: convertPrismaPlanToPlan(updatedSubscription.plan)\n  };\n}\n\nexport async function pauseSubscription(subscriptionId: number): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: 'paused',\n      updatedAt: new Date()\n    },\n    include: {\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\nexport async function resumeSubscription(subscriptionId: number): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      status: 'active',\n      updatedAt: new Date()\n    },\n    include: {\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\nexport async function cancelSubscription(subscriptionId: number): Promise<{ success: boolean; message: string; data?: Subscription; statusCode?: number }> {\n  try {\n    const subscription = await prisma.subscription.update({\n      where: { id: subscriptionId },\n      data: {\n        status: 'cancelled',\n        updatedAt: new Date()\n      },\n      include: {\n        plan: true\n      }\n    });\n\n    const result: Subscription = {\n      id: subscription.id,\n      planId: subscription.planId,\n      status: subscription.status as SubscriptionStatus,\n      billingInterval: subscription.interval as BillingInterval,\n      currentPeriodStart: subscription.currentPeriodStart,\n      currentPeriodEnd: subscription.currentPeriodEnd,\n      amount: subscription.amount,\n      createdAt: subscription.createdAt,\n      updatedAt: subscription.updatedAt,\n      plan: {\n        id: subscription.plan.id,\n        name: subscription.plan.name,\n        description: subscription.plan.description,\n        basePrice: subscription.plan.basePrice,\n        currency: subscription.plan.currency,\n        trialDays: subscription.plan.trialDays,\n        limits: JSON.parse(subscription.plan.limits as string) as PlanLimits,\n        features: JSON.parse(subscription.plan.features as string) as string[],\n        isActive: subscription.plan.isActive,\n        isPopular: subscription.plan.isPopular,\n        sortOrder: subscription.plan.sortOrder,\n        pricing: generatePricingFromBasePrice(subscription.plan.basePrice),\n        createdAt: subscription.plan.createdAt,\n        updatedAt: subscription.plan.updatedAt\n      }\n    };\n\n    return {\n      success: true,\n      message: 'Subscription cancelled successfully',\n      data: result\n    };\n  } catch (error) {\n    console.error('Error cancelling subscription:', error);\n    return {\n      success: false,\n      message: 'Failed to cancel subscription',\n      statusCode: 500\n    };\n  }\n}\n\n// ============================================================================\n// SUBSCRIPTION RENEWAL FUNCTIONS\n// ============================================================================\n\nexport async function getExpiredSubscriptions(): Promise<Subscription[]> {\n  const now = new Date();\n  \n  const subscriptions = await prisma.subscription.findMany({\n    where: {\n      currentPeriodEnd: {\n        lt: now\n      },\n      status: {\n        in: ['active', 'trial']\n      }\n    },\n    include: {\n      // Note: merchant removed - tenant databases don't have merchant model\n      plan: true\n    },\n    orderBy: { currentPeriodEnd: 'asc' }\n  });\n\n  return subscriptions.map((sub: any) => ({\n    id: sub.id,\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    planId: sub.planId,\n    status: sub.status as SubscriptionStatus,\n    billingInterval: sub.interval as BillingInterval,\n    currentPeriodStart: sub.currentPeriodStart,\n    currentPeriodEnd: sub.currentPeriodEnd,\n    amount: sub.amount,\n    createdAt: sub.createdAt,\n    updatedAt: sub.updatedAt,\n    // Note: merchant removed - tenant databases don't have merchant model\n    plan: convertPrismaPlanToPlan(sub.plan)\n  }));\n}\n\n// Duplicate function removed - using getSubscriptionById above (line 172)\n\nexport async function updateSubscription(\n  subscriptionId: number, \n  data: Partial<{\n    status: SubscriptionStatus;\n    currentPeriodStart: Date;\n    currentPeriodEnd: Date;\n    amount: number;\n  }>\n): Promise<Subscription> {\n  const subscription = await prisma.subscription.update({\n    where: { id: subscriptionId },\n    data: {\n      ...data,\n      updatedAt: new Date()\n    },\n    include: {\n      // Note: merchant removed - tenant databases don't have merchant model\n      plan: true\n    }\n  });\n\n  return {\n    id: subscription.id,\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    planId: subscription.planId,\n    status: subscription.status as SubscriptionStatus,\n    billingInterval: subscription.interval as BillingInterval,\n    currentPeriodStart: subscription.currentPeriodStart,\n    currentPeriodEnd: subscription.currentPeriodEnd,\n    amount: subscription.amount,\n    createdAt: subscription.createdAt,\n    updatedAt: subscription.updatedAt,\n    // Note: merchant removed - tenant databases don't have merchant model\n    plan: convertPrismaPlanToPlan(subscription.plan)\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION PAYMENT FUNCTIONS\n// ============================================================================\n\nexport interface SubscriptionPaymentCreateInput {\n  subscriptionId: number;\n  amount: number;\n  currency: string;\n  method: string;\n  status: string;\n  transactionId: string;\n  description?: string;\n  failureReason?: string;\n}\n\nexport interface SubscriptionPayment {\n  id: number;\n  subscriptionId: number;\n  amount: number;\n  currency: string;\n  method: string;\n  status: string;\n  transactionId: string;\n  description?: string;\n  failureReason?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport async function createSubscriptionPayment(data: SubscriptionPaymentCreateInput): Promise<SubscriptionPayment> {\n  // Find subscription by id\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: data.subscriptionId },\n    select: { id: true }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const payment = await prisma.payment.create({\n    data: {\n      subscriptionId: subscription.id,\n      amount: data.amount,\n      currency: data.currency,\n      method: data.method,\n      type: 'SUBSCRIPTION',\n      status: data.status,\n      transactionId: data.transactionId,\n      description: data.description,\n      failureReason: data.failureReason\n    }\n  });\n\n  return {\n    id: payment.id,\n    subscriptionId: data.subscriptionId,\n    amount: payment.amount,\n    currency: payment.currency,\n    method: payment.method,\n    status: payment.status,\n    transactionId: payment.transactionId || '',\n    description: payment.description || undefined,\n    failureReason: payment.failureReason || undefined,\n    createdAt: payment.createdAt,\n    updatedAt: payment.updatedAt\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION PAYMENT HISTORY\n// ============================================================================\n\n/**\n * Get payment history for a subscription\n * @param subscriptionId - Subscription ID\n * @param filters - Optional filters for payments\n * @returns Payment history with pagination\n */\nexport async function getSubscriptionPaymentHistory(\n  subscriptionId: number,\n  filters?: {\n    status?: string;\n    method?: string;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n    offset?: number;\n  }\n): Promise<{\n  payments: SubscriptionPayment[];\n  total: number;\n  hasMore: boolean;\n}> {\n  const where: any = {\n    subscriptionId,\n    type: 'SUBSCRIPTION'\n  };\n\n  // Apply filters\n  if (filters?.status) {\n    where.status = filters.status.toUpperCase();\n  }\n\n  if (filters?.method) {\n    where.method = filters.method.toUpperCase();\n  }\n\n  if (filters?.startDate || filters?.endDate) {\n    where.createdAt = {};\n    if (filters.startDate) where.createdAt.gte = filters.startDate;\n    if (filters.endDate) where.createdAt.lte = filters.endDate;\n  }\n\n  const limit = filters?.limit || 20;\n  const offset = filters?.offset || 0;\n\n  // Get total count and payments\n  const [total, payments] = await Promise.all([\n    prisma.payment.count({ where }),\n    prisma.payment.findMany({\n      where,\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset\n    })\n  ]);\n\n  const hasMore = offset + limit < total;\n\n  return {\n    payments: payments.map(p => ({\n      id: p.id,\n      subscriptionId: subscriptionId,\n      amount: p.amount,\n      currency: p.currency,\n      method: p.method,\n      status: p.status,\n      transactionId: p.transactionId || '',\n      description: p.description || undefined,\n      failureReason: p.failureReason || undefined,\n      createdAt: p.createdAt,\n      updatedAt: p.updatedAt\n    })),\n    total,\n    hasMore\n  };\n}\n\n// ============================================================================\n// SUBSCRIPTION RENEWAL\n// ============================================================================\n\n/**\n * Renew subscription for another month with payment\n * @param subscriptionId - Subscription ID\n * @param paymentData - Payment information\n * @returns Updated subscription and payment record\n */\nexport async function renewSubscription(\n  subscriptionId: number,\n  paymentData: {\n    method: 'STRIPE' | 'TRANSFER';\n    transactionId: string;\n    reference?: string;\n    description?: string;\n  }\n): Promise<{\n  subscription: Subscription;\n  payment: SubscriptionPayment;\n}> {\n  // 1. Get subscription\n  // Note: merchant removed - tenant databases are already isolated per tenant\n  const subscription = await prisma.subscription.findUnique({\n    where: { id: subscriptionId },\n    include: {\n      plan: true\n    }\n  });\n\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  // 2. Validate subscription can be renewed\n  if (subscription.status === 'cancelled') {\n    throw new Error('Cannot renew cancelled subscription');\n  }\n\n  // 3. Calculate new period (extend by 1 month)\n  const newPeriodStart = subscription.currentPeriodEnd;\n  const newPeriodEnd = calculatePeriodEnd(newPeriodStart, 'monthly');\n\n  // 4. Use database transaction to ensure atomicity\n  const result = await prisma.$transaction(async (tx) => {\n    // Create payment record\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    const payment = await tx.payment.create({\n      data: {\n        subscriptionId: subscription.id,\n        amount: subscription.amount,\n        currency: subscription.currency,\n        method: paymentData.method,\n        type: 'SUBSCRIPTION',\n        status: paymentData.method === 'STRIPE' ? 'COMPLETED' : 'PENDING',\n        transactionId: paymentData.transactionId,\n        reference: paymentData.reference,\n        description: paymentData.description || `Monthly subscription renewal - ${new Date().toLocaleDateString()}`,\n        processedAt: paymentData.method === 'STRIPE' ? new Date() : null\n      }\n    });\n\n    // Update subscription period\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    const updatedSubscription = await tx.subscription.update({\n      where: { id: subscription.id },\n      data: {\n        currentPeriodStart: newPeriodStart,\n        currentPeriodEnd: newPeriodEnd,\n        status: 'active',\n        updatedAt: new Date()\n      },\n      include: {\n        plan: true\n      }\n    });\n\n    return { updatedSubscription, payment };\n  });\n\n  // 5. Return formatted response\n  return {\n    subscription: {\n      id: result.updatedSubscription.id,\n      planId: result.updatedSubscription.planId,\n      status: result.updatedSubscription.status as SubscriptionStatus,\n      billingInterval: result.updatedSubscription.interval as BillingInterval,\n      currentPeriodStart: result.updatedSubscription.currentPeriodStart,\n      currentPeriodEnd: result.updatedSubscription.currentPeriodEnd,\n      amount: result.updatedSubscription.amount,\n      createdAt: result.updatedSubscription.createdAt,\n      updatedAt: result.updatedSubscription.updatedAt,\n      plan: convertPrismaPlanToPlan(result.updatedSubscription.plan)\n    },\n    payment: {\n      id: result.payment.id,\n      subscriptionId: subscriptionId,\n      amount: result.payment.amount,\n      currency: result.payment.currency,\n      method: result.payment.method,\n      status: result.payment.status,\n      transactionId: result.payment.transactionId || '',\n      description: result.payment.description || undefined,\n      createdAt: result.payment.createdAt,\n      updatedAt: result.payment.updatedAt\n    }\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedSubscriptions = {\n  /**\n   * Find subscription by ID (simplified API)\n   */\n  findById: async (id: number) => {\n    return await prisma.subscription.findUnique({\n      where: { id },\n      include: {\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Find active subscription (simplified API)\n   * Note: findByMerchantId removed - tenant databases are already isolated per tenant\n   */\n  findActive: async () => {\n    return await prisma.subscription.findFirst({\n      where: { \n        status: { not: 'CANCELLED' }\n      },\n      include: {\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Create new subscription (simplified API)\n   */\n  create: async (data: any) => {\n    return await prisma.subscription.create({\n      data,\n      include: {\n        plan: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Update subscription (simplified API)\n   */\n  update: async (id: number, data: any) => {\n    return await prisma.subscription.update({\n      where: { id },\n      data,\n      include: {\n        plan: { select: { id: true, name: true } }\n      }\n    });\n  },\n\n  /**\n   * Delete subscription (simplified API)\n   */\n  delete: async (id: number) => {\n    return await prisma.subscription.update({\n      where: { id },\n      data: { \n        status: 'CANCELLED',\n        canceledAt: new Date()\n      }\n    });\n  },\n\n  /**\n   * Search subscriptions with simple filters (simplified API)\n   */\n  search: async (filters: any) => {\n    const { page = 1, limit = 20, ...whereFilters } = filters;\n    const skip = (page - 1) * limit;\n\n    // Build where clause\n    const where: any = {};\n    \n    // Note: merchant search removed - tenant databases are already isolated per tenant\n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (whereFilters.planId) where.planId = whereFilters.planId;\n    if (whereFilters.isActive !== undefined) {\n      if (whereFilters.isActive) {\n        where.status = { not: 'CANCELLED' };\n      } else {\n        where.status = 'CANCELLED';\n      }\n    }\n    if (whereFilters.status) where.status = whereFilters.status;\n    \n    // Date range filters\n    if (whereFilters.startDate || whereFilters.endDate) {\n      where.createdAt = {};\n      if (whereFilters.startDate) where.createdAt.gte = whereFilters.startDate;\n      if (whereFilters.endDate) where.createdAt.lte = whereFilters.endDate;\n    }\n\n    const [subscriptions, total] = await Promise.all([\n      prisma.subscription.findMany({\n        where,\n        include: {\n          plan: { select: { id: true, name: true } },\n          payments: {\n            orderBy: { createdAt: 'desc' },\n            take: 3\n          }\n        },\n        orderBy: { createdAt: 'desc' },\n        skip,\n        take: limit\n      }),\n      prisma.subscription.count({ where })\n    ]);\n\n    return {\n      data: subscriptions,\n      total,\n      page,\n      limit,\n      hasMore: skip + limit < total\n    };\n  },\n\n  /**\n   * Find first subscription matching criteria (simplified API)\n   */\n  findFirst: async (whereClause: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.subscription.findFirst({\n      where,\n      include: {\n        plan: { select: { id: true, name: true } },\n        payments: {\n          orderBy: { createdAt: 'desc' },\n          take: 5\n        }\n      }\n    });\n  },\n\n  /**\n   * Get subscription statistics (simplified API)\n   */\n  getStats: async (whereClause?: any) => {\n    // Handle both direct where clause and object with where property\n    const where = whereClause?.where || whereClause || {};\n    return await prisma.subscription.count({ where });\n  },\n\n  /**\n   * Get expired subscriptions (simplified API)\n   */\n  getExpired: async () => {\n    const now = new Date();\n    \n    return await prisma.subscription.findMany({\n      where: {\n        status: { not: 'CANCELLED' },\n        OR: [\n          { \n            status: 'TRIAL',\n            trialEnd: { lt: now }\n          },\n          {\n            status: 'ACTIVE',\n            currentPeriodEnd: { lt: now }\n          }\n        ]\n      },\n      include: {\n        plan: { select: { id: true, name: true } }\n      },\n      orderBy: { currentPeriodEnd: 'asc' }\n    });\n  }\n};","import { prisma } from './client';\n\n/**\n * Create a subscription activity log\n */\nexport async function createActivity(data: {\n  subscriptionId: number;\n  type: string;\n  description: string;\n  reason?: string;\n  metadata?: any;\n  performedBy?: number;\n}) {\n  const { metadata, ...rest } = data;\n  \n  return await prisma.subscriptionActivity.create({\n    data: {\n      ...rest,\n      metadata: metadata ? JSON.stringify(metadata) : null\n    }\n  });\n}\n\n/**\n * Get activities for a subscription\n */\nexport async function getActivitiesBySubscriptionId(\n  subscriptionId: number,\n  options: { limit?: number; offset?: number } = {}\n) {\n  const { limit = 50, offset = 0 } = options;\n  \n  const [activities, total] = await Promise.all([\n    prisma.subscriptionActivity.findMany({\n      where: { subscriptionId },\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            firstName: true,\n            lastName: true,\n            role: true\n          }\n        }\n      },\n      orderBy: { createdAt: 'desc' },\n      take: limit,\n      skip: offset\n    }),\n    prisma.subscriptionActivity.count({ where: { subscriptionId } })\n  ]);\n\n  // Parse metadata JSON\n  return {\n    activities: activities.map(activity => ({\n      ...activity,\n      metadata: activity.metadata ? JSON.parse(activity.metadata) : null\n    })),\n    total\n  };\n}\n\n/**\n * Simplified subscription activity operations\n */\nexport const simplifiedSubscriptionActivities = {\n  /**\n   * Create activity (simplified API)\n   */\n  create: createActivity,\n\n  /**\n   * Get activities by subscription ID\n   */\n  getBySubscriptionId: getActivitiesBySubscriptionId\n};\n\n","/**\n * Order Number Generator & Configuration\n * \n * Provides robust, concurrent-safe order number generation for rental shop orders.\n * Supports multiple formats, handles race conditions, and includes centralized configuration.\n */\n\nimport { prisma } from './index';\n\n// ============================================================================\n// TYPES & INTERFACES\n// ============================================================================\n\nexport type OrderNumberFormat = 'sequential' | 'date-based' | 'random' | 'random-numeric' | 'hybrid' | 'compact-numeric';\n\nexport interface OrderNumberConfig {\n  format: OrderNumberFormat;\n  outletId: number;\n  prefix?: string;\n  includeDate?: boolean;\n  sequenceLength?: number;\n  randomLength?: number;\n  numericOnly?: boolean;\n}\n\nexport interface OrderNumberResult {\n  orderNumber: string;\n  sequence: number;\n  generatedAt: Date;\n}\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\n/**\n * Default order number format for new orders\n * \n * Available formats:\n * - 'sequential': ORD-{outletId}-{sequence} (e.g., ORD-001-0001)\n * - 'date-based': ORD-{outletId}-{date}-{sequence} (e.g., ORD-001-20250115-0001)\n * - 'random': ORD-{outletId}-{random} (e.g., ORD-001-A7B9C2)\n * - 'random-numeric': ORD-{outletId}-{random} (e.g., ORD-001-123456)\n * - 'hybrid': ORD-{outletId}-{date}-{random} (e.g., ORD-001-20250115-A7B9)\n * - 'compact-numeric': ORD{outletId}{random} (e.g., ORD00112345)\n */\nexport const ORDER_NUMBER_CONFIG = {\n  // Primary format for all new orders\n  format: 'compact-numeric' as OrderNumberFormat,\n  \n  // Prefix for all order numbers\n  prefix: 'ORD',\n  \n  // Sequence number padding (how many digits)\n  sequenceLength: 4,\n  \n  // Random string length (for random and hybrid formats)\n  randomLength: 6,\n  \n  // Whether to include date in order numbers (for date-based and hybrid)\n  includeDate: true,\n  \n  // Maximum retry attempts for collision resolution\n  maxRetries: 5,\n  \n  // Retry delay in milliseconds (exponential backoff)\n  retryDelay: 10,\n} as const;\n\n/**\n * Format-specific configurations\n */\nexport const FORMAT_CONFIGS = {\n  sequential: {\n    description: 'Sequential numbering per outlet',\n    example: 'ORD-001-0001',\n    pros: ['Outlet identification', 'Easy tracking', 'Human readable'],\n    cons: ['Business intelligence leakage', 'Race conditions possible'],\n    bestFor: 'Small to medium businesses with low concurrency'\n  },\n  \n  'date-based': {\n    description: 'Date-based with daily sequence reset',\n    example: 'ORD-001-20250115-0001',\n    pros: ['Daily organization', 'Better security', 'Easy daily reporting'],\n    cons: ['Longer numbers', 'Still somewhat predictable'],\n    bestFor: 'Medium businesses with daily operations focus'\n  },\n  \n  random: {\n    description: 'Random alphanumeric strings for security',\n    example: 'ORD-001-A7B9C2',\n    pros: ['Maximum security', 'No race conditions', 'Unpredictable'],\n    cons: ['No sequence tracking', 'Harder to manage', 'No business insights'],\n    bestFor: 'Large businesses prioritizing security'\n  },\n  \n  'random-numeric': {\n    description: 'Random numeric strings for security',\n    example: 'ORD-001-123456',\n    pros: ['Maximum security', 'No race conditions', 'Numbers only', 'Unpredictable'],\n    cons: ['No sequence tracking', 'Harder to manage', 'No business insights'],\n    bestFor: 'Businesses needing numeric-only random order numbers'\n  },\n  \n  'compact-numeric': {\n    description: 'Compact format with outlet ID and 5-digit random number',\n    example: 'ORD00112345',\n    pros: ['Compact format', 'Outlet identification', 'Numbers only', 'Short length', 'Easy to read'],\n    cons: ['No sequence tracking', 'Limited randomness (5 digits)'],\n    bestFor: 'Businesses wanting compact, numeric-only order numbers'\n  },\n  \n  hybrid: {\n    description: 'Combines outlet, date, and random elements',\n    example: 'ORD-001-20250115-A7B9',\n    pros: ['Balanced security', 'Outlet identification', 'Date organization'],\n    cons: ['Longer numbers', 'More complex'],\n    bestFor: 'Large businesses needing both security and organization'\n  }\n} as const;\n\n// ============================================================================\n// CONFIGURATION FUNCTIONS\n// ============================================================================\n\n/**\n * Get the current order number configuration\n */\nexport function getOrderNumberConfig() {\n  return ORDER_NUMBER_CONFIG;\n}\n\n/**\n * Update order number configuration (for testing or admin purposes)\n */\nexport function updateOrderNumberConfig(updates: Partial<typeof ORDER_NUMBER_CONFIG>) {\n  Object.assign(ORDER_NUMBER_CONFIG, updates);\n}\n\n/**\n * Get format information for display purposes\n */\nexport function getFormatInfo(format: OrderNumberFormat) {\n  return FORMAT_CONFIGS[format];\n}\n\n/**\n * Get all available formats with their information\n */\nexport function getAllFormats() {\n  return Object.entries(FORMAT_CONFIGS).map(([key, value]) => ({\n    format: key as OrderNumberFormat,\n    ...value\n  }));\n}\n\n/**\n * Validate order number format configuration\n */\nexport function validateOrderNumberConfig(config: typeof ORDER_NUMBER_CONFIG): string[] {\n  const errors: string[] = [];\n  \n  if (!config.prefix || config.prefix.length === 0) {\n    errors.push('Prefix cannot be empty');\n  }\n  \n  if (config.sequenceLength < 1 || config.sequenceLength > 10) {\n    errors.push('Sequence length must be between 1 and 10');\n  }\n  \n  if (config.randomLength < 4 || config.randomLength > 20) {\n    errors.push('Random length must be between 4 and 20');\n  }\n  \n  if (config.maxRetries < 1 || config.maxRetries > 20) {\n    errors.push('Max retries must be between 1 and 20');\n  }\n  \n  if (config.retryDelay < 1 || config.retryDelay > 1000) {\n    errors.push('Retry delay must be between 1 and 1000 milliseconds');\n  }\n  \n  return errors;\n}\n\n/**\n * Get recommended format based on business characteristics\n */\nexport function getRecommendedFormat(businessSize: 'small' | 'medium' | 'large', \n                                   concurrencyLevel: 'low' | 'medium' | 'high',\n                                   securityPriority: 'low' | 'medium' | 'high'): OrderNumberFormat {\n  // Small business with low concurrency and low security needs\n  if (businessSize === 'small' && concurrencyLevel === 'low' && securityPriority === 'low') {\n    return 'compact-numeric';\n  }\n  \n  // Medium business or higher security needs\n  if (businessSize === 'medium' || securityPriority === 'medium') {\n    return 'date-based';\n  }\n  \n  // High concurrency or high security needs\n  if (concurrencyLevel === 'high' || securityPriority === 'high') {\n    return 'random-numeric';\n  }\n  \n  // Large business with balanced needs\n  if (businessSize === 'large') {\n    return 'hybrid';\n  }\n  \n  // Default fallback - compact numeric for easy use\n  return 'compact-numeric';\n}\n\n// ============================================================================\n// ORDER NUMBER GENERATION\n// ============================================================================\n\n/**\n * Generate order number with specified format\n */\nexport async function generateOrderNumber(\n  config: OrderNumberConfig\n): Promise<OrderNumberResult> {\n  const {\n    format = 'sequential',\n    outletId,\n    prefix = 'ORD',\n    includeDate = false,\n    sequenceLength = 4,\n    randomLength = 6,\n    numericOnly = false\n  } = config;\n\n  // Validate outlet exists\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true, name: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  const outletIdStr = outlet.id.toString().padStart(3, '0');\n  const generatedAt = new Date();\n\n  switch (format) {\n    case 'sequential':\n      return await generateSequentialNumber(outletIdStr, prefix, sequenceLength);\n    \n    case 'date-based':\n      return await generateDateBasedNumber(outletIdStr, prefix, sequenceLength, generatedAt);\n    \n    case 'random':\n      return await generateRandomNumber(outletIdStr, prefix, randomLength, false);\n    \n    case 'random-numeric':\n      return await generateRandomNumber(outletIdStr, prefix, randomLength, true);\n    \n    case 'compact-numeric':\n      return await generateCompactNumericNumber(outletIdStr, prefix);\n    \n    case 'hybrid':\n      return await generateHybridNumber(outletIdStr, prefix, sequenceLength, generatedAt, numericOnly);\n    \n    default:\n      throw new Error(`Unsupported order number format: ${format}`);\n  }\n}\n\n/**\n * Generate sequential order number: ORD-{outletId}-{sequence}\n * Uses atomic counter to prevent race conditions\n */\nasync function generateSequentialNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number\n): Promise<OrderNumberResult> {\n  const maxRetries = 5;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Use atomic increment with retry logic\n      const result = await prisma.$transaction(async (tx: any) => {\n        // Get current sequence for this outlet\n        const lastOrder = await tx.order.findFirst({\n          where: { \n            orderNumber: { startsWith: `${prefix}-${outletIdStr}-` }\n          },\n          orderBy: { createdAt: 'desc' },\n          select: { orderNumber: true, createdAt: true }\n        });\n\n        let nextSequence = 1;\n        \n        if (lastOrder) {\n          // Extract sequence from last order number\n          const parts = lastOrder.orderNumber.split('-');\n          const lastSequence = parseInt(parts[parts.length - 1]) || 0;\n          nextSequence = lastSequence + 1;\n        }\n\n        const orderNumber = `${prefix}-${outletIdStr}-${nextSequence.toString().padStart(sequenceLength, '0')}`;\n\n        // Check for uniqueness (double-check)\n        const existingOrder = await tx.order.findUnique({\n          where: { orderNumber },\n          select: { id: true }\n        });\n\n        if (existingOrder) {\n          throw new Error('Order number collision detected');\n        }\n\n        return {\n          orderNumber,\n          sequence: nextSequence,\n          generatedAt: new Date()\n        };\n      });\n\n      return result;\n    } catch (error) {\n      retryCount++;\n      if (retryCount >= maxRetries) {\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        throw new Error(`Failed to generate sequential order number after ${maxRetries} retries: ${errorMessage}`);\n      }\n      \n      // Wait before retry (exponential backoff)\n      await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 10));\n    }\n  }\n\n  throw new Error('Maximum retries exceeded');\n}\n\n/**\n * Generate date-based order number: ORD-{outletId}-{date}-{sequence}\n * Resets sequence daily for better organization\n */\nasync function generateDateBasedNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number,\n  generatedAt: Date\n): Promise<OrderNumberResult> {\n  const dateStr = generatedAt.toISOString().split('T')[0].replace(/-/g, '');\n  \n  const result = await prisma.$transaction(async (tx: any) => {\n    // Get last order for this outlet on this date\n    const lastOrder = await tx.order.findFirst({\n      where: { \n        orderNumber: { startsWith: `${prefix}-${outletIdStr}-${dateStr}-` }\n      },\n      orderBy: { createdAt: 'desc' },\n      select: { orderNumber: true }\n    });\n\n    let nextSequence = 1;\n    \n    if (lastOrder) {\n      const parts = lastOrder.orderNumber.split('-');\n      const lastSequence = parseInt(parts[parts.length - 1]) || 0;\n      nextSequence = lastSequence + 1;\n    }\n\n    const orderNumber = `${prefix}-${outletIdStr}-${dateStr}-${nextSequence.toString().padStart(sequenceLength, '0')}`;\n\n    // Check for uniqueness\n    const existingOrder = await tx.order.findUnique({\n      where: { orderNumber },\n      select: { id: true }\n    });\n\n    if (existingOrder) {\n      throw new Error('Order number collision detected');\n    }\n\n    return {\n      orderNumber,\n      sequence: nextSequence,\n      generatedAt\n    };\n  });\n\n  return result;\n}\n\n/**\n * Generate random order number: ORD-{outletId}-{random}\n * Uses crypto-secure random generation\n */\nasync function generateRandomNumber(\n  outletIdStr: string,\n  prefix: string,\n  randomLength: number,\n  numericOnly: boolean = false\n): Promise<OrderNumberResult> {\n  const maxRetries = 10;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Generate crypto-secure random string\n      const randomStr = generateRandomString(randomLength, numericOnly);\n      const orderNumber = `${prefix}-${outletIdStr}-${randomStr}`;\n\n      // Check for uniqueness\n      const existingOrder = await prisma.order.findUnique({\n        where: { orderNumber },\n        select: { id: true }\n      });\n\n      if (!existingOrder) {\n        return {\n          orderNumber,\n          sequence: 0, // No sequence for random\n          generatedAt: new Date()\n        };\n      }\n\n      retryCount++;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to generate random order number: ${errorMessage}`);\n    }\n  }\n\n  throw new Error(`Failed to generate unique random order number after ${maxRetries} attempts`);\n}\n\n/**\n * Generate compact numeric order number: ORD{outletId}{random}\n * Format: ORD00112345678 (no hyphens, 8-digit random number)\n */\nasync function generateCompactNumericNumber(\n  outletIdStr: string,\n  prefix: string\n): Promise<OrderNumberResult> {\n  const maxRetries = 10;\n  let retryCount = 0;\n\n  while (retryCount < maxRetries) {\n    try {\n      // Generate 8-digit random number\n      const randomStr = generateRandomString(8, true); // 8 digits, numeric only\n      const orderNumber = `${prefix}${outletIdStr}${randomStr}`;\n\n      // Check for uniqueness\n      const existingOrder = await prisma.order.findUnique({\n        where: { orderNumber },\n        select: { id: true }\n      });\n\n      if (!existingOrder) {\n        return {\n          orderNumber,\n          sequence: 0, // No sequence for compact numeric\n          generatedAt: new Date()\n        };\n      }\n\n      retryCount++;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to generate compact numeric order number: ${errorMessage}`);\n    }\n  }\n\n  throw new Error(`Failed to generate unique compact numeric order number after ${maxRetries} attempts`);\n}\n\n/**\n * Generate hybrid order number: ORD-{outletId}-{date}-{random}\n * Combines outlet, date, and random for optimal security and organization\n */\nasync function generateHybridNumber(\n  outletIdStr: string,\n  prefix: string,\n  sequenceLength: number,\n  generatedAt: Date,\n  numericOnly: boolean = false\n): Promise<OrderNumberResult> {\n  const dateStr = generatedAt.toISOString().split('T')[0].replace(/-/g, '');\n  const randomStr = generateRandomString(4, numericOnly); // Shorter random part\n  \n  const orderNumber = `${prefix}-${outletIdStr}-${dateStr}-${randomStr}`;\n\n  // Check for uniqueness\n  const existingOrder = await prisma.order.findUnique({\n    where: { orderNumber },\n    select: { id: true }\n  });\n\n  if (existingOrder) {\n    // If collision, try with different random string\n    return generateHybridNumber(outletIdStr, prefix, sequenceLength, generatedAt, numericOnly);\n  }\n\n  return {\n    orderNumber,\n    sequence: 0, // No sequence for hybrid\n    generatedAt\n  };\n}\n\n/**\n * Generate crypto-secure random string\n */\nfunction generateRandomString(length: number, numericOnly: boolean = false): string {\n  const chars = numericOnly ? '0123456789' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  const randomBytes = new Uint8Array(length);\n  \n  if (typeof window !== 'undefined' && window.crypto) {\n    // Browser environment\n    window.crypto.getRandomValues(randomBytes);\n  } else {\n    // Node.js environment\n    const crypto = require('crypto');\n    const randomBytesNode = crypto.randomBytes(length);\n    randomBytes.set(randomBytesNode);\n  }\n  \n  return Array.from(randomBytes, byte => chars[byte % chars.length]).join('');\n}\n\n// ============================================================================\n// VALIDATION & PARSING\n// ============================================================================\n\n/**\n * Validate order number format\n */\nexport function validateOrderNumber(orderNumber: string): boolean {\n  const patterns = [\n    /^\\d{3}-\\d{4}$/, // Sequential: ORD-001-0001\n    /^\\d{3}-\\d{8}-\\d{4}$/, // Date-based: ORD-001-20250115-0001\n    /^\\d{3}-[A-Z0-9]{6}$/, // Random: ORD-001-A7B9C2\n    /^\\d{3}-\\d{6}$/, // Random-numeric: ORD-001-123456\n    /^\\d{3}-\\d{8}-[A-Z0-9]{4}$/, // Hybrid: ORD-001-20250115-A7B9\n    /^\\d{3}\\d{5}$/ // Compact-numeric: ORD00112345\n  ];\n  \n  return patterns.some(pattern => pattern.test(orderNumber));\n}\n\n/**\n * Parse order number to extract components\n */\nexport function parseOrderNumber(orderNumber: string): {\n  prefix: string;\n  outletId: number;\n  date?: string;\n  sequence?: number;\n  random?: string;\n  format: OrderNumberFormat;\n} | null {\n  if (!validateOrderNumber(orderNumber)) {\n    return null;\n  }\n\n  // Check for compact-numeric format first (no hyphens)\n  if (/^ORD\\d{3}\\d{5}$/.test(orderNumber)) {\n    const outletId = parseInt(orderNumber.substring(3, 6));\n    const random = orderNumber.substring(6);\n    \n    return {\n      prefix: 'ORD',\n      outletId,\n      random,\n      format: 'compact-numeric'\n    };\n  }\n\n  const parts = orderNumber.split('-');\n  \n  if (parts.length === 3) {\n    // Sequential or Random format\n    const sequence = parseInt(parts[2]);\n    const isNumeric = /^\\d+$/.test(parts[2]);\n    \n    return {\n      prefix: parts[0],\n      outletId: parseInt(parts[1]),\n      sequence: isNumeric ? sequence : undefined,\n      random: !isNumeric ? parts[2] : undefined,\n      format: isNumeric ? 'sequential' : 'random'\n    };\n  }\n  \n  if (parts.length === 4) {\n    // Date-based or Hybrid format\n    const sequence = parseInt(parts[3]);\n    const isNumeric = /^\\d+$/.test(parts[3]);\n    \n    return {\n      prefix: parts[0],\n      outletId: parseInt(parts[1]),\n      date: parts[2],\n      sequence: isNumeric ? sequence : undefined,\n      random: !isNumeric ? parts[3] : undefined,\n      format: isNumeric ? 'date-based' : 'hybrid'\n    };\n  }\n  \n  return null;\n}\n\n// ============================================================================\n// STATISTICS & UTILITIES\n// ============================================================================\n\n/**\n * Get order statistics for an outlet\n */\nexport async function getOutletOrderStats(outletId: number): Promise<{\n  totalOrders: number;\n  todayOrders: number;\n  lastOrderNumber?: string;\n  lastOrderDate?: Date;\n}> {\n  const outlet = await prisma.outlet.findUnique({\n    where: { id: outletId },\n    select: { id: true }\n  });\n\n  if (!outlet) {\n    throw new Error(`Outlet with id ${outletId} not found`);\n  }\n\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n  const tomorrow = new Date(today);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n\n  const [totalOrders, todayOrders, lastOrder] = await Promise.all([\n    prisma.order.count({\n      where: { outletId: outlet.id }\n    }),\n    prisma.order.count({\n      where: { \n        outletId: outlet.id,\n        createdAt: {\n          gte: today,\n          lt: tomorrow\n        }\n      }\n    }),\n    prisma.order.findFirst({\n      where: { outletId: outlet.id },\n      orderBy: { createdAt: 'desc' },\n      select: { orderNumber: true, createdAt: true }\n    })\n  ]);\n\n  return {\n    totalOrders,\n    todayOrders,\n    lastOrderNumber: lastOrder?.orderNumber,\n    lastOrderDate: lastOrder?.createdAt\n  };\n}\n\n/**\n * Quick order number generation with default settings\n */\nexport async function createOrderNumber(outletId: number): Promise<string> {\n  const result = await generateOrderNumber({\n    format: 'sequential',\n    outletId,\n    prefix: 'ORD',\n    sequenceLength: 4\n  });\n  \n  return result.orderNumber;\n}\n\n/**\n * Generate order number with specific format\n */\nexport async function createOrderNumberWithFormat(\n  outletId: number, \n  format: OrderNumberFormat\n): Promise<OrderNumberResult> {\n  const config: OrderNumberConfig = {\n    format,\n    outletId,\n    prefix: 'ORD',\n    sequenceLength: 4,\n    randomLength: 6,\n    includeDate: true\n  };\n  \n  return await generateOrderNumber(config);\n}\n\n/**\n * Generate multiple order numbers for testing\n */\nexport async function generateTestOrderNumbers(\n  outletId: number, \n  count: number, \n  format: OrderNumberFormat = 'sequential'\n): Promise<string[]> {\n  const orderNumbers: string[] = [];\n  \n  for (let i = 0; i < count; i++) {\n    const result = await createOrderNumberWithFormat(outletId, format);\n    orderNumbers.push(result.orderNumber);\n  }\n  \n  return orderNumbers;\n}\n\n/**\n * Analyze order number\n */\nexport function analyzeOrderNumber(orderNumber: string) {\n  const isValid = validateOrderNumber(orderNumber);\n  const parsed = parseOrderNumber(orderNumber);\n  \n  return {\n    orderNumber,\n    isValid,\n    parsed,\n    format: parsed?.format || 'unknown',\n    outletId: parsed?.outletId,\n    sequence: parsed?.sequence,\n    date: parsed?.date,\n    random: parsed?.random\n  };\n}\n\n// ============================================================================\n// SIMPLIFIED API FUNCTIONS (for db object)\n// ============================================================================\n\nexport const simplifiedOrderNumbers = {\n  /**\n   * Get outlet order stats (simplified API)\n   */\n  getOutletStats: async (outletId: number) => {\n    return await getOutletOrderStats(outletId);\n  },\n\n  /**\n   * Create order number with format (simplified API)\n   */\n  createWithFormat: async (outletId: number, format: OrderNumberFormat) => {\n    return await createOrderNumberWithFormat(outletId, format);\n  },\n\n  /**\n   * Generate multiple order numbers (simplified API)\n   */\n  generateMultiple: async (outletId: number, count: number, format: OrderNumberFormat = 'sequential') => {\n    return await generateTestOrderNumbers(outletId, count, format);\n  },\n\n  /**\n   * Validate order number format (simplified API)\n   */\n  validateFormat: (orderNumber: string) => {\n    return validateOrderNumber(orderNumber);\n  },\n\n  /**\n   * Get format info (simplified API)\n   */\n  getFormatInfo: (format: OrderNumberFormat) => {\n    return getFormatInfo(format);\n  }\n};","// ============================================================================\n// CATEGORY FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains category functions that follow the simplified API pattern\n// - Input: id (number)\n// - Database: queries by id, uses numbers for relationships\n// - Return: includes id (number)\n\nimport { prisma } from './client';\n\n// ============================================================================\n// CATEGORY LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find category by ID (simplified API)\n */\nexport const findById = async (id: number) => {\n  return await prisma.category.findUnique({\n    where: { id },\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Find first category matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.category.findFirst({\n    where,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Find many categories matching criteria (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, select = {}, orderBy = { name: 'asc' }, take, skip } = options;\n  \n  return await prisma.category.findMany({\n    where,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true,\n      ...select\n    },\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Create new category (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.category.create({\n    data,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Update category (simplified API)\n */\nexport const update = async (id: number, data: any) => {\n  return await prisma.category.update({\n    where: { id },\n    data,\n    select: {\n      id: true,\n      name: true,\n      description: true,\n      isActive: true,\n      isDefault: true,\n      createdAt: true,\n      updatedAt: true\n    }\n  });\n};\n\n/**\n * Delete category (hard delete) (simplified API)\n * Note: Dependency check should be done before calling this function\n */\nexport const deleteCategory = async (id: number) => {\n  return await prisma.category.delete({\n    where: { id }\n  });\n};\n\n/**\n * Search categories with pagination (simplified API)\n */\nexport const search = async (filters: any) => {\n  const { page = 1, limit = 20, sortBy = 'name', sortOrder = 'asc', ...whereFilters } = filters;\n  const skip = (page - 1) * limit;\n\n  console.log('ðŸ” DB category.search - Received filters:', filters);\n\n  // Build where clause\n  const where: any = {};\n  \n  // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n  // Default to active categories only unless explicitly requesting all\n  if (whereFilters.isActive !== undefined) {\n    where.isActive = whereFilters.isActive;\n  } else {\n    where.isActive = true; // Default: only show active categories\n  }\n  \n  // Text search by category name - accept both 'q' and 'search' parameters\n  const searchTerm = (whereFilters.q || whereFilters.search)?.trim();\n  console.log('ðŸ” DB category.search - searchTerm:', searchTerm, 'length:', searchTerm?.length);\n  \n  if (searchTerm && searchTerm.length > 0) {\n    where.name = { \n      contains: searchTerm, \n      mode: 'insensitive' \n    };\n    console.log('âœ… DB category.search - Added name filter:', where.name);\n  } else {\n    console.log('âš ï¸ DB category.search - No search term, will return all categories');\n  }\n  \n  console.log('ðŸ” DB category.search - Final where clause:', JSON.stringify(where, null, 2));\n\n  // Build orderBy based on sortBy and sortOrder\n  const orderBy: any = {};\n  if (sortBy === 'name' || sortBy === 'createdAt' || sortBy === 'updatedAt') {\n    orderBy[sortBy] = sortOrder;\n  } else {\n    orderBy.name = 'asc'; // Default\n  }\n\n  const [categories, total] = await Promise.all([\n    prisma.category.findMany({\n      where,\n      select: {\n        id: true,\n        name: true,\n        description: true,\n        isActive: true,\n        isDefault: true,\n        createdAt: true,\n        updatedAt: true,\n        _count: {\n          select: {\n            products: true\n          }\n        }\n      },\n      orderBy,\n      skip,\n      take: limit\n    }),\n    prisma.category.count({ where })\n  ]);\n\n  console.log(`ðŸ“Š db.categories.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, categories=${categories.length}`);\n\n  return {\n    data: categories,\n    total,\n    page,\n    limit,\n    hasMore: skip + limit < total,\n    totalPages: Math.ceil(total / limit)\n  };\n};\n\n/**\n * Get category statistics (simplified API)\n */\nexport const getStats = async (whereClause?: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.category.count({ where });\n};\n\n// ============================================================================\n// SIMPLIFIED CATEGORY API\n// ============================================================================\n\nexport const simplifiedCategories = {\n  findById,\n  findFirst,\n  findMany,\n  create,\n  update,\n  delete: deleteCategory,\n  search,\n  getStats\n};\n","// ============================================================================\n// AUDIT LOG FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains audit log functions that follow the simplified API pattern\n\nimport { prisma } from './client';\n\n// ============================================================================\n// AUDIT LOG LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find audit logs with filtering (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, include = {}, orderBy = { createdAt: 'desc' }, take, skip } = options;\n  \n  return await prisma.auditLog.findMany({\n    where,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      },\n      ...include\n    },\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Get audit log statistics (simplified API)\n */\nexport const getStats = async (whereClause?: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.auditLog.count({ where });\n};\n\n/**\n * Find first audit log matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.auditLog.findFirst({\n    where,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      }\n    }\n  });\n};\n\n/**\n * Create audit log (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.auditLog.create({\n    data,\n    include: {\n      user: {\n        select: {\n          email: true,\n          firstName: true,\n          lastName: true,\n          role: true\n        }\n      }\n    }\n  });\n};\n\n// ============================================================================\n// SIMPLIFIED AUDIT LOGS API\n// ============================================================================\n\nexport const simplifiedAuditLogs = {\n  findMany,\n  findFirst,\n  create,\n  getStats\n};\n","// ============================================================================\n// ORDER ITEM FUNCTIONS - SIMPLIFIED API\n// ============================================================================\n// This file contains order item functions that follow the simplified API pattern\n\nimport { prisma } from './client';\n\n// ============================================================================\n// ORDER ITEM LOOKUP FUNCTIONS\n// ============================================================================\n\n/**\n * Find order items with filtering (simplified API)\n */\nexport const findMany = async (options: any = {}) => {\n  const { where = {}, include = {}, orderBy = { createdAt: 'desc' }, take, skip } = options;\n  \n  return await prisma.orderItem.findMany({\n    where,\n    include,\n    orderBy,\n    take,\n    skip\n  });\n};\n\n/**\n * Group by order items (simplified API)\n */\nexport const groupBy = async (options: any) => {\n  const { by, where = {}, _count = {}, _sum = {}, _avg = {}, orderBy, take } = options;\n  \n  // Build the groupBy options object\n  const groupByOptions: any = {\n    by,\n    where,\n    orderBy,\n    take\n  };\n  \n  // Only add aggregation options if they have content\n  if (Object.keys(_count).length > 0) {\n    groupByOptions._count = _count;\n  }\n  \n  if (Object.keys(_sum).length > 0) {\n    groupByOptions._sum = _sum;\n  }\n  \n  if (Object.keys(_avg).length > 0) {\n    groupByOptions._avg = _avg;\n  }\n  \n  return await prisma.orderItem.groupBy(groupByOptions);\n};\n\n/**\n * Get order item statistics (simplified API)\n */\nexport const getStats = async (whereClause?: any) => {\n  // Handle both direct where clause and object with where property\n  const where = whereClause?.where || whereClause || {};\n  return await prisma.orderItem.count({ where });\n};\n\n/**\n * Find first order item matching criteria (simplified API)\n */\nexport const findFirst = async (where: any) => {\n  return await prisma.orderItem.findFirst({\n    where,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Create order item (simplified API)\n */\nexport const create = async (data: any) => {\n  return await prisma.orderItem.create({\n    data,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Update order item (simplified API)\n */\nexport const update = async (id: number, data: any) => {\n  return await prisma.orderItem.update({\n    where: { id },\n    data,\n    include: {\n      order: true,\n      product: true\n    }\n  });\n};\n\n/**\n * Delete order item (simplified API)\n */\nexport const deleteOrderItem = async (id: number) => {\n  return await prisma.orderItem.delete({\n    where: { id }\n  });\n};\n\n// ============================================================================\n// SIMPLIFIED ORDER ITEMS API\n// ============================================================================\n\nexport const simplifiedOrderItems = {\n  findMany,\n  findFirst,\n  create,\n  update,\n  delete: deleteOrderItem,\n  getStats,\n  groupBy\n};\n","import { prisma } from './client';\nimport { randomBytes } from 'crypto';\n\n/**\n * Generate a unique session ID\n */\nexport function generateSessionId(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Create a new session for a user and invalidate all previous sessions\n * This implements \"single session\" behavior - only the latest login is valid\n */\nexport async function createUserSession(\n  userId: number,\n  ipAddress?: string,\n  userAgent?: string\n) {\n  const sessionId = generateSessionId();\n  const expiresAt = new Date();\n  expiresAt.setDate(expiresAt.getDate() + 7); // 7 days expiry\n\n  // Start a transaction to ensure atomicity\n  return await prisma.$transaction(async (tx) => {\n    // 1. Invalidate ALL previous sessions for this user\n    await tx.userSession.updateMany({\n      where: {\n        userId,\n        isActive: true,\n      },\n      data: {\n        isActive: false,\n        invalidatedAt: new Date(),\n      },\n    });\n\n    // 2. Create new session\n    const session = await tx.userSession.create({\n      data: {\n        userId,\n        sessionId,\n        ipAddress,\n        userAgent,\n        expiresAt,\n        isActive: true,\n      },\n    });\n\n    return session;\n  });\n}\n\n/**\n * Validate a session by sessionId\n * Returns true if session is valid (active and not expired)\n */\nexport async function validateSession(sessionId: string): Promise<boolean> {\n  if (!sessionId) {\n    return false;\n  }\n\n  const session = await prisma.userSession.findUnique({\n    where: { sessionId },\n  });\n\n  if (!session) {\n    return false;\n  }\n\n  // Check if session is active\n  if (!session.isActive) {\n    return false;\n  }\n\n  // Check if session is expired\n  if (session.expiresAt < new Date()) {\n    // Auto-invalidate expired session\n    await prisma.userSession.update({\n      where: { id: session.id },\n      data: {\n        isActive: false,\n        invalidatedAt: new Date(),\n      },\n    });\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Invalidate a specific session (for logout)\n */\nexport async function invalidateSession(sessionId: string): Promise<void> {\n  await prisma.userSession.updateMany({\n    where: {\n      sessionId,\n      isActive: true,\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Invalidate all sessions for a user\n */\nexport async function invalidateAllUserSessions(userId: number): Promise<void> {\n  await prisma.userSession.updateMany({\n    where: {\n      userId,\n      isActive: true,\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n}\n\n/**\n * Get active sessions for a user\n */\nexport async function getUserActiveSessions(userId: number) {\n  return await prisma.userSession.findMany({\n    where: {\n      userId,\n      isActive: true,\n      expiresAt: {\n        gt: new Date(),\n      },\n    },\n    orderBy: {\n      createdAt: 'desc',\n    },\n  });\n}\n\n/**\n * Clean up expired sessions (can be run periodically)\n */\nexport async function cleanupExpiredSessions(): Promise<number> {\n  const result = await prisma.userSession.updateMany({\n    where: {\n      isActive: true,\n      expiresAt: {\n        lt: new Date(),\n      },\n    },\n    data: {\n      isActive: false,\n      invalidatedAt: new Date(),\n    },\n  });\n\n  return result.count;\n}\n\nexport const sessions = {\n  generateSessionId,\n  createUserSession,\n  validateSession,\n  invalidateSession,\n  invalidateAllUserSessions,\n  getUserActiveSessions,\n  cleanupExpiredSessions,\n};\n\n","/**\n * Comprehensive Audit Logging System\n * \n * This module provides a complete audit logging solution that tracks:\n * - Who made changes (user, role, context)\n * - What was changed (entity, fields, values)\n * - When changes occurred (timestamp, session)\n * - Where changes came from (IP, user agent)\n * - Why changes were made (business context)\n */\n\nimport { PrismaClient } from '@prisma/client';\n\n// Types for audit logging\nexport interface AuditContext {\n  userId?: number;\n  userEmail?: string;\n  userRole?: string;\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n  outletId?: number;\n  ipAddress?: string;\n  userAgent?: string;\n  sessionId?: string;\n  requestId?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface AuditLogData {\n  action: 'CREATE' | 'UPDATE' | 'DELETE' | 'LOGIN' | 'LOGOUT' | 'VIEW' | 'EXPORT' | 'IMPORT' | 'CUSTOM';\n  entityType: string;\n  entityId: string;\n  entityName?: string;\n  oldValues?: Record<string, any>;\n  newValues?: Record<string, any>;\n  changes?: Record<string, { old: any; new: any }>;\n  severity?: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL';\n  category?: 'GENERAL' | 'SECURITY' | 'BUSINESS' | 'SYSTEM' | 'COMPLIANCE';\n  description?: string;\n  context: AuditContext;\n}\n\nexport interface AuditLogFilter {\n  action?: string;\n  entityType?: string;\n  entityId?: string;\n  userId?: number;\n  // Note: merchantId removed - tenant databases are already isolated per tenant\n  outletId?: number;\n  severity?: string;\n  category?: string;\n  startDate?: Date;\n  endDate?: Date;\n  limit?: number;\n  offset?: number;\n}\n\n// Audit logger class\nexport class AuditLogger {\n  private prisma: PrismaClient;\n  private idCounter: number = 0;\n\n  constructor(prisma: PrismaClient) {\n    this.prisma = prisma;\n  }\n\n  // Get next public ID\n  private async getNextPublicId(): Promise<number> {\n    // Temporarily disabled - AuditLog model not in schema\n    return 1;\n  }\n\n  // Main logging method\n  async log(data: AuditLogData): Promise<void> {\n    try {\n      console.log('ðŸ” AuditLogger.log - Starting audit log creation...');\n      const id = await this.getNextPublicId();\n      console.log('ðŸ” AuditLogger.log - Got id:', id);\n      \n      // Validate foreign key IDs to prevent constraint violations\n      const validatedUserId = await this.validateUserId(data.context.userId);\n      // Note: merchantId validation removed - tenant databases are already isolated per tenant\n      const validatedOutletId = await this.validateOutletId(data.context.outletId);\n      \n      console.log('ðŸ” AuditLogger.log - About to create audit log with data:', {\n        id,\n        action: data.action,\n        entityType: data.entityType,\n        entityId: data.entityId,\n        userId: validatedUserId,\n        outletId: validatedOutletId\n      });\n      \n      // Temporarily disabled - AuditLog model not in schema\n      console.log('ðŸ” Audit log would be created:', {\n        id,\n        action: data.action,\n        entityType: data.entityType,\n        entityId: data.entityId\n      });\n      console.log('âœ… AuditLogger.log - Audit log created successfully');\n    } catch (error) {\n      // Don't throw errors from audit logging to avoid breaking main operations\n      console.error('âŒ AuditLogger.log - Audit logging failed:', error);\n      console.error('âŒ AuditLogger.log - Error details:', error instanceof Error ? error.message : String(error));\n      console.error('âŒ AuditLogger.log - Error stack:', error instanceof Error ? error.stack : undefined);\n    }\n  }\n\n  // Validate foreign key IDs to prevent constraint violations\n  private async validateUserId(userId?: number): Promise<number | null> {\n    if (!userId) return null;\n    \n    try {\n      const user = await this.prisma.user.findUnique({\n        where: { id: userId },\n        select: { id: true }\n      });\n      return user ? userId : null;\n    } catch (error) {\n      console.warn('âš ï¸ AuditLogger - Failed to validate userId:', userId, error);\n      return null;\n    }\n  }\n\n  // Note: validateMerchantId removed - tenant databases are already isolated per tenant\n\n  private async validateOutletId(outletId?: number): Promise<number | null> {\n    if (!outletId) return null;\n    \n    try {\n      const outlet = await this.prisma.outlet.findUnique({\n        where: { id: outletId },\n        select: { id: true }\n      });\n      return outlet ? outletId : null;\n    } catch (error) {\n      console.warn('âš ï¸ AuditLogger - Failed to validate outletId:', outletId, error);\n      return null;\n    }\n  }\n\n  // Convenience methods for common operations\n  async logCreate(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    newValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'CREATE',\n      entityType,\n      entityId,\n      entityName,\n      newValues,\n      description: description || `Created ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logUpdate(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    oldValues: Record<string, any>,\n    newValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    const changes = this.calculateChanges(oldValues, newValues);\n    \n    await this.log({\n      action: 'UPDATE',\n      entityType,\n      entityId,\n      entityName,\n      oldValues,\n      newValues,\n      changes,\n      description: description || `Updated ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logDelete(\n    entityType: string,\n    entityId: string,\n    entityName: string,\n    oldValues: Record<string, any>,\n    context: AuditContext,\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'DELETE',\n      entityType,\n      entityId,\n      entityName,\n      oldValues,\n      description: description || `Deleted ${entityType.toLowerCase()}: ${entityName}`,\n      context\n    });\n  }\n\n  async logLogin(\n    userId: number,\n    userEmail: string,\n    userRole: string,\n    context: AuditContext,\n    success: boolean = true\n  ): Promise<void> {\n    await this.log({\n      action: 'LOGIN',\n      entityType: 'User',\n      entityId: userId.toString(),\n      entityName: userEmail,\n      newValues: { success, timestamp: new Date().toISOString() },\n      severity: success ? 'INFO' : 'WARNING',\n      category: 'SECURITY',\n      description: success ? `User logged in: ${userEmail}` : `Failed login attempt: ${userEmail}`,\n      context\n    });\n  }\n\n  async logLogout(\n    userId: number,\n    userEmail: string,\n    context: AuditContext\n  ): Promise<void> {\n    await this.log({\n      action: 'LOGOUT',\n      entityType: 'User',\n      entityId: userId.toString(),\n      entityName: userEmail,\n      category: 'SECURITY',\n      description: `User logged out: ${userEmail}`,\n      context\n    });\n  }\n\n  async logSecurityEvent(\n    event: string,\n    entityType: string,\n    entityId: string,\n    context: AuditContext,\n    severity: 'WARNING' | 'ERROR' | 'CRITICAL' = 'WARNING',\n    description?: string\n  ): Promise<void> {\n    await this.log({\n      action: 'CUSTOM',\n      entityType,\n      entityId,\n      severity,\n      category: 'SECURITY',\n      description: description || `Security event: ${event}`,\n      context\n    });\n  }\n\n  // Calculate changes between old and new values\n  private calculateChanges(oldValues: Record<string, any>, newValues: Record<string, any>): Record<string, { old: any; new: any }> {\n    const changes: Record<string, { old: any; new: any }> = {};\n    \n    // Check for changed fields\n    const allKeys = new Set([...Object.keys(oldValues), ...Object.keys(newValues)]);\n    \n    for (const key of Array.from(allKeys)) {\n      const oldValue = oldValues[key];\n      const newValue = newValues[key];\n      \n      if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n        changes[key] = { old: oldValue, new: newValue };\n      }\n    }\n    \n    return changes;\n  }\n\n  // Query audit logs\n  async getAuditLogs(filter: AuditLogFilter = {}): Promise<{\n    logs: any[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    const where: any = {};\n    \n    if (filter.action) where.action = filter.action;\n    if (filter.entityType) where.entityType = filter.entityType;\n    if (filter.entityId) where.entityId = filter.entityId;\n    if (filter.userId) where.userId = filter.userId;\n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (filter.outletId) where.outletId = filter.outletId;\n    if (filter.severity) where.severity = filter.severity;\n    if (filter.category) where.category = filter.category;\n    \n    if (filter.startDate || filter.endDate) {\n      where.createdAt = {};\n      if (filter.startDate) where.createdAt.gte = filter.startDate;\n      if (filter.endDate) where.createdAt.lte = filter.endDate;\n    }\n\n    const limit = filter.limit || 50;\n    const offset = filter.offset || 0;\n\n    // Temporarily disabled - AuditLog model not in schema\n    const logs: any[] = [];\n    const total = 0;\n\n    // Transform logs to include parsed JSON fields\n    const transformedLogs = logs.map(log => ({\n      id: log.id,\n      action: log.action,\n      entityType: log.entityType,\n      entityId: log.entityId,\n      entityName: log.entityName,\n      user: log.user ? {\n        id: log.user.id,\n        email: log.user.email,\n        name: `${log.user.firstName} ${log.user.lastName}`,\n        role: log.user.role\n      } : null,\n      // Note: merchant removed - tenant databases are already isolated per tenant\n      outlet: log.outlet ? {\n        id: log.outlet.id,\n        name: log.outlet.name\n      } : null,\n      oldValues: log.oldValues ? JSON.parse(log.oldValues) : null,\n      newValues: log.newValues ? JSON.parse(log.newValues) : null,\n      changes: log.changes ? JSON.parse(log.changes) : null,\n      ipAddress: log.ipAddress,\n      userAgent: log.userAgent,\n      sessionId: log.sessionId,\n      requestId: log.requestId,\n      metadata: log.metadata ? JSON.parse(log.metadata) : null,\n      severity: log.severity,\n      category: log.category,\n      description: log.description,\n      createdAt: log.createdAt\n    }));\n\n    return {\n      logs: transformedLogs,\n      total,\n      hasMore: offset + limit < total\n    };\n  }\n\n  // Get audit statistics\n  async getAuditStats(filter: Partial<AuditLogFilter> = {}): Promise<{\n    totalLogs: number;\n    logsByAction: Record<string, number>;\n    logsByEntity: Record<string, number>;\n    logsBySeverity: Record<string, number>;\n    logsByCategory: Record<string, number>;\n    recentActivity: number; // Last 24 hours\n  }> {\n    const where: any = {};\n    \n    // Note: merchantId filtering removed - tenant databases are already isolated per tenant\n    if (filter.outletId) where.outletId = filter.outletId;\n    if (filter.startDate || filter.endDate) {\n      where.createdAt = {};\n      if (filter.startDate) where.createdAt.gte = filter.startDate;\n      if (filter.endDate) where.createdAt.lte = filter.endDate;\n    }\n\n    // Temporarily disabled - AuditLog model not in schema\n    const totalLogs = 0;\n    const actionStats: any[] = [];\n    const entityStats: any[] = [];\n    const severityStats: any[] = [];\n    const categoryStats: any[] = [];\n    const recentActivity = 0;\n\n    return {\n      totalLogs,\n      logsByAction: actionStats.reduce((acc, item) => {\n        acc[item.action] = item._count.action;\n        return acc;\n      }, {} as Record<string, number>),\n      logsByEntity: entityStats.reduce((acc, item) => {\n        acc[item.entityType] = item._count.entityType;\n        return acc;\n      }, {} as Record<string, number>),\n      logsBySeverity: severityStats.reduce((acc, item) => {\n        acc[item.severity] = item._count.severity;\n        return acc;\n      }, {} as Record<string, number>),\n      logsByCategory: categoryStats.reduce((acc, item) => {\n        acc[item.category] = item._count.category;\n        return acc;\n      }, {} as Record<string, number>),\n      recentActivity\n    };\n  }\n}\n\n// Create singleton instance\nlet auditLogger: AuditLogger | null = null;\n\nexport function getAuditLogger(prisma?: PrismaClient): AuditLogger {\n  if (!auditLogger) {\n    if (!prisma) {\n      throw new Error('Prisma client is required for audit logging');\n    }\n    auditLogger = new AuditLogger(prisma);\n  }\n  return auditLogger;\n}\n\n// Helper function to extract audit context from request\nexport function extractAuditContext(request: Request, user?: any): AuditContext {\n  const headers = request.headers;\n  \n  return {\n    userId: user?.id,\n    userEmail: user?.email,\n    userRole: user?.role,\n    // Note: merchantId removed - tenant databases are already isolated per tenant\n    outletId: user?.outletId,\n    ipAddress: headers.get('x-forwarded-for') || headers.get('x-real-ip') || 'unknown',\n    userAgent: headers.get('user-agent') || 'unknown',\n    sessionId: headers.get('x-session-id') || undefined,\n    requestId: headers.get('x-request-id') || undefined,\n    metadata: {\n      method: request.method,\n      url: request.url,\n      timestamp: new Date().toISOString()\n    }\n  };\n}\n","// ============================================================================\n// SMART REGISTRATION - HANDLES ALL USER ROLES\n// ============================================================================\n\nimport { prisma } from './client';\nimport { createUser } from './user';\nimport { createSubscription } from './subscription';\nimport { hashPassword } from '@rentalshop/auth';\nimport type { UserCreateInput } from '@rentalshop/types';\n\nexport interface RegistrationInput {\n  email: string;\n  password: string;\n  name: string;\n  phone?: string;\n  role?: 'ADMIN' | 'MERCHANT' | 'OUTLET_ADMIN' | 'OUTLET_STAFF';\n  // For merchant registration\n  businessName?: string;\n  outletName?: string;\n  // Business configuration (locked after registration)\n  businessType?: 'GENERAL' | 'VEHICLE' | 'CLOTHING' | 'EQUIPMENT';\n  pricingType?: 'FIXED' | 'HOURLY' | 'DAILY';\n  // Address fields for merchant registration\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  // For outlet staff/admin registration\n  merchantCode?: string;\n  outletCode?: string;\n}\n\nexport interface RegistrationResult {\n  success: boolean;\n  user: {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    role: string;\n    merchant?: {\n      id: number;\n      name: string;\n    };\n    outlet?: {\n      id: number;\n      name: string;\n    };\n  };\n  token: string;\n  message: string;\n}\n\n/**\n * Smart registration that handles all user roles\n * Based on role and provided data, creates appropriate account structure\n */\nexport async function registerUser(\n  data: RegistrationInput\n): Promise<RegistrationResult> {\n  try {\n    // Start transaction to ensure all operations succeed or fail together\n    const result = await prisma.$transaction(async (tx: any) => {\n      // 1. Check if user email already exists\n      const existingUser = await tx.user.findUnique({\n        where: { email: data.email }\n      });\n\n      if (existingUser) {\n        throw new Error('User with this email already exists');\n      }\n\n      // Determine registration type based on role and data\n      const registrationType = determineRegistrationType(data);\n\n      if (registrationType === 'MERCHANT') {\n        // Legacy registerMerchant removed - use registerTenantWithTrial instead\n        // This function should not be called directly - use registerTenantWithTrial for tenant registration\n        throw new Error('MERCHANT registration is deprecated. Use registerTenantWithTrial for tenant registration instead.');\n      } else if (registrationType === 'OUTLET_ADMIN' || registrationType === 'OUTLET_STAFF') {\n        return await registerOutletUser(tx, data);\n      } else {\n        return await registerBasicUser(tx, data);\n      }\n    });\n\n    return result;\n  } catch (error: any) {\n    console.error('Registration error:', error);\n    throw new Error(error.message || 'Registration failed');\n  }\n}\n\n/**\n * Determine registration type based on input data\n */\nfunction determineRegistrationType(data: RegistrationInput): 'MERCHANT' | 'OUTLET_ADMIN' | 'OUTLET_STAFF' | 'BASIC' {\n  // If role is explicitly set, use it\n  if (data.role === 'MERCHANT') {\n    return 'MERCHANT';\n  }\n  if (data.role === 'OUTLET_ADMIN' || data.role === 'OUTLET_STAFF') {\n    return data.role;\n  }\n\n  // If businessName is provided, assume merchant registration\n  if (data.businessName) {\n    return 'MERCHANT';\n  }\n\n  // If merchantCode is provided, assume outlet user registration\n  if (data.merchantCode) {\n    return 'OUTLET_STAFF'; // Default to staff, can be upgraded to admin\n  }\n\n  // Default to basic user registration\n  return 'BASIC';\n}\n\n/**\n * LEGACY: Register merchant function removed\n * Use registerTenantWithTrial instead for tenant registration\n * Tenant databases don't have merchant model anymore\n */\n// Note: registerMerchant function removed - tenant DBs don't have merchant model\n// Use registerTenantWithTrial instead\n\n/**\n * LEGACY: Register merchant with trial plan removed\n * Use registerTenantWithTrial instead\n */\n// Note: registerMerchantWithTrial function removed\n// Use registerTenantWithTrial instead for tenant registration\n\n/**\n * Register outlet admin/staff\n * Note: Tenant databases don't have merchant model - outlet lookup only\n */\nasync function registerOutletUser(tx: any, data: RegistrationInput) {\n  // Note: merchantCode removed - tenant DBs don't have merchant model\n  // Use outletCode instead to find outlet directly\n  \n  if (!data.outletCode) {\n    throw new Error('Outlet code is required for outlet user registration');\n  }\n\n  // Find outlet by code (assuming outletCode is the outlet's id)\n  const outlet = await tx.outlet.findUnique({\n    where: { id: parseInt(data.outletCode) }\n  });\n\n  if (!outlet) {\n    throw new Error('Invalid outlet code. Please check with your manager.');\n  }\n\n  // Create outlet user\n  const hashedPassword = await hashPassword(data.password);\n  const user = await tx.user.create({\n    data: {\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: data.role || 'OUTLET_STAFF',\n      outletId: outlet.id,\n      isActive: true\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n      outlet: {\n        id: outlet.id,\n        name: outlet.name\n      }\n    },\n    token: '', // Will be generated by auth service\n    message: `${data.role === 'OUTLET_ADMIN' ? 'Outlet admin' : 'Staff'} account created successfully`\n  };\n}\n\n/**\n * Register basic user (CLIENT, SHOP_OWNER, ADMIN)\n */\nasync function registerBasicUser(tx: any, data: RegistrationInput) {\n  const hashedPassword = await hashPassword(data.password);\n  const user = await tx.user.create({\n    data: {\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.name.split(' ')[0] || '',\n      lastName: data.name.split(' ').slice(1).join(' ') || '',\n      phone: data.phone,\n      role: data.role || 'CLIENT',\n      isActive: true\n    }\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n      firstName: user.firstName,\n      lastName: user.lastName,\n      role: user.role,\n    },\n    token: '', // Will be generated by auth service\n    message: 'User account created successfully'\n  };\n}\n\n/**\n * Register tenant with trial plan (Multi-tenant version)\n * Creates tenant in Main DB, creates isolated database, and sets up initial user\n */\nexport async function registerTenantWithTrial(data: {\n  businessName: string;\n  email: string;\n  password: string;\n  firstName: string;\n  lastName: string;\n  phone?: string;\n  subdomain?: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  zipCode?: string;\n  country?: string;\n  taxId?: string;\n  businessType?: string;\n  website?: string;\n  description?: string;\n  outletName?: string;\n}): Promise<{\n  tenant: {\n    id: string;\n    subdomain: string;\n    name: string;\n    email: string;\n  };\n  user: {\n    id: number;\n    email: string;\n    firstName: string;\n    lastName: string;\n    role: string;\n  };\n  outlet: {\n    id: number;\n    name: string;\n  };\n  subscription: {\n    planName: string;\n    trialEnd: Date;\n  };\n  tenantUrl: string;\n}> {\n  // Import multi-tenant utilities\n  const {\n    createTenant,\n    subdomainExists,\n    tenantEmailExists,\n    getDefaultPlan\n  } = await import('./main-db');\n  const { getTenantDb, createTenantDatabase } = await import('./tenant-db');\n  const { \n    sanitizeSubdomain: sanitize, \n    validateSubdomain: validate,\n    buildTenantUrl: buildUrl\n  } = await import('./subdomain-utils');\n  \n  // Generate subdomain if not provided\n  const subdomain = data.subdomain \n    ? sanitize(data.subdomain) \n    : sanitize(data.businessName);\n\n  // Validate subdomain\n  if (!validate(subdomain)) {\n    throw new Error('Invalid subdomain format');\n  }\n\n  // Check if subdomain or email already exists\n  if (await subdomainExists(subdomain)) {\n    throw new Error('Subdomain already taken');\n  }\n\n  if (await tenantEmailExists(data.email)) {\n    throw new Error('Email already registered');\n  }\n\n  // Get default plan from Main DB\n  const defaultPlan = await getDefaultPlan();\n  const planId = defaultPlan?.id || undefined;\n\n  // Calculate trial end date\n  const trialDays = defaultPlan?.trialDays || 14;\n  const trialStart = new Date();\n  const trialEnd = new Date(trialStart.getTime() + (trialDays * 24 * 60 * 60 * 1000));\n\n  // Create tenant database first (this takes time)\n  console.log(`Creating database for tenant: ${subdomain}`);\n  const databaseUrl = await createTenantDatabase(subdomain);\n\n  // Create tenant in Main DB\n  const tenant = await createTenant({\n    subdomain,\n    name: data.businessName,\n    email: data.email,\n    phone: data.phone,\n    address: data.address,\n    city: data.city,\n    state: data.state,\n    zipCode: data.zipCode,\n    country: data.country,\n    taxId: data.taxId,\n    businessType: data.businessType,\n    website: data.website,\n    description: data.description,\n    databaseUrl,\n    status: 'active',\n    planId: planId || undefined,\n    subscriptionStatus: 'trial',\n    trialStart,\n    trialEnd\n  });\n\n  // Get tenant DB connection\n  const tenantDb = await getTenantDb(subdomain);\n\n  // Setup initial data in tenant database\n  const result = await tenantDb.$transaction(async (tx: any) => {\n    // 1. Get or create trial plan in tenant DB (if needed for reference)\n    let trialPlan = await tx.plan.findFirst({\n      where: { \n        name: 'Trial',\n        isActive: true \n      }\n    });\n\n    if (!trialPlan && defaultPlan) {\n      trialPlan = await tx.plan.create({\n        data: {\n          name: defaultPlan.name,\n          description: defaultPlan.description,\n          basePrice: defaultPlan.basePrice,\n          currency: defaultPlan.currency,\n          trialDays: defaultPlan.trialDays,\n          limits: defaultPlan.limits,\n          features: defaultPlan.features,\n          isActive: defaultPlan.isActive,\n          isPopular: defaultPlan.isPopular,\n          sortOrder: defaultPlan.sortOrder\n        }\n      });\n    }\n\n    // 2. Create default outlet\n    const outlet = await tx.outlet.create({\n      data: {\n        name: data.outletName || 'Main Store',\n        address: data.address || 'Address to be updated',\n        phone: data.phone,\n        city: data.city,\n        state: data.state,\n        zipCode: data.zipCode,\n        country: data.country,\n        description: 'Default outlet created during registration',\n        isActive: true,\n        isDefault: true\n      }\n    });\n\n    // 3. Create default category\n    const defaultCategory = await tx.category.create({\n      data: {\n        name: 'General',\n        description: 'Default category for general products',\n        isActive: true,\n        isDefault: false\n      }\n    });\n\n    // 4. Create tenant owner user (MERCHANT role)\n    const hashedPassword = await hashPassword(data.password);\n    const user = await tx.user.create({\n      data: {\n        email: data.email,\n        password: hashedPassword,\n        firstName: data.firstName,\n        lastName: data.lastName,\n        phone: data.phone,\n        role: 'MERCHANT',\n        outletId: outlet.id,\n        isActive: true,\n        emailVerified: false,\n        emailVerifiedAt: null\n      }\n    });\n\n    // 5. Create trial subscription (if plan exists)\n    let subscription = null;\n    if (trialPlan && trialPlan.id) {\n      subscription = await tx.subscription.create({\n        data: {\n          planId: trialPlan.id,\n          status: 'trial',\n          currentPeriodStart: trialStart,\n          currentPeriodEnd: trialEnd,\n          trialStart,\n          trialEnd,\n          amount: 0,\n          currency: trialPlan.currency || 'USD',\n          interval: 'month',\n          intervalCount: 1,\n          period: 1,\n          discount: 0,\n          savings: 0\n        }\n      });\n    }\n\n    return {\n      user,\n      outlet,\n      subscription,\n      plan: trialPlan\n    };\n  });\n\n  // Build tenant URL\n  const tenantUrl = buildUrl(subdomain);\n\n  return {\n    tenant: {\n      id: tenant.id,\n      subdomain: tenant.subdomain,\n      name: tenant.name,\n      email: tenant.email\n    },\n    user: {\n      id: result.user.id,\n      email: result.user.email,\n      firstName: result.user.firstName,\n      lastName: result.user.lastName,\n      role: result.user.role\n    },\n    outlet: {\n      id: result.outlet.id,\n      name: result.outlet.name\n    },\n    subscription: {\n      planName: result.plan?.name || 'Trial',\n      trialEnd: result.subscription?.trialEnd || trialEnd\n    },\n    tenantUrl\n  };\n}\n","// ============================================================================\n// EMAIL VERIFICATION DATABASE OPERATIONS\n// ============================================================================\n\nimport { prisma } from './client';\nimport { randomBytes } from 'crypto';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface EmailVerificationToken {\n  id: number;\n  userId: number;\n  token: string;\n  email: string;\n  verified: boolean;\n  verifiedAt: Date | null;\n  expiresAt: Date;\n  createdAt: Date;\n}\n\n// ============================================================================\n// EMAIL VERIFICATION OPERATIONS\n// ============================================================================\n\n/**\n * Generate a secure random token for email verification\n */\nexport function generateVerificationToken(): string {\n  return randomBytes(32).toString('hex');\n}\n\n/**\n * Create email verification record\n */\nexport async function createEmailVerification(\n  userId: number,\n  email: string,\n  expiresInHours: number = 24\n): Promise<EmailVerificationToken> {\n  const token = generateVerificationToken();\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + expiresInHours);\n\n  // Invalidate any existing unverified tokens for this user\n  // Use raw query to avoid Prisma relation validation issues with merchantId\n  await prisma.$executeRaw`\n    UPDATE \"EmailVerification\"\n    SET verified = true, \"verifiedAt\" = NOW()\n    WHERE \"userId\" = ${userId}\n      AND verified = false\n      AND \"expiresAt\" > NOW()\n  `;\n\n  // Create new verification token\n  const verification = await prisma.emailVerification.create({\n    data: {\n      userId,\n      token,\n      email,\n      expiresAt,\n    },\n  });\n\n  return verification;\n}\n\n/**\n * Verify email using token\n */\nexport async function verifyEmailByToken(\n  token: string\n): Promise<{ success: boolean; user?: { id: number; email: string }; error?: string }> {\n  // Don't include user relation to avoid merchantId issues in tenant database\n  const verification = await prisma.emailVerification.findUnique({\n    where: { token },\n    select: {\n      id: true,\n      userId: true,\n      email: true,\n      token: true,\n      verified: true,\n      expiresAt: true,\n    },\n  });\n\n  if (!verification) {\n    return {\n      success: false,\n      error: 'Token khÃ´ng há»£p lá»‡ hoáº·c khÃ´ng tá»“n táº¡i',\n    };\n  }\n\n  if (verification.verified) {\n    return {\n      success: false,\n      error: 'Token Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng',\n    };\n  }\n\n  if (new Date() > verification.expiresAt) {\n    return {\n      success: false,\n      error: 'Token Ä‘Ã£ háº¿t háº¡n. Vui lÃ²ng yÃªu cáº§u gá»­i láº¡i email xÃ¡c thá»±c',\n    };\n  }\n\n  // Update verification record\n  await prisma.emailVerification.update({\n    where: { id: verification.id },\n    data: {\n      verified: true,\n      verifiedAt: new Date(),\n    },\n  });\n\n  // Get user separately without including relations that might have merchantId\n  const user = await prisma.user.findUnique({\n    where: { id: verification.userId },\n    select: {\n      id: true,\n      email: true,\n    },\n  });\n\n  if (!user) {\n    return {\n      success: false,\n      error: 'User khÃ´ng tá»“n táº¡i',\n    };\n  }\n\n  // Update user email verified status\n  await prisma.user.update({\n    where: { id: verification.userId },\n    data: {\n      emailVerified: true,\n      emailVerifiedAt: new Date(),\n    } as any,\n  });\n\n  return {\n    success: true,\n    user: {\n      id: user.id,\n      email: user.email,\n    },\n  };\n}\n\n/**\n * Get verification token by userId\n */\nexport async function getVerificationTokenByUserId(\n  userId: number\n): Promise<EmailVerificationToken | null> {\n  const verification = await prisma.emailVerification.findFirst({\n    where: {\n      userId,\n      verified: false,\n      expiresAt: { gt: new Date() }, // Not expired\n    },\n    orderBy: { createdAt: 'desc' },\n  });\n\n  return verification;\n}\n\n/**\n * Resend verification email (create new token)\n */\nexport async function resendVerificationToken(\n  userId: number,\n  email: string\n): Promise<EmailVerificationToken> {\n  return await createEmailVerification(userId, email);\n}\n\n/**\n * Check if user's email is verified\n */\nexport async function isEmailVerified(userId: number): Promise<boolean> {\n  const user = await prisma.user.findUnique({\n    where: { id: userId },\n    select: { emailVerified: true } as any,\n  });\n\n  return (user as any)?.emailVerified || false;\n}\n\n/**\n * Delete expired verification tokens (cleanup job)\n */\nexport async function deleteExpiredTokens(): Promise<number> {\n  const result = await prisma.emailVerification.deleteMany({\n    where: {\n      expiresAt: { lt: new Date() },\n      verified: false,\n    },\n  });\n\n  return result.count;\n}\n\n"],"mappings":"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","names":["path","fs","import_client","import_pg","generateOrderNumber","search","randomBytes","findById","findMany","getStats","findFirst","create","findMany","getStats","findFirst","create","update","prisma","createTenant","subdomainExists","tenantEmailExists","getDefaultPlan","getTenantDb","createTenantDatabase","import_crypto","generateOrderNumber"]}