// ============================================================================
// NEW: CORRECT DUAL ID CUSTOMER FUNCTIONS
// ============================================================================
// This file contains only the correct customer functions that follow the dual ID system:
// - Input: id (number)
// - Database: queries by id, uses CUIDs for relationships
// - Return: includes both id (CUID) and id (number)

import { prisma } from './client';
import { removeVietnameseDiacritics } from '@rentalshop/utils';
import type { 
  CustomerInput, 
  CustomerUpdateInput, 
  CustomerSearchFilter,
  CustomerSearchResult,
  CustomerSearchResponse 
} from '@rentalshop/types';

// ============================================================================
// CUSTOMER LOOKUP FUNCTIONS (BY PUBLIC ID)
// ============================================================================

/**
 * Get customer by public ID and merchant - follows dual ID system
 * Input: id (number) and merchantId (number), Output: Customer with relations
 */
export async function getCustomerByPublicId(id: number, merchantId: number) {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  return await prisma.customer.findFirst({
    where: { 
      id,
      merchantId: merchant.id // Use CUID for merchant
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      orders: {
        select: {
          id: true,
          orderNumber: true,
          status: true,
          totalAmount: true,
          createdAt: true,
        },
      },
    },
  });
}

/**
 * Get customer by email and merchant - follows dual ID system
 */
export async function getCustomerByEmail(email: string, merchantId: number) {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  return await prisma.customer.findFirst({
    where: {
      merchantId: merchant.id, // Use CUID
      email: email,
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
}

/**
 * Get customer by phone and merchant - follows dual ID system
 */
export async function getCustomerByPhone(phone: string, merchantId: number) {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  return await prisma.customer.findFirst({
    where: {
      merchantId: merchant.id, // Use CUID
      phone: phone,
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
}

// ============================================================================
// CUSTOMER CREATION FUNCTIONS
// ============================================================================

/**
 * Create new customer - follows dual ID system
 * Input: ids (numbers), Output: id (number)
 */
export async function createCustomer(input: CustomerInput): Promise<any> {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: input.merchantId }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${input.merchantId} not found`);
  }

  // Create customer - let database auto-generate ID to avoid race conditions
  // lastName and phone are now optional (nullable) in schema
  // Convert empty strings to null for optional fields
  const customer = await prisma.customer.create({
    data: {
      // ID will be auto-generated by database (autoincrement)
      firstName: input.firstName || '',
      lastName: input.lastName && input.lastName.trim() !== '' ? input.lastName.trim() : null,
      phone: input.phone && input.phone.trim() !== '' ? input.phone.trim() : null,
      // Optional fields: convert empty strings to null
      email: input.email && input.email.trim() !== '' ? input.email.trim() : null,
      address: input.address && input.address.trim() !== '' ? input.address.trim() : null,
      city: input.city && input.city.trim() !== '' ? input.city.trim() : null,
      state: input.state && input.state.trim() !== '' ? input.state.trim() : null,
      zipCode: input.zipCode && input.zipCode.trim() !== '' ? input.zipCode.trim() : null,
      country: input.country && input.country.trim() !== '' ? input.country.trim() : null,
      idNumber: input.idNumber && input.idNumber.trim() !== '' ? input.idNumber.trim() : null,
      notes: input.notes && input.notes.trim() !== '' ? input.notes.trim() : null,
      dateOfBirth: input.dateOfBirth || null,
      idType: input.idType || null,
      isActive: true, // Default to true
      merchantId: merchant.id, // Use CUID
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  return customer;
}

// ============================================================================
// CUSTOMER UPDATE FUNCTIONS
// ============================================================================

/**
 * Update customer - follows dual ID system
 * Input: id (number), Output: id (number)
 */
export async function updateCustomer(
  id: number,
  input: CustomerUpdateInput
): Promise<any> {
  // Find customer by id
  const existingCustomer = await prisma.customer.findUnique({
    where: { id }
  });

  if (!existingCustomer) {
    throw new Error(`Customer with id ${id} not found`);
  }

  // Update customer
  // lastName and phone are now optional (nullable) in schema
  // Convert empty strings to null for optional fields
  const updateData: any = {};
  
  // Only include fields that are being updated
  if (input.firstName !== undefined) updateData.firstName = input.firstName || '';
  if (input.lastName !== undefined) {
    updateData.lastName = input.lastName && input.lastName.trim() !== '' ? input.lastName.trim() : null;
  }
  if (input.phone !== undefined) {
    updateData.phone = input.phone && input.phone.trim() !== '' ? input.phone.trim() : null;
  }
  
  // Optional fields: convert empty strings to null
  if (input.email !== undefined) {
    updateData.email = input.email && input.email.trim() !== '' ? input.email.trim() : null;
  }
  if (input.address !== undefined) {
    updateData.address = input.address && input.address.trim() !== '' ? input.address.trim() : null;
  }
  if (input.city !== undefined) {
    updateData.city = input.city && input.city.trim() !== '' ? input.city.trim() : null;
  }
  if (input.state !== undefined) {
    updateData.state = input.state && input.state.trim() !== '' ? input.state.trim() : null;
  }
  if (input.zipCode !== undefined) {
    updateData.zipCode = input.zipCode && input.zipCode.trim() !== '' ? input.zipCode.trim() : null;
  }
  if (input.country !== undefined) {
    updateData.country = input.country && input.country.trim() !== '' ? input.country.trim() : null;
  }
  if (input.idNumber !== undefined) {
    updateData.idNumber = input.idNumber && input.idNumber.trim() !== '' ? input.idNumber.trim() : null;
  }
  if (input.notes !== undefined) {
    updateData.notes = input.notes && input.notes.trim() !== '' ? input.notes.trim() : null;
  }
  if (input.dateOfBirth !== undefined) {
    updateData.dateOfBirth = input.dateOfBirth || null;
  }
  if (input.idType !== undefined) {
    updateData.idType = input.idType || null;
  }
  if (input.isActive !== undefined) {
    updateData.isActive = input.isActive;
  }
  
  const updatedCustomer = await prisma.customer.update({
    where: { id },
    data: updateData,
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  return updatedCustomer;
}

// ============================================================================
// CUSTOMER SEARCH FUNCTIONS
// ============================================================================

/**
 * Build order by clause for customer queries
 */
function buildCustomerOrderByClause(sortBy?: string, sortOrder?: string): any {
  const validSortFields = [
    'createdAt', 'updatedAt', 'firstName', 'lastName', 'email', 'phone'
  ];
  
  const field = validSortFields.includes(sortBy || '') ? sortBy : 'createdAt';
  const order = sortOrder === 'asc' ? 'asc' : 'desc';
  
  return { [field as string]: order };
}

/**
 * Search customers - follows dual ID system
 * Input: ids (numbers), Output: ids (numbers)
 */
export async function searchCustomers(
  filters: CustomerSearchFilter
): Promise<CustomerSearchResponse> {
  const {
    q,
    merchantId,
    isActive,
    city,
    state,
    country,
    idType,
    limit = 20,
    offset = 0,
    sortBy,
    sortOrder
  } = filters;

  // Build where conditions
  const where: any = {};

  if (merchantId) {
    // Find merchant by id
    const merchant = await prisma.merchant.findUnique({
      where: { id: merchantId },
      select: { id: true }
    });
    
    if (merchant) {
      where.merchantId = merchant.id; // Use CUID
    }
  }

  // Default to active customers only
  if (isActive !== undefined) {
    where.isActive = isActive;
  } else {
    where.isActive = true;
  }

  if (city) {
    where.city = { contains: city.toLowerCase() };
  }

  if (state) {
    where.state = { contains: state.toLowerCase() };
  }

  if (country) {
    where.country = { contains: country.toLowerCase() };
  }

  if (idType) {
    where.idType = idType;
  }

  // Search query for name, email, phone, or idNumber (case-insensitive and diacritics-insensitive)
  if (q && q.trim()) {
    const searchQuery = q.trim();
    // Normalize Vietnamese text to support search without diacritics
    const normalizedQuery = removeVietnameseDiacritics(searchQuery);
    
    // Search with both original and normalized terms to support diacritics-insensitive search
    const searchConditions: any[] = [
      { firstName: { contains: searchQuery, mode: 'insensitive' } },
      { lastName: { contains: searchQuery, mode: 'insensitive' } },
      { email: { contains: searchQuery, mode: 'insensitive' } },
      { phone: { contains: searchQuery } } // Phone numbers are usually exact match
    ];
    
    // Add normalized search if different from original
    if (normalizedQuery !== searchQuery) {
      searchConditions.push(
        { firstName: { contains: normalizedQuery, mode: 'insensitive' } },
        { lastName: { contains: normalizedQuery, mode: 'insensitive' } }
      );
    }
    
    where.OR = searchConditions;
  }

  // Get total count
  const total = await prisma.customer.count({ where });

  // Get customers with pagination
  const customers = await prisma.customer.findMany({
    where,
    include: {
      merchant: {
        select: {
          id: true,
          name: true
        }
      }
    },
    orderBy: buildCustomerOrderByClause(sortBy, sortOrder),
    take: limit,
    skip: offset
  });

  // Transform to match CustomerSearchResult type
  const transformedCustomers: CustomerSearchResult[] = customers.map((customer: any) => ({
    id: customer.id, // Use id (number) as required by CustomerSearchResult
    firstName: customer.firstName,
    lastName: customer.lastName,
    email: customer.email || '',
    phone: customer.phone,
    address: customer.address || undefined,
    city: customer.city || undefined,
    state: customer.state || undefined,
    zipCode: customer.zipCode || undefined,
    country: customer.country || undefined,
    dateOfBirth: customer.dateOfBirth || undefined,
    idNumber: customer.idNumber || undefined,
    idType: customer.idType as any,
    notes: customer.notes || undefined,
    isActive: customer.isActive,
    createdAt: customer.createdAt,
    updatedAt: customer.updatedAt,
    merchantId: customer.merchant.id, // Add merchantId as required
    merchant: {
      id: customer.merchant.id, // Use id (number) as required
      name: customer.merchant.name,
    },
  }));

  return {
    success: true,
    data: {
      customers: transformedCustomers as any, // Type assertion to handle CustomerWithMerchant mismatch
      total,
      page: Math.floor(offset / limit) + 1,
      limit,
      offset,
      hasMore: offset + limit < total,
      totalPages: Math.ceil(total / limit),
    },
  };
}

// ============================================================================
// CUSTOMER UTILITY FUNCTIONS
// ============================================================================

/**
 * Get customers by merchant - follows dual ID system
 */
export async function getCustomersByMerchant(merchantId: number) {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  return await prisma.customer.findMany({
    where: { merchantId: merchant.id }, // Use CUID
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
}

/**
 * Check if customer exists by email - follows dual ID system
 */
export async function customerExistsByEmail(email: string, merchantId: number): Promise<boolean> {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  const customer = await prisma.customer.findFirst({
    where: {
      merchantId: merchant.id, // Use CUID
      email: email,
    },
  });

  return !!customer;
}

/**
 * Check if customer exists by phone - follows dual ID system
 */
export async function customerExistsByPhone(phone: string, merchantId: number): Promise<boolean> {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  const customer = await prisma.customer.findFirst({
    where: {
      merchantId: merchant.id, // Use CUID
      phone: phone,
    },
  });

  return !!customer;
}

// ============================================================================
// SIMPLIFIED API FUNCTIONS (for db object)
// ============================================================================

export const simplifiedCustomers = {
  /**
   * Find customer by ID (simplified API)
   */
  findById: async (id: number) => {
    return await prisma.customer.findUnique({
      where: { id },
      include: {
        merchant: { select: { id: true, name: true } },
        orders: {
          select: { id: true, orderNumber: true, totalAmount: true, status: true, createdAt: true },
          orderBy: { createdAt: 'desc' },
          take: 5
        }
      }
    });
  },

  /**
   * Create new customer (simplified API)
   */
  create: async (data: any) => {
    // lastName and phone are now optional (nullable) in schema
    // Convert empty strings to null for optional fields
    const customerData = {
      ...data,
      firstName: data.firstName || '',
      lastName: data.lastName && data.lastName.trim() !== '' ? data.lastName.trim() : null,
      phone: data.phone && data.phone.trim() !== '' ? data.phone.trim() : null,
      // Optional fields: convert empty strings to null
      email: data.email && data.email.trim() !== '' ? data.email.trim() : null,
      address: data.address && data.address.trim() !== '' ? data.address.trim() : null,
      city: data.city && data.city.trim() !== '' ? data.city.trim() : null,
      state: data.state && data.state.trim() !== '' ? data.state.trim() : null,
      zipCode: data.zipCode && data.zipCode.trim() !== '' ? data.zipCode.trim() : null,
      country: data.country && data.country.trim() !== '' ? data.country.trim() : null,
      idNumber: data.idNumber && data.idNumber.trim() !== '' ? data.idNumber.trim() : null,
      notes: data.notes && data.notes.trim() !== '' ? data.notes.trim() : null,
      dateOfBirth: data.dateOfBirth || null,
      idType: data.idType || null,
    };
    
    // Remove merchant connection from data since it's handled by Prisma relations
    delete customerData.merchant;
    
    return await prisma.customer.create({
      data: customerData,
      include: {
        merchant: { select: { id: true, name: true } }
      }
    });
  },

  /**
   * Update customer (simplified API)
   */
  update: async (id: number, data: any) => {
    // lastName and phone are now optional (nullable) in schema
    // Convert empty strings to null for optional fields
    const updateData: any = {};
    
    // Only include fields that are being updated
    if (data.firstName !== undefined) updateData.firstName = data.firstName || '';
    if (data.lastName !== undefined) {
      updateData.lastName = data.lastName && data.lastName.trim() !== '' ? data.lastName.trim() : null;
    }
    if (data.phone !== undefined) {
      updateData.phone = data.phone && data.phone.trim() !== '' ? data.phone.trim() : null;
    }
    
    // Optional fields: convert empty strings to null
    if (data.email !== undefined) {
      updateData.email = data.email && data.email.trim() !== '' ? data.email.trim() : null;
    }
    if (data.address !== undefined) {
      updateData.address = data.address && data.address.trim() !== '' ? data.address.trim() : null;
    }
    if (data.city !== undefined) {
      updateData.city = data.city && data.city.trim() !== '' ? data.city.trim() : null;
    }
    if (data.state !== undefined) {
      updateData.state = data.state && data.state.trim() !== '' ? data.state.trim() : null;
    }
    if (data.zipCode !== undefined) {
      updateData.zipCode = data.zipCode && data.zipCode.trim() !== '' ? data.zipCode.trim() : null;
    }
    if (data.country !== undefined) {
      updateData.country = data.country && data.country.trim() !== '' ? data.country.trim() : null;
    }
    if (data.idNumber !== undefined) {
      updateData.idNumber = data.idNumber && data.idNumber.trim() !== '' ? data.idNumber.trim() : null;
    }
    if (data.notes !== undefined) {
      updateData.notes = data.notes && data.notes.trim() !== '' ? data.notes.trim() : null;
    }
    if (data.dateOfBirth !== undefined) {
      updateData.dateOfBirth = data.dateOfBirth || null;
    }
    if (data.idType !== undefined) {
      updateData.idType = data.idType || null;
    }
    if (data.isActive !== undefined) {
      updateData.isActive = data.isActive;
    }
    
    return await prisma.customer.update({
      where: { id },
      data: updateData,
      include: {
        merchant: { select: { id: true, name: true } }
      }
    });
  },

  /**
   * Search customers with pagination (simplified API)
   */
  search: async (filters: any) => {
    const { 
      page = 1, 
      limit = 20, 
      sortBy = 'createdAt', 
      sortOrder = 'desc',
      ...whereFilters 
    } = filters;
    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {};
    
    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;
    if (whereFilters.outletId) where.outletId = whereFilters.outletId;
    // Default to active customers only unless explicitly requesting all
    if (whereFilters.isActive !== undefined) {
      where.isActive = whereFilters.isActive;
    } else {
      where.isActive = true; // Default: only show active customers
    }
    
    // Text search across multiple fields (case-insensitive and diacritics-insensitive)
    if (whereFilters.search) {
      const searchTerm = whereFilters.search.trim();
      const normalizedTerm = removeVietnameseDiacritics(searchTerm);
      
      const searchConditions: any[] = [
        { firstName: { contains: searchTerm, mode: 'insensitive' } },
        { lastName: { contains: searchTerm, mode: 'insensitive' } },
        { email: { contains: searchTerm, mode: 'insensitive' } },
        { phone: { contains: searchTerm, mode: 'insensitive' } }
      ];
      
      // Add normalized search for name fields if different from original
      if (normalizedTerm !== searchTerm) {
        searchConditions.push(
          { firstName: { contains: normalizedTerm, mode: 'insensitive' } },
          { lastName: { contains: normalizedTerm, mode: 'insensitive' } }
        );
      }
      
      where.OR = searchConditions;
    }

    // Specific field filters (case-insensitive and diacritics-insensitive for text fields)
    if (whereFilters.firstName) {
      const normalized = removeVietnameseDiacritics(whereFilters.firstName);
      if (normalized !== whereFilters.firstName) {
        const existingOR = where.OR || [];
        where.OR = [
          ...existingOR,
          { firstName: { contains: whereFilters.firstName, mode: 'insensitive' } },
          { firstName: { contains: normalized, mode: 'insensitive' } }
        ];
      } else {
        where.firstName = { contains: whereFilters.firstName, mode: 'insensitive' };
      }
    }
    if (whereFilters.lastName) {
      const normalized = removeVietnameseDiacritics(whereFilters.lastName);
      if (normalized !== whereFilters.lastName) {
        const existingOR = where.OR || [];
        where.OR = [
          ...existingOR,
          { lastName: { contains: whereFilters.lastName, mode: 'insensitive' } },
          { lastName: { contains: normalized, mode: 'insensitive' } }
        ];
      } else {
        where.lastName = { contains: whereFilters.lastName, mode: 'insensitive' };
      }
    }
    if (whereFilters.email) where.email = { contains: whereFilters.email, mode: 'insensitive' };
    if (whereFilters.phone) where.phone = { contains: whereFilters.phone, mode: 'insensitive' };
    if (whereFilters.city) {
      const normalized = removeVietnameseDiacritics(whereFilters.city);
      if (normalized !== whereFilters.city) {
        const existingOR = where.OR || [];
        where.OR = [
          ...existingOR,
          { city: { contains: whereFilters.city, mode: 'insensitive' } },
          { city: { contains: normalized, mode: 'insensitive' } }
        ];
      } else {
        where.city = { contains: whereFilters.city, mode: 'insensitive' };
      }
    }
    if (whereFilters.state) {
      const normalized = removeVietnameseDiacritics(whereFilters.state);
      if (normalized !== whereFilters.state) {
        const existingOR = where.OR || [];
        where.OR = [
          ...existingOR,
          { state: { contains: whereFilters.state, mode: 'insensitive' } },
          { state: { contains: normalized, mode: 'insensitive' } }
        ];
      } else {
        where.state = { contains: whereFilters.state, mode: 'insensitive' };
      }
    }
    if (whereFilters.country) {
      const normalized = removeVietnameseDiacritics(whereFilters.country);
      if (normalized !== whereFilters.country) {
        const existingOR = where.OR || [];
        where.OR = [
          ...existingOR,
          { country: { contains: whereFilters.country, mode: 'insensitive' } },
          { country: { contains: normalized, mode: 'insensitive' } }
        ];
      } else {
        where.country = { contains: whereFilters.country, mode: 'insensitive' };
      }
    }

    // âœ… Build dynamic orderBy clause
    const orderBy: any = {};
    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email' || sortBy === 'phone') {
      orderBy[sortBy] = sortOrder;
    } else {
      // Default: createdAt
      orderBy.createdAt = sortOrder;
    }

    const [customers, total] = await Promise.all([
      prisma.customer.findMany({
        where,
        include: {
          merchant: { select: { id: true, name: true } },
          _count: {
            select: { orders: true }
          }
        },
        orderBy, // âœ… Dynamic sorting
        skip,
        take: limit
      }),
      prisma.customer.count({ where })
    ]);

    console.log(`ðŸ“Š db.customers.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, customers=${customers.length}`);

    return {
      data: customers,
      total,
      page,
      limit,
      hasMore: skip + limit < total,
      totalPages: Math.ceil(total / limit)
    };
  },

  /**
   * Delete customer (soft delete) (simplified API)
   */
  delete: async (id: number) => {
    return await prisma.customer.update({
      where: { id },
      data: { isActive: false },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        address: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
        merchantId: true
      }
    });
  },

  /**
   * Find first customer matching criteria (simplified API)
   */
  findFirst: async (whereClause: any) => {
    // Handle both direct where clause and object with where property
    const where = whereClause?.where || whereClause || {};
    return await prisma.customer.findFirst({
      where,
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        address: true,
        isActive: true,
        createdAt: true,
        updatedAt: true,
        merchantId: true
      }
    });
  },

  /**
   * Get customer statistics (simplified API)
   */
  getStats: async (whereClause?: any) => {
    // Handle both direct where clause and object with where property
    const where = whereClause?.where || whereClause || {};
    return await prisma.customer.count({ where });
  }
};
