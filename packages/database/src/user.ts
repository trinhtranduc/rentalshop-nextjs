// ============================================================================
// USER FUNCTIONS
// ============================================================================
// This file contains user functions that use integer IDs:
// - Input: id (number)
// - Database: queries by id (auto-incrementing integer)
// - Return: includes id (number)

import { prisma } from './client';
import type { UserCreateInput, UserUpdateInput } from '@rentalshop/types';
import { hashPassword } from '@rentalshop/auth';
import { removeVietnameseDiacritics, ApiError, ErrorCode } from '@rentalshop/utils';

// ============================================================================
// USER LOOKUP FUNCTIONS
// ============================================================================

/**
 * Find user by ID
 */
export async function findUserById(id: number) {
  return await prisma.user.findUnique({
    where: { id },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
}

/**
 * Get user by ID
 */
export async function getUserById(id: number) {
  return await prisma.user.findUnique({
    where: { id },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
}

// ============================================================================
// USER CREATION FUNCTIONS
// ============================================================================

/**
 * Create new user - follows dual ID system
 * Input: ids (numbers), Output: id (number)
 */
export async function createUser(input: UserCreateInput): Promise<any> {
  // Find merchant by id if provided
  let merchantId: number | undefined;
  if (input.merchantId) {
    const merchant = await prisma.merchant.findUnique({
      where: { id: input.merchantId }
    });
    if (!merchant) {
      throw new Error(`Merchant with id ${input.merchantId} not found`);
    }
    merchantId = merchant.id;
  }

  // Find outlet by id if provided
  let outletId: number | undefined;
  if (input.outletId) {
    const outlet = await prisma.outlet.findUnique({
      where: { id: input.outletId }
    });
    if (!outlet) {
      throw new Error(`Outlet with id ${input.outletId} not found`);
    }
    outletId = outlet.id;
  }

  // Create user - let database auto-generate ID to avoid race conditions
  const user = await prisma.user.create({
    data: {
      // ID will be auto-generated by database (autoincrement)
      email: input.email,
      password: input.password,
      firstName: input.firstName,
      lastName: input.lastName || '', // Default to empty string if not provided
      phone: input.phone,
      role: input.role,
      isActive: true,
      merchantId,
      outletId,
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  return user;
}

// ============================================================================
// USER UPDATE FUNCTIONS
// ============================================================================

/**
 * Update user - follows dual ID system
 * Input: id (number), Output: id (number)
 */
export async function updateUser(
  id: number,
  input: UserUpdateInput
): Promise<any> {
  // Find user by id
  const existingUser = await prisma.user.findUnique({
    where: { id }
  });

  if (!existingUser) {
    throw new Error(`User with id ${id} not found`);
  }

  // Update user - only update fields that are provided
  const updateData: any = {};
  if (input.firstName !== undefined) updateData.firstName = input.firstName;
  if (input.lastName !== undefined) updateData.lastName = input.lastName;
  if (input.phone !== undefined) updateData.phone = input.phone;
  // Note: email updates are disabled for security reasons

  const updatedUser = await prisma.user.update({
    where: { id },
    data: updateData,
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
          email: true,
          phone: true,
          address: true,
          city: true,
          state: true,
          zipCode: true,
          country: true,
          businessType: true,
          taxId: true,
          website: true,
          description: true,
          isActive: true,
          planId: true,
          // subscriptionStatus removed - use subscription.status
          totalRevenue: true,
          createdAt: true,
          lastActiveAt: true,
        }
      },
      outlet: {
        select: {
          id: true,
          name: true,
          address: true,
          phone: true,
          description: true,
          isActive: true,
          isDefault: true,
          createdAt: true,
          merchant: {
            select: {
              id: true,
              name: true,
            }
          }
        }
      },
    },
  });

  return updatedUser;
}

// ============================================================================
// USER UTILITY FUNCTIONS
// ============================================================================

/**
 * Helper: Build where clause excluding soft-deleted users
 * Automatically filters out users with deletedAt != null
 */
function buildUserWhere(additionalWhere: any = {}) {
  return {
    ...additionalWhere,
    deletedAt: null, // Only include non-deleted users
  };
}

/**
 * Get users by merchant - follows dual ID system
 * Automatically excludes soft-deleted users
 */
export async function getUsersByMerchant(merchantId: number) {
  // Find merchant by id
  const merchant = await prisma.merchant.findUnique({
    where: { id: merchantId },
    select: { id: true }
  });
  
  if (!merchant) {
    throw new Error(`Merchant with id ${merchantId} not found`);
  }

  return await prisma.user.findMany({
    where: buildUserWhere({ merchantId: merchant.id }),
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
}

/**
 * Get users by outlet - follows dual ID system
 * Automatically excludes soft-deleted users
 */
export async function getUsersByOutlet(outletId: number) {
  // Find outlet by id
  const outlet = await prisma.outlet.findUnique({
    where: { id: outletId },
    select: { id: true }
  });
  
  if (!outlet) {
    throw new Error(`Outlet with id ${outletId} not found`);
  }

  return await prisma.user.findMany({
    where: buildUserWhere({ outletId: outlet.id }),
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  });
}

// ============================================================================
// USER SOFT DELETE FUNCTIONS
// ============================================================================

/**
 * Soft delete user by public ID - follows dual ID system
 * Sets isActive to false and deletedAt to current timestamp
 */
export async function softDeleteUser(id: number): Promise<any> {
  // Find user by id
  const user = await prisma.user.findUnique({
    where: { id },
    select: { id: true, email: true, isActive: true, deletedAt: true }
  });

  if (!user) {
    throw new Error(`User with id ${id} not found`);
  }

  if (user.deletedAt) {
    throw new Error(`User with id ${id} is already deleted`);
  }

  // Soft delete the user
  const deletedUser = await prisma.user.update({
    where: { id: user.id },
    data: {
      isActive: false,
      deletedAt: new Date(),
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  return deletedUser;
}

/**
 * Restore soft deleted user by public ID - follows dual ID system
 * Sets isActive to true and clears deletedAt
 */
export async function restoreUser(id: number): Promise<any> {
  // Find user by id
  const user = await prisma.user.findUnique({
    where: { id },
    select: { id: true, email: true, isActive: true, deletedAt: true }
  });

  if (!user) {
    throw new Error(`User with id ${id} not found`);
  }

  if (!user.deletedAt) {
    throw new Error(`User with id ${id} is not deleted`);
  }

  // Restore the user
  const restoredUser = await prisma.user.update({
    where: { id: user.id },
    data: {
      isActive: true,
      deletedAt: null,
    },
    include: {
      merchant: {
        select: {
          id: true,
          name: true,
        },
      },
      outlet: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });

  return restoredUser;
}

// ============================================================================
// SIMPLIFIED API FUNCTIONS (for db object)
// ============================================================================

export const simplifiedUsers = {
  /**
   * Find user by ID (simplified API)
   */
  findById: async (id: number) => {
    return await prisma.user.findUnique({
      where: { id },
      include: {
        merchant: { 
          select: { 
            id: true, 
            name: true,
            email: true,
            phone: true,
            address: true,
            city: true,
            state: true,
            zipCode: true,
            country: true,
            businessType: true,
            pricingType: true,
            taxId: true,
            website: true,
            description: true,
            tenantKey: true, // Include tenantKey for referral code
            isActive: true,
            planId: true,
            // subscriptionStatus removed - use subscription.status
            totalRevenue: true,
            createdAt: true,
            lastActiveAt: true
          } 
        },
        outlet: { 
          select: { 
            id: true, 
            name: true,
            address: true,
            phone: true,
            description: true,
            isActive: true,
            isDefault: true,
            createdAt: true,
            merchant: {
              select: {
                id: true,
                name: true,
              }
            }
          } 
        }
      }
    });
  },

  /**
   * Find user by email (simplified API)
   */
  findByEmail: async (email: string) => {
    return await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        password: true,
        firstName: true,
        lastName: true,
        phone: true,
        role: true,
        isActive: true,
        emailVerified: true,
        emailVerifiedAt: true,
        passwordChangedAt: true, // âœ… Include passwordChangedAt for token validation
        createdAt: true,
        updatedAt: true,
        merchantId: true,
        outletId: true,
        deletedAt: true,
        merchant: { select: { id: true, name: true } },
        outlet: { select: { id: true, name: true } }
      }
    });
  },

  /**
   * Find first user matching criteria (simplified API)
   */
  findFirst: async (where: any) => {
    return await prisma.user.findFirst({
      where,
      include: {
        merchant: { select: { id: true, name: true } },
        outlet: { select: { id: true, name: true } }
      }
    });
  },

  /**
   * Create new user (simplified API)
   */
  create: async (data: any) => {
    try {
      console.log('ðŸ” simplifiedUsers.create called with data:', data);
      
      // Password should already be hashed when passed to this function
      const userData = { ...data };

      // Validate merchantId exists if provided
      if (userData.merchantId && typeof userData.merchantId === 'number') {
        const merchant = await prisma.merchant.findUnique({
          where: { id: userData.merchantId },
          select: { id: true, name: true }
        });
        
        if (!merchant) {
          throw new Error(`Merchant with id ${userData.merchantId} not found`);
        }
        
        console.log('âœ… Merchant found:', merchant);
        // Keep the number ID as-is since schema uses Int IDs
      }

      // Validate outletId exists if provided
      if (userData.outletId && typeof userData.outletId === 'number') {
        const outlet = await prisma.outlet.findUnique({
          where: { id: userData.outletId },
          select: { id: true, name: true, merchantId: true }
        });
        
        if (!outlet) {
          throw new Error(`Outlet with id ${userData.outletId} not found`);
        }
        
        // Validate outlet belongs to the same merchant
        if (userData.merchantId && outlet.merchantId !== userData.merchantId) {
          throw new Error(`Outlet ${userData.outletId} does not belong to merchant ${userData.merchantId}`);
        }
        
        console.log('âœ… Outlet found:', outlet);
        // Keep the number ID as-is since schema uses Int IDs
      }

      // Check for duplicate email globally (toÃ n há»‡ thá»‘ng)
      // Email must be unique across the entire system, not just within outlet/merchant
      if (userData.email) {
        const existingEmail = await prisma.user.findUnique({
          where: { email: userData.email },
          select: { 
            id: true, 
            email: true,
            merchantId: true,
            outletId: true,
            merchant: { select: { name: true } },
            outlet: { select: { name: true } }
          }
        });
        
        if (existingEmail) {
          // Provide detailed error message if email exists in same outlet/merchant
          if (userData.outletId && existingEmail.outletId === userData.outletId) {
            console.log(`âŒ Email ${userData.email} already exists in outlet ${userData.outletId}`);
          } else if (userData.merchantId && existingEmail.merchantId === userData.merchantId) {
            console.log(`âŒ Email ${userData.email} already exists in merchant ${userData.merchantId}`);
          } else {
            console.log(`âŒ Email ${userData.email} already exists in the system`);
          }
          throw new ApiError(ErrorCode.EMAIL_EXISTS);
        }
      }

      // Check for duplicate phone within merchant
      if (userData.phone && userData.merchantId) {
        const existingPhone = await prisma.user.findFirst({
          where: { 
            phone: userData.phone,
            merchantId: userData.merchantId
          },
          select: { id: true, phone: true, merchantId: true }
        });
        
        if (existingPhone) {
          throw new ApiError(ErrorCode.PHONE_EXISTS);
        }
      }

      // Remove id from userData if present - let database auto-generate to avoid race conditions
      const { id: _, ...userDataWithoutId } = userData;

      const user = await prisma.user.create({
        data: userDataWithoutId,
        include: {
          merchant: { 
            select: { 
              id: true, 
              name: true,
              email: true,
              phone: true,
              address: true,
              city: true,
              state: true,
              zipCode: true,
              country: true,
              businessType: true,
              taxId: true,
              website: true,
              description: true,
              isActive: true,
              planId: true,
              // subscriptionStatus removed - use subscription.status
              totalRevenue: true,
              createdAt: true,
              lastActiveAt: true
            } 
          },
          outlet: { 
            select: { 
              id: true, 
              name: true,
              address: true,
              phone: true,
              description: true,
              isActive: true,
              isDefault: true,
              createdAt: true,
              merchant: {
                select: {
                  id: true,
                  name: true,
                }
              }
            } 
          }
        }
      });
      
      console.log('âœ… User created successfully:', user);
      return user;
    } catch (error) {
      console.error('âŒ Error in simplifiedUsers.create:', error);
      throw error;
    }
  },

  /**
   * Update user (simplified API)
   */
  update: async (id: number, data: any) => {
    return await prisma.user.update({
      where: { id },
      data,
      include: {
        merchant: { select: { id: true, name: true } },
        outlet: { select: { id: true, name: true } }
      }
    });
  },

  /**
   * Delete user (hard delete) (simplified API)
   * Hard delete removes user from database permanently.
   * Note: If user has created orders, the orders.createdById will remain but user will be deleted.
   * This is acceptable as orders preserve the ID reference even if user no longer exists.
   */
  delete: async (id: number) => {
    // Check if user has created any orders
    const orderCount = await prisma.order.count({
      where: { createdById: id }
    });

    if (orderCount > 0) {
      console.log(`âš ï¸ Warning: User ${id} has created ${orderCount} orders. User will be hard deleted but orders.createdById will remain.`);
    }

    // Hard delete the user
    // Note: UserSession will be cascade deleted due to onDelete: Cascade in schema
    // Orders.createdById will remain with the deleted user's ID (historical reference)
    return await prisma.user.delete({
      where: { id },
      include: {
        merchant: { select: { id: true, name: true } },
        outlet: { select: { id: true, name: true } }
      }
    });
  },

  /**
   * Search users with simple filters (simplified API)
   */
  search: async (filters: any) => {
    const { 
      page = 1, 
      limit = 20, 
      sortBy = 'createdAt', 
      sortOrder = 'desc',
      ...whereFilters 
    } = filters;
    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {};
    
    // Automatically exclude soft-deleted users (deletedAt = null)
    where.deletedAt = null;
    
    if (whereFilters.merchantId) where.merchantId = whereFilters.merchantId;
    if (whereFilters.outletId) where.outletId = whereFilters.outletId;
    if (whereFilters.isActive !== undefined) where.isActive = whereFilters.isActive;
    
    // Handle role filtering - roles array has priority over single role
    if (whereFilters.roles && Array.isArray(whereFilters.roles)) {
      where.role = { in: whereFilters.roles };
    } else if (whereFilters.role) {
      where.role = whereFilters.role;
    }
    
    // Text search (case-insensitive and diacritics-insensitive)
    if (whereFilters.search) {
      const searchTerm = whereFilters.search.trim();
      // Normalize Vietnamese text to support search without diacritics
      const normalizedTerm = removeVietnameseDiacritics(searchTerm);
      
      // Search with both original and normalized terms to support diacritics-insensitive search
      const searchConditions: any[] = [
        { firstName: { contains: searchTerm, mode: 'insensitive' } },
        { lastName: { contains: searchTerm, mode: 'insensitive' } },
        { email: { contains: searchTerm, mode: 'insensitive' } }
      ];
      
      // Add normalized search if different from original
      if (normalizedTerm !== searchTerm) {
        searchConditions.push(
          { firstName: { contains: normalizedTerm, mode: 'insensitive' } },
          { lastName: { contains: normalizedTerm, mode: 'insensitive' } }
        );
      }
      
      where.OR = searchConditions;
    }

    // âœ… Build dynamic orderBy clause
    const orderBy: any = {};
    if (sortBy === 'firstName' || sortBy === 'lastName' || sortBy === 'email') {
      orderBy[sortBy] = sortOrder;
    } else {
      // Default: createdAt
      orderBy.createdAt = sortOrder;
    }

    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where,
        include: {
          merchant: { select: { id: true, name: true } },
          outlet: { select: { id: true, name: true } }
        },
        orderBy, // âœ… Dynamic sorting
        skip,
        take: limit
      }),
      prisma.user.count({ where })
    ]);

    console.log(`ðŸ“Š db.users.search: page=${page}, skip=${skip}, limit=${limit}, total=${total}, users=${users.length}`);

    return {
      data: users,
      total,
      page,
      limit,
      hasMore: skip + limit < total,
      totalPages: Math.ceil(total / limit)
    };
  },

  count: async (options?: { where?: any }) => {
    const baseWhere = options?.where || {};
    // Automatically exclude soft-deleted users
    const where = buildUserWhere(baseWhere);
    return await prisma.user.count({ where });
  },

  /**
   * Get user statistics (simplified API)
   * Automatically excludes soft-deleted users
   */
  getStats: async (whereClause?: any) => {
    // Handle both direct where clause and object with where property
    const baseWhere = whereClause?.where || whereClause || {};
    // Automatically exclude soft-deleted users
    const where = buildUserWhere(baseWhere);
    return await prisma.user.count({ where });
  }
};
