{"version":3,"sources":["../src/index.ts","../src/hooks/useAuth.ts","../src/hooks/useAuthErrorHandler.ts","../src/hooks/useCanPerform.ts","../src/hooks/useSubscriptionStatusInfo.ts","../src/hooks/useCurrency.tsx","../src/hooks/useCustomersData.ts","../src/hooks/useOrdersData.ts","../src/hooks/useOutletsData.ts","../src/hooks/useCategoriesData.ts","../src/hooks/usePagination.ts","../src/hooks/useProductAvailability.ts","../src/hooks/useProductsData.ts","../src/hooks/useSubscriptionError.ts","../src/hooks/useThrottledSearch.ts","../src/hooks/useToast.ts","../src/hooks/useUserRole.ts","../src/hooks/useUsersData.ts"],"sourcesContent":["// ============================================================================\n// HOOKS PACKAGE - Main Exports\n// ============================================================================\n\n// Export all business logic hooks\nexport * from './hooks/useAuth';\nexport * from './hooks/useAuthErrorHandler';\nexport * from './hooks/useCanPerform';\nexport * from './hooks/useCurrency';\nexport * from './hooks/useCustomersData';\nexport * from './hooks/useOrdersData';\nexport * from './hooks/useOutletsData';\nexport * from './hooks/useCategoriesData';\nexport * from './hooks/usePagination';\nexport * from './hooks/useProductAvailability';\nexport * from './hooks/useProductsData';\nexport * from './hooks/useSubscriptionError';\nexport * from './hooks/useSubscriptionStatusInfo';\nexport * from './hooks/useThrottledSearch';\nexport * from './hooks/useToast';\nexport * from './hooks/useUserRole';\nexport * from './hooks/useUsersData';\n","'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { getAuthToken, getStoredUser, clearAuthData, storeAuthData } from '@rentalshop/utils';\nimport type { User } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface AuthState {\n  user: User | null;\n  loading: boolean;\n  error: string | null;\n}\n\nexport interface LoginResponse {\n  success: boolean;\n  data: {\n    token: string;\n    user: User;\n  };\n  message?: string;\n}\n\n// ============================================================================\n// USE AUTH HOOK\n// ============================================================================\n\nexport function useAuth() {\n  const [state, setState] = useState<AuthState>({\n    user: null,\n    loading: true,\n    error: null,\n  });\n\n  // ============================================================================\n  // AUTH FUNCTIONS\n  // ============================================================================\n\n  const login = useCallback(async (email: string, password: string): Promise<boolean> => {\n    try {\n      setState(prev => ({ ...prev, loading: true }));\n\n      // Use centralized API URL configuration\n      const { apiUrls } = await import('@rentalshop/utils');\n      const response = await fetch(apiUrls.auth.login, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ email, password }),\n      });\n\n      // Handle subscription errors (402 Payment Required)\n      if (response.status === 402) {\n        const errorData = await response.json();\n        setState(prev => ({ \n          ...prev, \n          error: errorData.message || 'Subscription issue detected',\n          loading: false \n        }));\n        return false;\n      }\n\n      // Handle authentication errors (401 Unauthorized)\n      if (response.status === 401) {\n        const errorData = await response.json();\n        setState(prev => ({ \n          ...prev, \n          error: errorData.message || 'Invalid credentials',\n          loading: false \n        }));\n        return false;\n      }\n\n      const data: LoginResponse = await response.json();\n\n      if (data.success && data.data?.token) {\n        // Store auth data using consolidated function\n        storeAuthData(data.data.token, data.data.user);\n        \n        setState(prev => ({ \n          ...prev, \n          user: data.data.user, \n          loading: false \n        }));\n        return true;\n      } else {\n        setState(prev => ({ \n          ...prev, \n          error: data.message || 'Login failed',\n          loading: false \n        }));\n        return false;\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Login failed';\n      setState(prev => ({ \n        ...prev, \n        error: errorMessage,\n        loading: false \n      }));\n      return false;\n    }\n  }, []);\n\n  const logout = useCallback(() => {\n    // Use consolidated clearAuthData function\n    clearAuthData();\n    setState({\n      user: null,\n      loading: false,\n      error: null,\n    });\n    // window.location.href = '/login';\n  }, []);\n\n  const clearError = useCallback(() => {\n    setState(prev => ({ ...prev, error: null }));\n  }, []);\n\n  const refreshUser = useCallback(async () => {\n    try {\n      // Use consolidated getAuthToken function\n      const token = getAuthToken();\n      console.log('🔄 refreshUser called, token exists:', !!token);\n      \n      if (!token) {\n        console.log('❌ No token found, setting user to null');\n        setState(prev => ({ ...prev, user: null, loading: false }));\n        return;\n      }\n\n      console.log('🌐 Fetching user profile from API...');\n      // Use centralized API URL and authenticatedFetch\n      const { apiUrls, authenticatedFetch } = await import('@rentalshop/utils');\n      const response = await authenticatedFetch(apiUrls.settings.user);\n\n      console.log('📥 Profile API response:', {\n        ok: response.ok,\n        status: response.status,\n        statusText: response.statusText\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        console.log('📊 Profile API data:', data);\n        \n        if (data.success && data.data) {\n          console.log('✅ Setting user data:', data.data);\n          setState(prev => ({ \n            ...prev, \n            user: data.data,\n            loading: false \n          }));\n          // Don't set localStorage here - it's already handled by storeAuthData\n        } else {\n          console.error('❌ API returned success:false:', data);\n          throw new Error('Failed to refresh user');\n        }\n      } else if (response.status === 402) {\n        // Handle subscription errors (402 Payment Required)\n        try {\n          const errorData = await response.clone().json();\n          console.log('⚠️ Subscription error detected, not logging out');\n          // Don't logout for subscription errors - just show error\n          setState(prev => ({ \n            ...prev, \n            loading: false, \n            error: errorData.message || 'Subscription issue detected' \n          }));\n          return;\n        } catch (parseError) {\n          console.log('🔍 Could not parse 402 error response');\n          setState(prev => ({ \n            ...prev, \n            loading: false, \n            error: 'Subscription issue detected' \n          }));\n          return;\n        }\n      } else if (response.status === 401) {\n        // Handle authentication errors (401 Unauthorized)\n        console.log('🔒 Token expired, logging out and redirecting to login');\n        // Token expired or invalid - logout will clear data\n        logout();\n        // Redirect to login page\n        if (typeof window !== 'undefined') {\n          window.location.href = '/login';\n        }\n      } else {\n        console.error('❌ API error:', response.status, response.statusText);\n        // Don't clear auth data on API errors - keep existing user data\n        console.log('⚠️ API error during refresh, but keeping existing user data');\n        setState(prev => ({ ...prev, loading: false }));\n        // Only clear auth data for critical errors (500, 503, etc.)\n        if (response.status >= 500) {\n          console.log('🔥 Server error, keeping user data but not clearing auth');\n        }\n      }\n    } catch (err) {\n      console.error('💥 Error refreshing user:', err);\n      // Don't clear auth data immediately on refresh error\n      // Keep existing user data and just set loading to false\n      console.log('⚠️ Refresh failed, but keeping existing user data');\n      setState(prev => ({ ...prev, loading: false }));\n      // Only clear auth data if it's a network error or critical failure\n      if (err instanceof Error && (\n        err.message.includes('Failed to fetch') || \n        err.message.includes('Network error') ||\n        err.message.includes('fetch')\n      )) {\n        console.log('🌐 Network error during refresh, keeping user data');\n      }\n    }\n  }, [logout]);\n\n  // ============================================================================\n  // EFFECTS\n  // ============================================================================\n\n  useEffect(() => {\n    // Check for existing auth on mount using consolidated approach\n    const token = getAuthToken();\n    const storedUser = getStoredUser();\n\n    console.log('🔍 useAuth useEffect - localStorage check:', {\n      hasToken: !!token,\n      hasStoredUser: !!storedUser,\n      tokenLength: token?.length,\n      tokenPreview: token ? token.substring(0, 20) + '...' : 'null',\n      storedUserPreview: storedUser ? JSON.stringify(storedUser).substring(0, 100) + '...' : 'null',\n      storedUserFirstName: storedUser?.firstName,\n      storedUserLastName: storedUser?.lastName,\n      storedUserPhone: storedUser?.phone\n    });\n\n    if (token && storedUser) {\n      console.log('✅ Found stored user data:', storedUser);\n      setState(prev => ({ ...prev, user: {\n        ...storedUser,\n        id: storedUser.id, // Keep as number\n      } as User, loading: false }));\n      \n      // Only refresh user data if we don't have complete user info\n      // This prevents unnecessary API calls that might fail\n      if (!storedUser.merchantId && !storedUser.outletId) {\n        console.log('🔄 User data incomplete (missing merchant/outlet IDs) - refreshing from API...');\n        // Don't set loading to true here - keep user visible while refreshing\n        refreshUser();\n      } else if (!storedUser.firstName || !storedUser.lastName) {\n        console.log('🔄 User data incomplete (missing firstName/lastName) - refreshing from API...');\n        // Don't set loading to true here - keep user visible while refreshing\n        refreshUser();\n      } else {\n        console.log('✅ User data complete - no need to refresh');\n      }\n    } else if (token && !storedUser) {\n      console.log('🔄 Token exists but no user data - refreshing from API...');\n      // We have a token but no user data, try to refresh from API\n      refreshUser();\n    } else {\n      console.log('❌ No auth data found - user not authenticated');\n      setState(prev => ({ ...prev, user: null, loading: false }));\n    }\n  }, [refreshUser]);\n\n  // ============================================================================\n  // MODERN PATTERN: Automatic Token Refresh\n  // ============================================================================\n  \n  useEffect(() => {\n    // Modern pattern: Auto-refresh tokens before they expire\n    const checkTokenExpiry = () => {\n      const token = getAuthToken();\n      if (!token) return;\n\n      try {\n        const parts = token.split('.');\n        if (parts.length === 3) {\n          const payload = JSON.parse(atob(parts[1]));\n          const now = Math.floor(Date.now() / 1000);\n          const timeUntilExpiry = payload.exp - now;\n          \n          // Refresh token if it expires in less than 5 minutes\n          if (timeUntilExpiry < 300 && timeUntilExpiry > 0) {\n            console.log('🔄 Token expires soon, refreshing...');\n            refreshUser();\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to check token expiry:', error);\n      }\n    };\n\n    // Check every minute\n    const interval = setInterval(checkTokenExpiry, 60000);\n    \n    // Initial check\n    checkTokenExpiry();\n\n    return () => clearInterval(interval);\n  }, [refreshUser]);\n\n  // ============================================================================\n  // RETURN VALUES\n  // ============================================================================\n\n  return {\n    user: state.user,\n    loading: state.loading,\n    error: state.error,\n    login,\n    logout,\n    refreshUser,\n    clearError,\n  };\n}\n","import { useCallback } from 'react';\nimport { clearAuthData } from '@rentalshop/utils';\n\n/**\n * Custom hook for handling authentication errors\n * Automatically logs out user and redirects to login on auth failures\n */\nexport const useAuthErrorHandler = () => {\n  const handleAuthError = useCallback((error: any) => {\n    console.error('Authentication error detected:', error);\n    \n    // Check if it's an authentication-related error\n    if (\n      error?.message?.includes('Authentication required') ||\n      error?.message?.includes('Unauthorized') ||\n      error?.message?.includes('Invalid token') ||\n      error?.message?.includes('Token expired') ||\n      error?.status === 401\n    ) {\n      console.log('🔄 Authentication error detected, logging out user');\n      \n      // Clear auth data using centralized function\n      clearAuthData();\n      \n      // Redirect to login\n      if (typeof window !== 'undefined') {\n        // window.location.href = '/login';\n      }\n    }\n  }, []);\n\n  return { handleAuthError };\n};\n","\"use client\"\n\nimport { useCallback } from 'react';\nimport { useAuth } from './useAuth';\nimport { useSubscriptionStatusInfo } from './useSubscriptionStatusInfo';\n\n// ============================================================================\n// CAN PERFORM ACTION HOOK\n// ============================================================================\n\nexport type ActionType = \n  | 'create_order'\n  | 'edit_order'\n  | 'delete_order'\n  | 'create_customer'\n  | 'edit_customer'\n  | 'delete_customer'\n  | 'create_product'\n  | 'edit_product'\n  | 'delete_product'\n  | 'view_analytics'\n  | 'manage_users'\n  | 'manage_settings'\n  | 'export_data'\n  | 'bulk_operations'\n  | string; // Allow custom actions\n\nexport interface ActionPermission {\n  action: ActionType;\n  requiresSubscription?: boolean;\n  requiredFeatures?: string[];\n  requiredRole?: string[];\n  customCheck?: (user: any, subscription: any) => boolean;\n}\n\nexport function useCanPerform(action: ActionType): boolean {\n  const { user } = useAuth();\n  const { hasActiveSubscription, isExpired, canAccessFeature } = useSubscriptionStatusInfo();\n\n  const checkPermission = useCallback((action: ActionType): boolean => {\n    // If no user, deny all actions\n    if (!user) {\n      return false;\n    }\n\n    // Define action permissions\n    const actionPermissions: Record<ActionType, ActionPermission> = {\n      // Order actions\n      'create_order': {\n        action: 'create_order',\n        requiresSubscription: true,\n        requiredFeatures: ['orders']\n      },\n      'edit_order': {\n        action: 'edit_order',\n        requiresSubscription: true,\n        requiredFeatures: ['orders']\n      },\n      'delete_order': {\n        action: 'delete_order',\n        requiresSubscription: true,\n        requiredFeatures: ['orders']\n      },\n      \n      // Customer actions\n      'create_customer': {\n        action: 'create_customer',\n        requiresSubscription: true,\n        requiredFeatures: ['customers']\n      },\n      'edit_customer': {\n        action: 'edit_customer',\n        requiresSubscription: true,\n        requiredFeatures: ['customers']\n      },\n      'delete_customer': {\n        action: 'delete_customer',\n        requiresSubscription: true,\n        requiredFeatures: ['customers']\n      },\n      \n      // Product actions\n      'create_product': {\n        action: 'create_product',\n        requiresSubscription: true,\n        requiredFeatures: ['products']\n      },\n      'edit_product': {\n        action: 'edit_product',\n        requiresSubscription: true,\n        requiredFeatures: ['products']\n      },\n      'delete_product': {\n        action: 'delete_product',\n        requiresSubscription: true,\n        requiredFeatures: ['products']\n      },\n      \n      // Analytics and reporting\n      'view_analytics': {\n        action: 'view_analytics',\n        requiresSubscription: true,\n        requiredFeatures: ['analytics']\n      },\n      'export_data': {\n        action: 'export_data',\n        requiresSubscription: true,\n        requiredFeatures: ['analytics', 'export']\n      },\n      \n      // User management\n      'manage_users': {\n        action: 'manage_users',\n        requiresSubscription: true,\n        requiredRole: ['ADMIN', 'MERCHANT', 'OUTLET_ADMIN']\n      },\n      \n      // Settings\n      'manage_settings': {\n        action: 'manage_settings',\n        requiresSubscription: true,\n        requiredRole: ['ADMIN', 'MERCHANT']\n      },\n      \n      // Bulk operations\n      'bulk_operations': {\n        action: 'bulk_operations',\n        requiresSubscription: true,\n        requiredFeatures: ['bulk_operations']\n      }\n    };\n\n    const permission = actionPermissions[action];\n    \n    // If no specific permission defined, allow for now (backward compatibility)\n    if (!permission) {\n      return true;\n    }\n\n    // Check subscription requirements\n    if (permission.requiresSubscription) {\n      if (!hasActiveSubscription || isExpired) {\n        return false;\n      }\n    }\n\n    // Check required features\n    if (permission.requiredFeatures) {\n      for (const feature of permission.requiredFeatures) {\n        if (!canAccessFeature(feature)) {\n          return false;\n        }\n      }\n    }\n\n    // Check required roles\n    if (permission.requiredRole) {\n      if (!permission.requiredRole.includes(user.role)) {\n        return false;\n      }\n    }\n\n    // Custom check\n    if (permission.customCheck) {\n      return permission.customCheck(user, { hasActiveSubscription, isExpired });\n    }\n\n    return true;\n  }, [user, hasActiveSubscription, isExpired, canAccessFeature]);\n\n  return checkPermission(action);\n}\n","\"use client\"\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from './useAuth';\n\n// ============================================================================\n// SUBSCRIPTION STATUS INFO HOOK\n// ============================================================================\n\nexport interface SubscriptionStatusInfo {\n  // Original interface\n  loading: boolean;\n  hasActiveSubscription: boolean;\n  isExpired: boolean;\n  isExpiringSoon: boolean;\n  daysUntilExpiry: number | null;\n  subscriptionType: string | null;\n  canAccessFeature: (feature: string) => boolean;\n  refreshStatus: () => Promise<void>;\n  \n  // Extended interface for UI components\n  hasSubscription: boolean;\n  subscription: any;\n  status: string;\n  isTrial: boolean;\n  isActive: boolean;\n  planName: string;\n  error: string | null;\n  \n  // Additional properties for other components\n  statusMessage: string;\n  statusColor: string;\n  hasAccess: boolean;\n  accessLevel: string;\n  requiresPayment: boolean;\n  upgradeRequired: boolean;\n  gracePeriodEnds: Date | null;\n  canExportData: boolean;\n  isRestricted: boolean;\n  isReadOnly: boolean;\n  isLimited: boolean;\n  isDenied: boolean;\n}\n\nexport interface UseSubscriptionStatusInfoOptions {\n  checkInterval?: number; // Check interval in milliseconds (default: 5 minutes)\n}\n\nexport function useSubscriptionStatusInfo(\n  options: UseSubscriptionStatusInfoOptions = {}\n): SubscriptionStatusInfo {\n  const { checkInterval = 5 * 60 * 1000 } = options; // Default 5 minutes\n  const { user } = useAuth();\n  \n  const [loading, setLoading] = useState(true);\n  const [hasActiveSubscription, setHasActiveSubscription] = useState(false);\n  const [isExpired, setIsExpired] = useState(false);\n  const [isExpiringSoon, setIsExpiringSoon] = useState(false);\n  const [daysUntilExpiry, setDaysUntilExpiry] = useState<number | null>(null);\n  const [subscriptionType, setSubscriptionType] = useState<string | null>(null);\n  \n  // Extended state for UI components\n  const [hasSubscription, setHasSubscription] = useState(false);\n  const [subscription, setSubscription] = useState<any>(null);\n  const [status, setStatus] = useState<string>('');\n  const [isTrial, setIsTrial] = useState(false);\n  const [isActive, setIsActive] = useState(false);\n  const [planName, setPlanName] = useState<string>('');\n  const [error, setError] = useState<string | null>(null);\n\n  // Fetch subscription status from API\n  const fetchSubscriptionStatus = useCallback(async () => {\n    if (!user) {\n      setLoading(false);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      \n      // Import subscriptionsApi dynamically to avoid circular dependencies\n      const { subscriptionsApi } = await import('@rentalshop/utils');\n      const response = await subscriptionsApi.getCurrentUserSubscriptionStatus();\n      \n      if (response.success && response.data) {\n        const data = response.data;\n        \n        // ============================================================================\n        // MAP NEW FLAT RESPONSE STRUCTURE\n        // ============================================================================\n        // Response structure:\n        // {\n        //   status: \"CANCELED\" | \"EXPIRED\" | \"PAST_DUE\" | \"PAUSED\" | \"TRIAL\" | \"ACTIVE\",\n        //   statusReason: \"Canceled on 10/7/2025\",\n        //   hasAccess: false,\n        //   daysRemaining: 31,\n        //   isExpiringSoon: false,\n        //   planName: \"Basic\",\n        //   ...other flat fields\n        // }\n        \n        // Map computed status flags from API\n        const computedStatus = data.status || 'UNKNOWN'; // CANCELED | EXPIRED | PAST_DUE | PAUSED | TRIAL | ACTIVE\n        const apiHasAccess = data.hasAccess ?? false;\n        const apiDaysRemaining = data.daysRemaining ?? null;\n        const apiIsExpiringSoon = data.isExpiringSoon ?? false;\n        \n        // Derive boolean flags from computed status\n        const isActive = computedStatus === 'ACTIVE';\n        const isExpired = computedStatus === 'EXPIRED';\n        const isTrial = computedStatus === 'TRIAL';\n        const isCanceled = computedStatus === 'CANCELED';\n        const isPastDue = computedStatus === 'PAST_DUE';\n        const isPaused = computedStatus === 'PAUSED';\n        \n        // Determine if subscription is active for access (ACTIVE or TRIAL)\n        const hasActive = apiHasAccess; // API already calculated this\n        \n        // Set original state (for backward compatibility)\n        setHasActiveSubscription(hasActive);\n        setIsExpired(isExpired);\n        setIsExpiringSoon(apiIsExpiringSoon);\n        setDaysUntilExpiry(apiDaysRemaining);\n        setSubscriptionType(data.planName || computedStatus);\n        \n        // Set extended state for UI components\n        setHasSubscription(true);\n        setSubscription(data); // Store full response data\n        setStatus(computedStatus);\n        setIsTrial(isTrial);\n        setIsActive(isActive);\n        setPlanName(data.planName || 'Unknown Plan');\n        setError(null);\n        \n        console.log('✅ Subscription status mapped:', {\n          computedStatus,\n          hasAccess: apiHasAccess,\n          daysRemaining: apiDaysRemaining,\n          isExpiringSoon: apiIsExpiringSoon,\n          statusReason: data.statusReason\n        });\n        \n      } else {\n        // No subscription found\n        setHasActiveSubscription(false);\n        setIsExpired(true);\n        setIsExpiringSoon(false);\n        setDaysUntilExpiry(null);\n        setSubscriptionType(null);\n        \n        // Set extended state for UI components\n        setHasSubscription(false);\n        setSubscription(null);\n        setStatus('NO_SUBSCRIPTION');\n        setIsTrial(false);\n        setIsActive(false);\n        setPlanName('');\n        setError('No subscription found');\n      }\n      \n    } catch (error) {\n      console.error('Error fetching subscription status:', error);\n      setHasActiveSubscription(false);\n      setIsExpired(true);\n      setIsExpiringSoon(false);\n      setDaysUntilExpiry(null);\n      setSubscriptionType(null);\n      \n      // Set extended state for UI components\n      setHasSubscription(false);\n      setSubscription(null);\n      setStatus('ERROR');\n      setIsTrial(false);\n      setIsActive(false);\n      setPlanName('');\n      setError(error instanceof Error ? error.message : 'Failed to fetch subscription');\n    } finally {\n      setLoading(false);\n    }\n  }, [user]);\n\n  // Check if user can access a specific feature\n  const canAccessFeature = useCallback((feature: string): boolean => {\n    if (!hasActiveSubscription || isExpired) {\n      return false;\n    }\n    \n    // TODO: Replace with actual feature checking logic\n    // For now, allow all features if subscription is active\n    return true;\n  }, [hasActiveSubscription, isExpired]);\n\n  // Refresh subscription status\n  const refreshStatus = useCallback(async () => {\n    await fetchSubscriptionStatus();\n  }, [fetchSubscriptionStatus]);\n\n  // Initial fetch\n  useEffect(() => {\n    fetchSubscriptionStatus();\n  }, [fetchSubscriptionStatus]);\n\n  // Set up interval for periodic checks\n  useEffect(() => {\n    if (!user) return;\n\n    const interval = setInterval(fetchSubscriptionStatus, checkInterval);\n    return () => clearInterval(interval);\n  }, [user, fetchSubscriptionStatus, checkInterval]);\n\n  // Calculate additional properties for other components\n  // Use subscription.statusReason if available (from API), otherwise fallback to computed message\n  const statusMessage = subscription?.statusReason || \n                       (isExpired ? 'Subscription expired' : \n                        isExpiringSoon ? `Expires in ${daysUntilExpiry} days` :\n                        isTrial ? `Trial (${daysUntilExpiry} days left)` :\n                        isActive ? 'Active subscription' : 'No subscription');\n  \n  // Map status to color\n  const statusColor = status === 'EXPIRED' ? 'red' :\n                     status === 'CANCELED' ? 'red' :\n                     status === 'PAST_DUE' ? 'orange' :\n                     status === 'PAUSED' ? 'yellow' :\n                     isExpiringSoon ? 'orange' :\n                     status === 'TRIAL' ? 'yellow' :\n                     status === 'ACTIVE' ? 'green' : 'gray';\n  \n  // Use hasAccess from API (already calculated there)\n  const hasAccess = subscription?.hasAccess ?? (hasActiveSubscription && !isExpired);\n  \n  const accessLevel = status === 'EXPIRED' || status === 'CANCELED' ? 'denied' : \n                     status === 'PAST_DUE' ? 'readonly' :\n                     status === 'PAUSED' ? 'readonly' :\n                     status === 'TRIAL' ? 'limited' :\n                     status === 'ACTIVE' ? 'full' : 'denied';\n  \n  const requiresPayment = status === 'EXPIRED' || status === 'PAST_DUE' || isExpiringSoon;\n  const upgradeRequired = status === 'EXPIRED' || status === 'CANCELED';\n  const gracePeriodEnds = isExpiringSoon && daysUntilExpiry ? new Date(Date.now() + daysUntilExpiry * 24 * 60 * 60 * 1000) : null;\n  const canExportData = hasAccess;\n  const isRestricted = !hasAccess || status === 'TRIAL' || status === 'PAUSED';\n  const isReadOnly = status === 'EXPIRED' || status === 'PAST_DUE' || status === 'PAUSED';\n  const isLimited = status === 'TRIAL';\n  const isDenied = status === 'EXPIRED' || status === 'CANCELED' || !hasActiveSubscription;\n\n  return {\n    // Original interface\n    loading,\n    hasActiveSubscription,\n    isExpired,\n    isExpiringSoon,\n    daysUntilExpiry,\n    subscriptionType,\n    canAccessFeature,\n    refreshStatus,\n    \n    // Extended interface for UI components\n    hasSubscription,\n    subscription,\n    status,\n    isTrial,\n    isActive,\n    planName,\n    error,\n    \n    // Additional properties for other components\n    statusMessage,\n    statusColor,\n    hasAccess,\n    accessLevel,\n    requiresPayment,\n    upgradeRequired,\n    gracePeriodEnds,\n    canExportData,\n    isRestricted,\n    isReadOnly,\n    isLimited,\n    isDenied\n  };\n}\n","'use client';\n\n// ============================================================================\n// CURRENCY HOOK\n// ============================================================================\n\nimport { createContext, useContext, useState, useCallback, useEffect, ReactNode } from 'react';\nimport { \n  CurrencyCode, \n  CurrencySettings, \n  Currency \n} from '@rentalshop/types';\nimport { \n  DEFAULT_CURRENCY_SETTINGS, \n  getCurrency, \n  getCurrentCurrency \n} from '@rentalshop/utils';\n\n// ============================================================================\n// CURRENCY CONTEXT\n// ============================================================================\n\ninterface CurrencyContextType {\n  /** Current currency settings */\n  settings: CurrencySettings;\n  /** Current currency configuration */\n  currentCurrency: Currency;\n  /** Change the current currency */\n  setCurrency: (currency: CurrencyCode) => void;\n  /** Toggle currency symbol visibility */\n  toggleSymbol: () => void;\n  /** Toggle currency code visibility */\n  toggleCode: () => void;\n  /** Get currency by code */\n  getCurrencyByCode: (code: CurrencyCode) => Currency | undefined;\n  /** Convert amount between currencies */\n  convertAmount: (amount: number, from: CurrencyCode, to: CurrencyCode) => number;\n}\n\nconst CurrencyContext = createContext<CurrencyContextType | undefined>(undefined);\n\n// ============================================================================\n// CURRENCY PROVIDER\n// ============================================================================\n\ninterface CurrencyProviderProps {\n  children: ReactNode;\n  /** Initial currency settings (optional) */\n  initialSettings?: Partial<CurrencySettings>;\n}\n\nexport function CurrencyProvider({ \n  children, \n  initialSettings = {} \n}: CurrencyProviderProps) {\n  // Initialize settings with defaults and any overrides\n  const [settings, setSettings] = useState<CurrencySettings>({\n    ...DEFAULT_CURRENCY_SETTINGS,\n    ...initialSettings,\n  });\n\n  // Get current currency configuration\n  const currentCurrency = getCurrentCurrency(settings);\n\n  // Change current currency\n  const setCurrency = useCallback((currencyCode: CurrencyCode) => {\n    setSettings(prev => ({\n      ...prev,\n      currentCurrency: currencyCode,\n    }));\n    \n    // Save to localStorage for persistence\n    localStorage.setItem('rentalshop-currency', currencyCode);\n  }, []);\n\n  // Toggle currency symbol visibility\n  const toggleSymbol = useCallback(() => {\n    setSettings(prev => ({\n      ...prev,\n      showSymbol: !prev.showSymbol,\n    }));\n    \n    // Save to localStorage for persistence\n    localStorage.setItem('rentalshop-show-symbol', (!settings.showSymbol).toString());\n  }, [settings.showSymbol]);\n\n  // Toggle currency code visibility\n  const toggleCode = useCallback(() => {\n    setSettings(prev => ({\n      ...prev,\n      showCode: !prev.showCode,\n    }));\n    \n    // Save to localStorage for persistence\n    localStorage.setItem('rentalshop-show-code', (!settings.showCode).toString());\n  }, [settings.showCode]);\n\n  // Get currency by code\n  const getCurrencyByCode = useCallback((code: CurrencyCode) => {\n    return getCurrency(code);\n  }, []);\n\n  // Convert amount between currencies\n  const convertAmount = useCallback((amount: number, from: CurrencyCode, to: CurrencyCode) => {\n    if (from === to) return amount;\n    \n    const fromCurrency = getCurrency(from);\n    const toCurrency = getCurrency(to);\n    \n    if (!fromCurrency || !toCurrency) {\n      throw new Error(`Invalid currency code: ${from} or ${to}`);\n    }\n    \n    // Convert to base currency (USD) first, then to target currency\n    const amountInUSD = amount / fromCurrency.exchangeRate;\n    return amountInUSD * toCurrency.exchangeRate;\n  }, []);\n\n  // Load saved settings from localStorage on mount\n  useEffect(() => {\n    try {\n      const savedCurrency = localStorage.getItem('rentalshop-currency') as CurrencyCode;\n      const savedShowSymbol = localStorage.getItem('rentalshop-show-symbol');\n      const savedShowCode = localStorage.getItem('rentalshop-show-code');\n      \n      if (savedCurrency && isValidCurrencyCode(savedCurrency)) {\n        setSettings(prev => ({ ...prev, currentCurrency: savedCurrency }));\n      }\n      \n      if (savedShowSymbol !== null) {\n        setSettings(prev => ({ ...prev, showSymbol: savedShowSymbol === 'true' }));\n      }\n      \n      if (savedShowCode !== null) {\n        setSettings(prev => ({ ...prev, showCode: savedShowCode === 'true' }));\n      }\n    } catch (error) {\n      console.warn('Failed to load currency settings from localStorage:', error);\n    }\n  }, []);\n\n  const contextValue: CurrencyContextType = {\n    settings,\n    currentCurrency,\n    setCurrency,\n    toggleSymbol,\n    toggleCode,\n    getCurrencyByCode,\n    convertAmount,\n  };\n\n  return (\n    <CurrencyContext.Provider value={contextValue}>\n      {children}\n    </CurrencyContext.Provider>\n  );\n}\n\n// ============================================================================\n// CURRENCY HOOK\n// ============================================================================\n\nexport function useCurrency(): CurrencyContextType {\n  const context = useContext(CurrencyContext);\n  \n  if (context === undefined) {\n    throw new Error('useCurrency must be used within a CurrencyProvider');\n  }\n  \n  return context;\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\nfunction isValidCurrencyCode(code: string): code is CurrencyCode {\n  return ['USD', 'VND'].includes(code as CurrencyCode);\n}\n","'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { customersApi } from '@rentalshop/utils';\nimport type { CustomerFilters, Customer } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface CustomersDataResponse {\n  customers: Customer[];\n  total: number;\n  totalPages: number;\n  currentPage: number;\n  limit: number;\n  hasMore: boolean;\n}\n\nexport interface UseCustomersDataOptions {\n  filters: CustomerFilters;\n  enabled?: boolean; // Allow disabling fetch\n  debounceSearch?: boolean; // Debounce search queries\n  debounceMs?: number; // Debounce delay\n}\n\nexport interface UseCustomersDataReturn {\n  data: CustomersDataResponse | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\n/**\n * ✅ CLEAN DATA FETCHING HOOK\n * - Single responsibility: fetch customers based on filters\n * - Automatic request cancellation\n * - Debounced search\n * - No state management (that's the page's job)\n */\nexport function useCustomersData(options: UseCustomersDataOptions): UseCustomersDataReturn {\n  const { filters, enabled = true, debounceSearch = true, debounceMs = 500 } = options;\n  \n  const [data, setData] = useState<CustomersDataResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const refetchTriggerRef = useRef(0);\n\n  // Refetch function\n  const refetch = () => {\n    refetchTriggerRef.current += 1;\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    // Cancel previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        console.log('🔍 useCustomersData: Fetching with filters:', filters);\n\n        const response = await customersApi.searchCustomers(filters);\n\n        // Check if request was aborted\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n\n        if (response.success && response.data) {\n          // API returns: { success: true, data: { customers, total, page, limit, hasMore, totalPages } }\n          const apiData = response.data as any;\n          const customersData = apiData.customers || [];\n          const total = apiData.total || 0;\n          const limit = apiData.limit || filters.limit || 25;\n          const currentPage = apiData.page || filters.page || 1;\n          const totalPages = apiData.totalPages || Math.ceil(total / limit);\n          const hasMore = apiData.hasMore !== undefined ? apiData.hasMore : currentPage < totalPages;\n\n          setData({\n            customers: customersData as Customer[],\n            total,\n            totalPages,\n            currentPage,\n            limit,\n            hasMore\n          });\n        } else {\n          throw new Error('Failed to fetch customers');\n        }\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          console.error('🔍 useCustomersData: Error fetching customers:', err);\n          setError(err as Error);\n        }\n      } finally {\n        if (!abortControllerRef.current?.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    // Debounce search queries only\n    if (debounceSearch && (filters.search || filters.q)) {\n      console.log('🔍 useCustomersData: Debouncing search query');\n      const timer = setTimeout(fetchData, debounceMs);\n      return () => {\n        clearTimeout(timer);\n        abortControllerRef.current?.abort();\n      };\n    } else {\n      // Immediate fetch for non-search filters\n      fetchData();\n      return () => {\n        abortControllerRef.current?.abort();\n      };\n    }\n  }, [\n    filters, // This is now stable from parent's memoization\n    enabled,\n    debounceSearch,\n    debounceMs,\n    refetchTriggerRef.current\n  ]);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch\n  };\n}\n\n","'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { ordersApi } from '@rentalshop/utils';\nimport type { OrderFilters, OrderWithDetails, OrderStatus, OrderType } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface OrdersDataResponse {\n  orders: OrderWithDetails[];\n  total: number;\n  totalPages: number;\n  currentPage: number;\n  limit: number;\n  hasMore: boolean;\n}\n\nexport interface UseOrdersDataOptions {\n  filters: OrderFilters;\n  enabled?: boolean; // Allow disabling fetch\n  debounceSearch?: boolean; // Debounce search queries\n  debounceMs?: number; // Debounce delay\n}\n\nexport interface UseOrdersDataReturn {\n  data: OrdersDataResponse | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\n/**\n * ✅ CLEAN DATA FETCHING HOOK\n * - Single responsibility: fetch orders based on filters\n * - Automatic request cancellation\n * - Debounced search\n * - No state management (that's the page's job)\n */\nexport function useOrdersData(options: UseOrdersDataOptions): UseOrdersDataReturn {\n  const { filters, enabled = true, debounceSearch = true, debounceMs = 500 } = options;\n  \n  const [data, setData] = useState<OrdersDataResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const refetchTriggerRef = useRef(0);\n\n  // Refetch function\n  const refetch = () => {\n    refetchTriggerRef.current += 1;\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    // Cancel previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        console.log('🔍 useOrdersData: Fetching with filters:', filters);\n\n        const response = await ordersApi.searchOrders(filters);\n\n        // Check if request was aborted\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n\n        if (response.success && response.data) {\n          const ordersData = response.data.orders || [];\n          const total = response.data.total || 0;\n          const limit = filters.limit || 25;\n          const currentPage = filters.page || 1;\n          const totalPages = Math.ceil(total / limit);\n\n          setData({\n            orders: ordersData as OrderWithDetails[],\n            total,\n            totalPages,\n            currentPage,\n            limit,\n            hasMore: currentPage < totalPages\n          });\n        } else {\n          throw new Error('Failed to fetch orders');\n        }\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          console.error('🔍 useOrdersData: Error fetching orders:', err);\n          setError(err as Error);\n        }\n      } finally {\n        if (!abortControllerRef.current?.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    // Debounce search queries only\n    if (debounceSearch && filters.search) {\n      console.log('🔍 useOrdersData: Debouncing search query');\n      const timer = setTimeout(fetchData, debounceMs);\n      return () => {\n        clearTimeout(timer);\n        abortControllerRef.current?.abort();\n      };\n    } else {\n      // Immediate fetch for non-search filters\n      fetchData();\n      return () => {\n        abortControllerRef.current?.abort();\n      };\n    }\n  }, [\n    filters, // This is now stable from parent's memoization\n    enabled,\n    debounceSearch,\n    debounceMs,\n    refetchTriggerRef.current\n  ]);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch\n  };\n}\n\n","'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { outletsApi } from '@rentalshop/utils';\nimport type { OutletFilters, Outlet } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface OutletsDataResponse {\n  outlets: Outlet[];\n  total: number;\n  totalPages: number;\n  currentPage: number;\n  limit: number;\n  hasMore: boolean;\n}\n\nexport interface UseOutletsDataOptions {\n  filters: OutletFilters;\n  enabled?: boolean;\n  debounceSearch?: boolean;\n  debounceMs?: number;\n}\n\nexport interface UseOutletsDataReturn {\n  data: OutletsDataResponse | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\n/**\n * ✅ CLEAN DATA FETCHING HOOK\n * - Single responsibility: fetch outlets based on filters\n * - Automatic request cancellation\n * - Debounced search\n * - No state management (that's the page's job)\n */\nexport function useOutletsData(options: UseOutletsDataOptions): UseOutletsDataReturn {\n  const { filters, enabled = true, debounceSearch = true, debounceMs = 500 } = options;\n  \n  const [data, setData] = useState<OutletsDataResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const refetchTriggerRef = useRef(0);\n\n  const refetch = () => {\n    refetchTriggerRef.current += 1;\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        console.log('🔍 useOutletsData: Fetching with filters:', filters);\n\n        const response = await outletsApi.searchOutlets(filters);\n        \n        console.log('📦 useOutletsData: API Response:', response);\n        console.log('📊 useOutletsData: Response data:', response.data);\n\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n\n        if (response.success && response.data) {\n          const apiData = response.data as any;\n          \n          // Handle different API response structures\n          if (Array.isArray(apiData)) {\n            const pagination = (response as any).pagination || {};\n            const outletsData = apiData;\n            const total = pagination.total || apiData.length;\n            const limit = pagination.limit || filters.limit || 25;\n            const currentPage = pagination.page || filters.page || 1;\n            const totalPages = Math.ceil(total / limit);\n            const hasMore = pagination.hasMore !== undefined ? pagination.hasMore : currentPage < totalPages;\n\n            setData({\n              outlets: outletsData as Outlet[],\n              total,\n              totalPages,\n              currentPage,\n              limit,\n              hasMore\n            });\n          } else {\n            const outletsData = apiData.outlets || [];\n            const total = apiData.total || 0;\n            const limit = apiData.limit || filters.limit || 25;\n            const currentPage = apiData.page || filters.page || 1;\n            const totalPages = apiData.totalPages || Math.ceil(total / limit);\n            const hasMore = apiData.hasMore !== undefined ? apiData.hasMore : currentPage < totalPages;\n\n            setData({\n              outlets: outletsData as Outlet[],\n              total,\n              totalPages,\n              currentPage,\n              limit,\n              hasMore\n            });\n          }\n        } else {\n          throw new Error('Failed to fetch outlets');\n        }\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          console.error('🔍 useOutletsData: Error fetching outlets:', err);\n          setError(err as Error);\n        }\n      } finally {\n        if (!abortControllerRef.current?.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    if (debounceSearch && (filters.search || filters.q)) {\n      console.log('🔍 useOutletsData: Debouncing search query');\n      const timer = setTimeout(fetchData, debounceMs);\n      return () => {\n        clearTimeout(timer);\n        abortControllerRef.current?.abort();\n      };\n    } else {\n      fetchData();\n      return () => {\n        abortControllerRef.current?.abort();\n      };\n    }\n  }, [\n    filters,\n    enabled,\n    debounceSearch,\n    debounceMs,\n    refetchTriggerRef.current\n  ]);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch\n  };\n}\n\n","import { useState, useEffect, useRef } from 'react';\nimport { categoriesApi } from '@rentalshop/utils';\nimport type { CategoryFilters, Category } from '@rentalshop/types';\n\nexport interface CategoriesDataResponse {\n  categories: Category[];\n  total: number;\n  currentPage: number;\n  totalPages: number;\n  limit: number;\n  hasMore: boolean;\n}\n\nexport interface UseCategoriesDataOptions {\n  filters: CategoryFilters;\n  enabled?: boolean;\n  debounceSearch?: boolean;\n  debounceMs?: number;\n}\n\nexport interface UseCategoriesDataReturn {\n  data: CategoriesDataResponse | null;\n  loading: boolean;\n  error: string | null;\n  refetch: () => void;\n}\n\n/**\n * Hook to fetch categories data with filters, pagination, and optional debounced search\n * Follows the same pattern as useOutletsData\n */\nexport function useCategoriesData(options: UseCategoriesDataOptions): UseCategoriesDataReturn {\n  const { filters, enabled = true, debounceSearch = false, debounceMs = 300 } = options;\n  \n  const [data, setData] = useState<CategoriesDataResponse | null>(null);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  const abortControllerRef = useRef<AbortController | null>(null);\n  const refetchTriggerRef = useRef<number>(0);\n  const searchDebounceRef = useRef<NodeJS.Timeout | null>(null);\n\n  const refetch = () => {\n    refetchTriggerRef.current += 1;\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        console.log('🔍 useCategoriesData: Fetching with filters:', filters);\n\n        const response = await categoriesApi.searchCategories(filters);\n        \n        console.log('📦 useCategoriesData: API Response:', response);\n        console.log('📊 useCategoriesData: Response data:', response.data);\n\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n\n        if (response.success && response.data) {\n          const apiData = response.data as any;\n          \n          // Handle different API response structures\n          if (Array.isArray(apiData)) {\n            const pagination = (response as any).pagination || {};\n            const categoriesData = apiData;\n            const total = pagination.total || apiData.length;\n            const limit = pagination.limit || filters.limit || 25;\n            const currentPage = pagination.page || filters.page || 1;\n            const totalPages = Math.ceil(total / limit);\n            const hasMore = pagination.hasMore !== undefined ? pagination.hasMore : currentPage < totalPages;\n\n            setData({\n              categories: categoriesData as Category[],\n              total,\n              totalPages,\n              currentPage,\n              limit,\n              hasMore\n            });\n          } else {\n            const categoriesData = apiData.categories || [];\n            const total = apiData.total || 0;\n            const limit = apiData.limit || filters.limit || 25;\n            const currentPage = apiData.page || filters.page || 1;\n            const totalPages = apiData.totalPages || Math.ceil(total / limit);\n            const hasMore = apiData.hasMore !== undefined ? apiData.hasMore : currentPage < totalPages;\n\n            setData({\n              categories: categoriesData as Category[],\n              total,\n              totalPages,\n              currentPage,\n              limit,\n              hasMore\n            });\n          }\n        } else {\n          throw new Error(response.message || 'Failed to fetch categories');\n        }\n      } catch (err: any) {\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n        console.error('useCategoriesData: Error fetching categories:', err);\n        setError(err.message || 'Failed to fetch categories');\n        setData(null);\n      } finally {\n        if (!abortControllerRef.current?.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    // Handle debounced search\n    const shouldDebounce = debounceSearch && (filters.q || filters.search);\n    \n    if (shouldDebounce) {\n      console.log('🔍 useCategoriesData: Debouncing search query');\n      if (searchDebounceRef.current) {\n        clearTimeout(searchDebounceRef.current);\n      }\n      searchDebounceRef.current = setTimeout(() => {\n        fetchData();\n      }, debounceMs);\n    } else {\n      fetchData();\n    }\n\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (searchDebounceRef.current) {\n        clearTimeout(searchDebounceRef.current);\n      }\n    };\n  }, [filters, enabled, debounceSearch, debounceMs, refetchTriggerRef.current]);\n\n  return { data, loading, error, refetch };\n}\n\n","\"use client\"\n\nimport { useState, useCallback } from 'react';\nimport { PAGINATION } from '@rentalshop/constants';\n\nexport interface PaginationState {\n  total: number;\n  limit: number;\n  offset: number;\n  hasMore: boolean;\n  currentPage: number;\n  totalPages: number;\n}\n\nexport interface PaginationConfig {\n  initialLimit?: number;\n  initialOffset?: number;\n}\n\nexport interface UsePaginationReturn {\n  pagination: PaginationState;\n  setPagination: (pagination: Partial<PaginationState>) => void;\n  handlePageChange: (page: number) => void;\n  resetPagination: () => void;\n  updatePaginationFromResponse: (response: {\n    total: number;\n    limit: number;\n    offset: number;\n    hasMore?: boolean;\n  }) => void;\n}\n\nexport function usePagination(config: PaginationConfig = {}): UsePaginationReturn {\n  const { initialLimit = PAGINATION.DEFAULT_PAGE_SIZE, initialOffset = 0 } = config;\n  \n  const [pagination, setPaginationState] = useState<PaginationState>({\n    total: 0,\n    limit: initialLimit,\n    offset: initialOffset,\n    hasMore: false,\n    currentPage: 1,\n    totalPages: 1\n  });\n\n  const setPagination = useCallback((newPagination: Partial<PaginationState>) => {\n    setPaginationState(prev => ({\n      ...prev,\n      ...newPagination,\n      currentPage: Math.floor((newPagination.offset ?? prev.offset) / (newPagination.limit ?? prev.limit)) + 1,\n      totalPages: Math.ceil((newPagination.total ?? prev.total) / (newPagination.limit ?? prev.limit))\n    }));\n  }, []);\n\n  const handlePageChange = useCallback((page: number) => {\n    const newOffset = (page - 1) * pagination.limit;\n    setPagination({\n      offset: newOffset,\n      currentPage: page\n    });\n  }, [pagination.limit, setPagination]);\n\n\n\n  const resetPagination = useCallback(() => {\n    setPagination({\n      total: 0,\n      offset: initialOffset,\n      hasMore: false,\n      currentPage: 1,\n      totalPages: 1\n    });\n  }, [initialOffset, setPagination]);\n\n  const updatePaginationFromResponse = useCallback((response: {\n    total: number;\n    limit: number;\n    offset: number;\n    hasMore?: boolean;\n  }) => {\n    setPagination({\n      total: response.total,\n      limit: response.limit,\n      offset: response.offset,\n      hasMore: response.hasMore ?? (response.offset + response.limit < response.total),\n      currentPage: Math.floor(response.offset / response.limit) + 1,\n      totalPages: Math.ceil(response.total / response.limit)\n    });\n  }, [setPagination]);\n\n  return {\n    pagination,\n    setPagination,\n    handlePageChange,\n    resetPagination,\n    updatePaginationFromResponse\n  };\n}\n","'use client';\n\nimport { useCallback } from 'react';\nimport type { Product } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n// Product interface is now imported from @rentalshop/types\n\nexport interface Order {\n  id: number;\n  orderType: string;\n  status: string;\n  pickupPlanAt: string;\n  returnPlanAt: string;\n  orderItems: Array<{\n    productId: number;\n    quantity: number;\n    name: string;\n  }>;\n}\n\nexport interface AvailabilityStatus {\n  available: boolean;\n  availableQuantity: number;\n  conflicts: Order[];\n  message: string;\n}\n\n// ============================================================================\n// USE PRODUCT AVAILABILITY HOOK\n// ============================================================================\n\nexport function useProductAvailability() {\n  // ============================================================================\n  // AVAILABILITY CALCULATION\n  // ============================================================================\n\n  const calculateAvailability = useCallback((\n    product: Product,\n    pickupDate: string,\n    returnDate: string,\n    requestedQuantity: number,\n    existingOrders: Order[] = []\n  ): AvailabilityStatus => {\n    // Convert dates to Date objects\n    const pickup = new Date(pickupDate);\n    const return_ = new Date(returnDate);\n    \n    // Validate dates\n    if (pickup >= return_) {\n      return {\n        available: false,\n        availableQuantity: 0,\n        conflicts: [],\n        message: 'Return date must be after pickup date'\n      };\n    }\n\n    // Find conflicting orders for this product\n    const conflicts = existingOrders.filter(order => {\n      // Only check RENT orders\n      if (order.orderType !== 'RENT') return false;\n      \n      // Check if order is active (not completed/cancelled)\n      const activeStatuses = ['RESERVED', 'PICKUPED'];\n      if (!activeStatuses.includes(order.status)) return false;\n      \n      // Check if order items contain this product\n      const hasProduct = order.orderItems.some(item => item.productId === product.id);\n      if (!hasProduct) return false;\n      \n      // Check date overlap\n      const orderPickup = new Date(order.pickupPlanAt);\n      const orderReturn = new Date(order.returnPlanAt);\n      \n      // Check if dates overlap\n      return (\n        (pickup <= orderReturn && return_ >= orderPickup) ||\n        (orderPickup <= return_ && orderReturn >= pickup)\n      );\n    });\n\n    // Calculate total quantity needed during the requested period\n    const conflictingQuantity = conflicts.reduce((total, order) => {\n      const orderItem = order.orderItems.find(item => item.productId === product.id);\n      return total + (orderItem?.quantity || 0);\n    }, 0);\n\n    // Calculate available quantity\n    const availableQuantity = Math.max(0, product.available - conflictingQuantity);\n    const available = availableQuantity >= requestedQuantity;\n\n    // Generate message\n    let message = '';\n    if (available) {\n      message = `Available: ${availableQuantity} units`;\n    } else {\n      message = `Only ${availableQuantity} units available (requested: ${requestedQuantity})`;\n    }\n\n    return {\n      available,\n      availableQuantity,\n      conflicts,\n      message,\n    };\n  }, []);\n\n  // ============================================================================\n  // QUICK AVAILABILITY CHECK\n  // ============================================================================\n\n  const isProductAvailable = useCallback((\n    product: Product,\n    pickupDate: string,\n    returnDate: string,\n    requestedQuantity: number,\n    existingOrders: Order[] = []\n  ): boolean => {\n    const status = calculateAvailability(product, pickupDate, returnDate, requestedQuantity, existingOrders);\n    return status.available;\n  }, [calculateAvailability]);\n\n  // ============================================================================\n  // AVAILABILITY FOR DATE RANGE\n  // ============================================================================\n\n  const getAvailabilityForDateRange = useCallback((\n    product: Product,\n    startDate: string,\n    endDate: string,\n    existingOrders: Order[] = []\n  ): Array<{ date: string; available: number; conflicts: Order[] }> => {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    const results = [];\n    \n    // Check availability for each day in the range\n    for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {\n      const dateStr = date.toISOString().split('T')[0];\n      const status = calculateAvailability(\n        product, \n        dateStr, \n        dateStr, \n        1, \n        existingOrders\n      );\n      \n      results.push({\n        date: dateStr,\n        available: status.availableQuantity,\n        conflicts: status.conflicts,\n      });\n    }\n    \n    return results;\n  }, [calculateAvailability]);\n\n  // ============================================================================\n  // RETURN VALUES\n  // ============================================================================\n\n  return {\n    calculateAvailability,\n    isProductAvailable,\n    getAvailabilityForDateRange,\n  };\n}\n","'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { productsApi } from '@rentalshop/utils';\nimport type { ProductFilters, ProductWithDetails } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ProductsDataResponse {\n  products: ProductWithDetails[];\n  total: number;\n  totalPages: number;\n  currentPage: number;\n  limit: number;\n  hasMore: boolean;\n}\n\nexport interface UseProductsDataOptions {\n  filters: ProductFilters;\n  enabled?: boolean; // Allow disabling fetch\n  debounceSearch?: boolean; // Debounce search queries\n  debounceMs?: number; // Debounce delay\n}\n\nexport interface UseProductsDataReturn {\n  data: ProductsDataResponse | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\n/**\n * ✅ CLEAN DATA FETCHING HOOK\n * - Single responsibility: fetch products based on filters\n * - Automatic request cancellation\n * - Debounced search\n * - No state management (that's the page's job)\n */\nexport function useProductsData(options: UseProductsDataOptions): UseProductsDataReturn {\n  const { filters, enabled = true, debounceSearch = true, debounceMs = 500 } = options;\n  \n  const [data, setData] = useState<ProductsDataResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const refetchTriggerRef = useRef(0);\n\n  // Refetch function\n  const refetch = () => {\n    refetchTriggerRef.current += 1;\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    // Cancel previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        console.log('🔍 useProductsData: Fetching with filters:', filters);\n\n        const response = await productsApi.searchProducts(filters);\n\n        // Check if request was aborted\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n\n        if (response.success && response.data) {\n          // API returns: { success: true, data: { products, total, page, limit, hasMore, totalPages } }\n          const apiData = response.data as any;\n          const productsData = apiData.products || [];\n          const total = apiData.total || 0;\n          const limit = apiData.limit || filters.limit || 25;\n          const currentPage = apiData.page || filters.page || 1;\n          const totalPages = apiData.totalPages || Math.ceil(total / limit);\n          const hasMore = apiData.hasMore !== undefined ? apiData.hasMore : currentPage < totalPages;\n\n          setData({\n            products: productsData as ProductWithDetails[],\n            total,\n            totalPages,\n            currentPage,\n            limit,\n            hasMore\n          });\n        } else {\n          throw new Error('Failed to fetch products');\n        }\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          console.error('🔍 useProductsData: Error fetching products:', err);\n          setError(err as Error);\n        }\n      } finally {\n        if (!abortControllerRef.current?.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    // Debounce search queries only\n    if (debounceSearch && (filters.search || filters.q)) {\n      console.log('🔍 useProductsData: Debouncing search query');\n      const timer = setTimeout(fetchData, debounceMs);\n      return () => {\n        clearTimeout(timer);\n        abortControllerRef.current?.abort();\n      };\n    } else {\n      // Immediate fetch for non-search filters\n      fetchData();\n      return () => {\n        abortControllerRef.current?.abort();\n      };\n    }\n  }, [\n    filters, // This is now stable from parent's memoization\n    enabled,\n    debounceSearch,\n    debounceMs,\n    refetchTriggerRef.current\n  ]);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch\n  };\n}\n\n","'use client';\n\n// ============================================================================\n// SUBSCRIPTION ERROR HANDLER HOOK\n// ============================================================================\n\nimport { useState, useCallback } from 'react';\nimport { useToasts } from '@rentalshop/ui';\n\nexport interface SubscriptionError {\n  message: string;\n  subscriptionStatus?: string;\n  merchantStatus?: string;\n  code?: string;\n}\n\nexport interface UseSubscriptionErrorReturn {\n  handleSubscriptionError: (error: any) => void;\n  showSubscriptionError: (error: SubscriptionError) => void;\n  clearError: () => void;\n  error: SubscriptionError | null;\n}\n\n/**\n * Hook for handling subscription-related errors\n * Provides centralized error handling and user feedback\n */\nexport function useSubscriptionError(): UseSubscriptionErrorReturn {\n  const [error, setError] = useState<SubscriptionError | null>(null);\n  const { addToast } = useToasts();\n\n  const handleSubscriptionError = useCallback((error: any) => {\n    console.error('Subscription error:', error);\n\n    // Check if it's a subscription error\n    if (error?.error === 'SUBSCRIPTION_ERROR' || error?.code === 'SUBSCRIPTION_REQUIRED') {\n      const subscriptionError: SubscriptionError = {\n        message: error.message || 'Subscription error occurred',\n        subscriptionStatus: error.subscriptionStatus,\n        merchantStatus: error.merchantStatus,\n        code: error.code\n      };\n\n      setError(subscriptionError);\n      showSubscriptionError(subscriptionError);\n    } else {\n      // Handle other errors normally\n      addToast('error', 'Error', error?.message || 'An error occurred');\n    }\n  }, [addToast]);\n\n  const showSubscriptionError = useCallback((error: SubscriptionError) => {\n    const { subscriptionStatus, merchantStatus } = error;\n\n    let message = error.message;\n    let action = '';\n\n    // Customize message based on status\n    if (subscriptionStatus === 'paused') {\n      message = 'Your subscription is paused. Some features may be limited.';\n      action = 'Resume your subscription to access all features.';\n    } else if (subscriptionStatus === 'expired') {\n      message = 'Your subscription has expired. Please renew to continue.';\n      action = 'Choose a new plan to continue using the service.';\n    } else if (subscriptionStatus === 'cancelled') {\n      message = 'Your subscription has been cancelled.';\n      action = 'Choose a new plan to reactivate your account.';\n    } else if (subscriptionStatus === 'past_due') {\n      message = 'Payment is past due. Please update your payment method.';\n      action = 'Update your payment information to avoid service interruption.';\n    } else if (merchantStatus && !['active'].includes(merchantStatus)) {\n      message = `Your merchant account is ${merchantStatus}. Please contact support.`;\n      action = 'Contact support to resolve account issues.';\n    }\n\n    // Show error toast with action\n    addToast('error', 'Subscription Error', action ? `${message}\\n\\n${action}` : message, 8000);\n  }, [addToast]);\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    handleSubscriptionError,\n    showSubscriptionError,\n    clearError,\n    error\n  };\n}\n\nexport default useSubscriptionError;\n","'use client';\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ThrottledSearchOptions {\n  delay: number;\n  minLength: number;\n  onSearch: (query: string) => void;\n}\n\nexport interface ThrottledSearchReturn {\n  query: string;\n  isSearching: boolean;\n  handleSearchChange: (value: string) => void;\n  clearSearch: () => void;\n  cleanup: () => void;\n  setQuery: (value: string) => void;\n}\n\n// ============================================================================\n// USE THROTTLED SEARCH HOOK\n// ============================================================================\n\nexport function useThrottledSearch(options: ThrottledSearchOptions): ThrottledSearchReturn {\n  const { delay, minLength, onSearch } = options;\n  \n  const [query, setQuery] = useState('');\n  const [isSearching, setIsSearching] = useState(false);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isSearchingRef = useRef(false);\n  const isInitialRender = useRef(true); // Track initial render\n  \n  // ✅ FIX: Use ref to store the latest onSearch callback to avoid recreating handleSearchChange\n  const onSearchRef = useRef(onSearch);\n  \n  // Update ref when onSearch changes\n  useEffect(() => {\n    onSearchRef.current = onSearch;\n  }, [onSearch]);\n\n  // ============================================================================\n  // SEARCH FUNCTIONS\n  // ============================================================================\n\n  const handleSearchChange = useCallback((value: string) => {\n    console.log('🔍 useThrottledSearch: handleSearchChange called with:', value);\n    setQuery(value);\n    \n    // Clear existing timeout\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    // Only search if query meets minimum length\n    if (value.length >= minLength) {\n      console.log('🔍 useThrottledSearch: Query meets minLength, setting up timeout');\n      setIsSearching(true);\n      isSearchingRef.current = true;\n      \n      // Set new timeout for debounced search\n      timeoutRef.current = setTimeout(() => {\n        console.log('🔍 useThrottledSearch: Timeout executing, calling onSearch with:', value);\n        onSearchRef.current(value); // ✅ Use ref instead of direct callback\n        setIsSearching(false);\n        isSearchingRef.current = false;\n      }, delay);\n    } else if (value.length === 0) {\n      console.log('🔍 useThrottledSearch: Query is empty, clearing search');\n      // Clear search when query is empty\n      setIsSearching(false);\n      isSearchingRef.current = false;\n      if (!isInitialRender.current) {\n        onSearchRef.current(''); // ✅ Use ref instead of direct callback\n      }\n    } else {\n      console.log('🔍 useThrottledSearch: Query too short, not searching');\n      // Query too short, not searching\n      setIsSearching(false);\n      isSearchingRef.current = false;\n    }\n  }, [delay, minLength]); // ✅ Remove onSearch from dependencies\n\n  const clearSearch = useCallback(() => {\n    setQuery('');\n    setIsSearching(false);\n    isSearchingRef.current = false;\n    \n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    if (!isInitialRender.current) {\n      onSearchRef.current(''); // ✅ Use ref instead of direct callback\n    }\n  }, []); // ✅ Remove onSearch from dependencies\n\n  const cleanup = useCallback(() => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n  }, []);\n\n  // ============================================================================\n  // EFFECTS\n  // ============================================================================\n\n  useEffect(() => {\n    // Mark that initial render is complete\n    isInitialRender.current = false;\n    \n    \n    // Cleanup on unmount\n    return cleanup;\n  }, [cleanup]);\n\n  // ============================================================================\n  // RETURN VALUES\n  // ============================================================================\n\n  return {\n    query,\n    isSearching,\n    handleSearchChange,\n    clearSearch,\n    cleanup,\n    setQuery,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { \n  analyzeError, \n  handleApiErrorForUI, \n  withErrorHandlingForUI,\n  getToastType,\n  type ErrorInfo \n} from '@rentalshop/utils';\nimport { useToasts } from '@rentalshop/ui';\n\n/**\n * Toast Management Hooks\n * \n * This file contains hooks for managing toast notifications and error handling:\n * - useErrorHandler: Full-featured error handling with retry and login functionality\n * - useSimpleErrorHandler: Basic error handling with toast notifications\n * - useToastHandler: General toast functionality for both errors and success messages\n */\n\nexport interface UseErrorHandlerOptions {\n  onLogin?: () => void;\n  onRetry?: () => void;\n  onDismiss?: () => void;\n  autoHandleAuth?: boolean;\n}\n\nexport interface UseErrorHandlerReturn {\n  isLoading: boolean;\n  handleError: (error: any) => ErrorInfo;\n  handleApiCall: <T>(apiCall: () => Promise<T>) => Promise<{ data?: T; error?: ErrorInfo }>;\n  retry: () => void;\n  login: () => void;\n  showErrorToast: (error: any) => void;\n}\n\n/**\n * Hook for handling errors with toast notifications and user actions\n * \n * Features:\n * - Automatic error analysis and categorization\n * - Toast notifications for all error types\n * - Built-in retry and login functionality\n * - Loading state management\n * - Easy integration with API calls\n */\nexport const useErrorHandler = (options: UseErrorHandlerOptions = {}): UseErrorHandlerReturn => {\n  const {\n    onLogin,\n    onRetry,\n    onDismiss,\n    autoHandleAuth = true\n  } = options;\n\n  const [isLoading, setIsLoading] = useState(false);\n  const { addToast } = useToasts();\n\n  const handleError = useCallback((error: any): ErrorInfo => {\n    const errorInfo = analyzeError(error);\n    return errorInfo;\n  }, []);\n\n  const showErrorToast = useCallback((error: any) => {\n    const errorInfo = analyzeError(error);\n    const toastType = getToastType(errorInfo.type);\n    \n    // Create toast message with specific action guidance\n    let toastMessage = errorInfo.message;\n    \n    if (errorInfo.showLoginButton) {\n      if (errorInfo.type === 'auth') {\n        toastMessage += ' Click to log in again.';\n      } else if (errorInfo.type === 'permission') {\n        toastMessage += ' Click to log in with a different account.';\n      } else if (errorInfo.type === 'subscription') {\n        toastMessage += ' Click to log in and upgrade your plan.';\n      } else {\n        toastMessage += ' Click to log in.';\n      }\n    }\n    \n    addToast(toastType, errorInfo.title, toastMessage, 0); // No auto-hide for errors\n  }, [addToast]);\n\n  const handleApiCall = useCallback(async <T>(apiCall: () => Promise<T>) => {\n    setIsLoading(true);\n    \n    try {\n      const result = await withErrorHandlingForUI(apiCall);\n      \n      if (result.error) {\n        showErrorToast(result.error);\n      }\n      \n      return result;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [showErrorToast]);\n\n  const retry = useCallback(() => {\n    if (onRetry) {\n      onRetry();\n    }\n  }, [onRetry]);\n\n  const login = useCallback(() => {\n    if (onLogin) {\n      onLogin();\n    } else if (typeof window !== 'undefined') {\n      // Default login behavior - redirect to login page\n    //   window.location.href = '/login';\n    }\n  }, [onLogin]);\n\n  return {\n    isLoading,\n    handleError,\n    handleApiCall,\n    retry,\n    login,\n    showErrorToast\n  };\n};\n\n/**\n * Simplified hook for basic error handling with toasts\n */\nexport const useSimpleErrorHandler = () => {\n  const { addToast } = useToasts();\n\n  const handleError = useCallback((error: any) => {\n    const errorInfo = analyzeError(error);\n    const toastType = getToastType(errorInfo.type);\n    \n    let toastMessage = errorInfo.message;\n    if (errorInfo.showLoginButton) {\n      if (errorInfo.type === 'auth') {\n        toastMessage += ' Click to log in again.';\n      } else if (errorInfo.type === 'permission') {\n        toastMessage += ' Click to log in with a different account.';\n      } else if (errorInfo.type === 'subscription') {\n        toastMessage += ' Click to log in and upgrade your plan.';\n      } else {\n        toastMessage += ' Click to log in.';\n      }\n    }\n    \n    addToast(toastType, errorInfo.title, toastMessage, 0);\n    return errorInfo;\n  }, [addToast]);\n\n  return {\n    handleError\n  };\n};\n\n/**\n * Toast handler hook that provides both error and success toast functionality\n * This is the recommended way to handle toasts in components\n */\nexport const useToastHandler = () => {\n  const { addToast } = useToasts();\n\n  const showError = useCallback((title: string, message?: string) => {\n    addToast('error', title, message, 0); // No auto-hide for errors\n  }, [addToast]);\n\n  const showSuccess = useCallback((title: string, message?: string) => {\n    addToast('success', title, message, 5000); // 5 second auto-hide for success\n  }, [addToast]);\n\n  const showWarning = useCallback((title: string, message?: string) => {\n    addToast('warning', title, message, 5000);\n  }, [addToast]);\n\n  const showInfo = useCallback((title: string, message?: string) => {\n    addToast('info', title, message, 5000);\n  }, [addToast]);\n\n  const handleError = useCallback((error: any) => {\n    const errorInfo = analyzeError(error);\n    const toastType = getToastType(errorInfo.type);\n    \n    let toastMessage = errorInfo.message;\n    if (errorInfo.showLoginButton) {\n      if (errorInfo.type === 'auth') {\n        toastMessage += ' Click to log in again.';\n      } else if (errorInfo.type === 'permission') {\n        toastMessage += ' Click to log in with a different account.';\n      } else if (errorInfo.type === 'subscription') {\n        toastMessage += ' Click to log in and upgrade your plan.';\n      } else {\n        toastMessage += ' Click to log in.';\n      }\n    }\n    \n    addToast(toastType, errorInfo.title, toastMessage, 0);\n    return errorInfo;\n  }, [addToast]);\n\n  return {\n    showError,\n    showSuccess,\n    showWarning,\n    showInfo,\n    handleError\n  };\n};\n","'use client';\n\nimport { useAuth } from './useAuth';\n\n// ============================================================================\n// USER ROLE HOOK - Simplified role checking\n// ============================================================================\n\nexport interface UserRoleInfo {\n  role: string | undefined;\n  isAdmin: boolean;\n  isMerchant: boolean;\n  isOutletAdmin: boolean;\n  isOutletStaff: boolean;\n  canManageUsers: boolean;\n  canManageProducts: boolean;\n  canManageCategories: boolean;\n  canManageOutlets: boolean;\n  canManageSubscriptions: boolean;\n  canViewBilling: boolean;\n  canExportData: boolean;\n}\n\nexport function useUserRole(): UserRoleInfo {\n  const { user } = useAuth();\n  \n  const role = user?.role;\n  \n  return {\n    role,\n    isAdmin: role === 'ADMIN',\n    isMerchant: role === 'MERCHANT',\n    isOutletAdmin: role === 'OUTLET_ADMIN',\n    isOutletStaff: role === 'OUTLET_STAFF',\n    \n    // Permission checks\n    canManageUsers: role === 'ADMIN' || role === 'MERCHANT' || role === 'OUTLET_ADMIN',\n    canManageProducts: role === 'ADMIN' || role === 'MERCHANT' || role === 'OUTLET_ADMIN',\n    canManageCategories: role === 'ADMIN' || role === 'MERCHANT',\n    canManageOutlets: role === 'ADMIN' || role === 'MERCHANT',\n    canManageSubscriptions: role === 'ADMIN' || role === 'MERCHANT',\n    canViewBilling: role === 'ADMIN' || role === 'MERCHANT',\n    canExportData: role === 'ADMIN' || role === 'MERCHANT',\n  };\n}\n\n// ============================================================================\n// CONVENIENCE HOOKS FOR SPECIFIC PERMISSIONS\n// ============================================================================\n\nexport function useCanManageProducts(): boolean {\n  const { canManageProducts } = useUserRole();\n  return canManageProducts;\n}\n\nexport function useCanManageCategories(): boolean {\n  const { canManageCategories } = useUserRole();\n  return canManageCategories;\n}\n\nexport function useCanManageUsers(): boolean {\n  const { canManageUsers } = useUserRole();\n  return canManageUsers;\n}\n\nexport function useCanManageOutlets(): boolean {\n  const { canManageOutlets } = useUserRole();\n  return canManageOutlets;\n}\n\nexport function useCanManageSubscriptions(): boolean {\n  const { canManageSubscriptions } = useUserRole();\n  return canManageSubscriptions;\n}\n\nexport function useCanViewBilling(): boolean {\n  const { canViewBilling } = useUserRole();\n  return canViewBilling;\n}\n\nexport function useCanExportData(): boolean {\n  const { canExportData } = useUserRole();\n  return canExportData;\n}\n","'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { usersApi } from '@rentalshop/utils';\nimport type { UserFilters, User } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface UsersDataResponse {\n  users: User[];\n  total: number;\n  totalPages: number;\n  currentPage: number;\n  limit: number;\n  hasMore: boolean;\n}\n\nexport interface UseUsersDataOptions {\n  filters: UserFilters;\n  enabled?: boolean; // Allow disabling fetch\n  debounceSearch?: boolean; // Debounce search queries\n  debounceMs?: number; // Debounce delay\n}\n\nexport interface UseUsersDataReturn {\n  data: UsersDataResponse | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => void;\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\n/**\n * ✅ CLEAN DATA FETCHING HOOK\n * - Single responsibility: fetch users based on filters\n * - Automatic request cancellation\n * - Debounced search\n * - No state management (that's the page's job)\n */\nexport function useUsersData(options: UseUsersDataOptions): UseUsersDataReturn {\n  const { filters, enabled = true, debounceSearch = true, debounceMs = 500 } = options;\n  \n  const [data, setData] = useState<UsersDataResponse | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const refetchTriggerRef = useRef(0);\n\n  // Refetch function\n  const refetch = () => {\n    refetchTriggerRef.current += 1;\n  };\n\n  useEffect(() => {\n    if (!enabled) return;\n\n    // Cancel previous request\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n    }\n    abortControllerRef.current = new AbortController();\n\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        console.log('🔍 useUsersData: Fetching with filters:', filters);\n\n        const response = await usersApi.searchUsers(filters);\n\n        // Check if request was aborted\n        if (abortControllerRef.current?.signal.aborted) {\n          return;\n        }\n\n        if (response.success && response.data) {\n          // Handle different API response structures\n          const apiData = response.data as any;\n          \n          // Check if data is array (direct array response)\n          if (Array.isArray(apiData)) {\n            // Direct array: { success: true, data: [...users], pagination: {...} }\n            const pagination = (response as any).pagination || {};\n            const usersData = apiData;\n            const total = pagination.total || apiData.length;\n            const limit = pagination.limit || filters.limit || 25;\n            const currentPage = pagination.page || filters.page || 1;\n            const totalPages = Math.ceil(total / limit);\n            const hasMore = pagination.hasMore !== undefined ? pagination.hasMore : currentPage < totalPages;\n\n            setData({\n              users: usersData as User[],\n              total,\n              totalPages,\n              currentPage,\n              limit,\n              hasMore\n            });\n          } else {\n            // Nested object: { success: true, data: { users, total, page, ... } }\n            const usersData = apiData.users || [];\n            const total = apiData.total || 0;\n            const limit = apiData.limit || filters.limit || 25;\n            const currentPage = apiData.page || filters.page || 1;\n            const totalPages = apiData.totalPages || Math.ceil(total / limit);\n            const hasMore = apiData.hasMore !== undefined ? apiData.hasMore : currentPage < totalPages;\n\n            setData({\n              users: usersData as User[],\n              total,\n              totalPages,\n              currentPage,\n              limit,\n              hasMore\n            });\n          }\n        } else {\n          throw new Error('Failed to fetch users');\n        }\n      } catch (err) {\n        if ((err as Error).name !== 'AbortError') {\n          console.error('🔍 useUsersData: Error fetching users:', err);\n          setError(err as Error);\n        }\n      } finally {\n        if (!abortControllerRef.current?.signal.aborted) {\n          setLoading(false);\n        }\n      }\n    };\n\n    // Debounce search queries only\n    if (debounceSearch && (filters.search || filters.q)) {\n      console.log('🔍 useUsersData: Debouncing search query');\n      const timer = setTimeout(fetchData, debounceMs);\n      return () => {\n        clearTimeout(timer);\n        abortControllerRef.current?.abort();\n      };\n    } else {\n      // Immediate fetch for non-search filters\n      fetchData();\n      return () => {\n        abortControllerRef.current?.abort();\n      };\n    }\n  }, [\n    filters, // This is now stable from parent's memoization\n    enabled,\n    debounceSearch,\n    debounceMs,\n    refetchTriggerRef.current\n  ]);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch\n  };\n}\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,mBAAiD;AACjD,mBAA0E;AA0BnE,SAAS,UAAU;AACxB,QAAM,CAAC,OAAO,QAAQ,QAAI,uBAAoB;AAAA,IAC5C,MAAM;AAAA,IACN,SAAS;AAAA,IACT,OAAO;AAAA,EACT,CAAC;AAMD,QAAM,YAAQ,0BAAY,OAAO,OAAe,aAAuC;AACrF,QAAI;AACF,eAAS,WAAS,EAAE,GAAG,MAAM,SAAS,KAAK,EAAE;AAG7C,YAAM,EAAE,QAAQ,IAAI,MAAM,OAAO,mBAAmB;AACpD,YAAM,WAAW,MAAM,MAAM,QAAQ,KAAK,OAAO;AAAA,QAC/C,QAAQ;AAAA,QACR,SAAS;AAAA,UACP,gBAAgB;AAAA,QAClB;AAAA,QACA,MAAM,KAAK,UAAU,EAAE,OAAO,SAAS,CAAC;AAAA,MAC1C,CAAC;AAGD,UAAI,SAAS,WAAW,KAAK;AAC3B,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,iBAAS,WAAS;AAAA,UAChB,GAAG;AAAA,UACH,OAAO,UAAU,WAAW;AAAA,UAC5B,SAAS;AAAA,QACX,EAAE;AACF,eAAO;AAAA,MACT;AAGA,UAAI,SAAS,WAAW,KAAK;AAC3B,cAAM,YAAY,MAAM,SAAS,KAAK;AACtC,iBAAS,WAAS;AAAA,UAChB,GAAG;AAAA,UACH,OAAO,UAAU,WAAW;AAAA,UAC5B,SAAS;AAAA,QACX,EAAE;AACF,eAAO;AAAA,MACT;AAEA,YAAM,OAAsB,MAAM,SAAS,KAAK;AAEhD,UAAI,KAAK,WAAW,KAAK,MAAM,OAAO;AAEpC,wCAAc,KAAK,KAAK,OAAO,KAAK,KAAK,IAAI;AAE7C,iBAAS,WAAS;AAAA,UAChB,GAAG;AAAA,UACH,MAAM,KAAK,KAAK;AAAA,UAChB,SAAS;AAAA,QACX,EAAE;AACF,eAAO;AAAA,MACT,OAAO;AACL,iBAAS,WAAS;AAAA,UAChB,GAAG;AAAA,UACH,OAAO,KAAK,WAAW;AAAA,UACvB,SAAS;AAAA,QACX,EAAE;AACF,eAAO;AAAA,MACT;AAAA,IACF,SAAS,KAAK;AACZ,YAAM,eAAe,eAAe,QAAQ,IAAI,UAAU;AAC1D,eAAS,WAAS;AAAA,QAChB,GAAG;AAAA,QACH,OAAO;AAAA,QACP,SAAS;AAAA,MACX,EAAE;AACF,aAAO;AAAA,IACT;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,aAAS,0BAAY,MAAM;AAE/B,oCAAc;AACd,aAAS;AAAA,MACP,MAAM;AAAA,MACN,SAAS;AAAA,MACT,OAAO;AAAA,IACT,CAAC;AAAA,EAEH,GAAG,CAAC,CAAC;AAEL,QAAM,iBAAa,0BAAY,MAAM;AACnC,aAAS,WAAS,EAAE,GAAG,MAAM,OAAO,KAAK,EAAE;AAAA,EAC7C,GAAG,CAAC,CAAC;AAEL,QAAM,kBAAc,0BAAY,YAAY;AAC1C,QAAI;AAEF,YAAM,YAAQ,2BAAa;AAC3B,cAAQ,IAAI,+CAAwC,CAAC,CAAC,KAAK;AAE3D,UAAI,CAAC,OAAO;AACV,gBAAQ,IAAI,6CAAwC;AACpD,iBAAS,WAAS,EAAE,GAAG,MAAM,MAAM,MAAM,SAAS,MAAM,EAAE;AAC1D;AAAA,MACF;AAEA,cAAQ,IAAI,6CAAsC;AAElD,YAAM,EAAE,SAAS,mBAAmB,IAAI,MAAM,OAAO,mBAAmB;AACxE,YAAM,WAAW,MAAM,mBAAmB,QAAQ,SAAS,IAAI;AAE/D,cAAQ,IAAI,mCAA4B;AAAA,QACtC,IAAI,SAAS;AAAA,QACb,QAAQ,SAAS;AAAA,QACjB,YAAY,SAAS;AAAA,MACvB,CAAC;AAED,UAAI,SAAS,IAAI;AACf,cAAM,OAAO,MAAM,SAAS,KAAK;AACjC,gBAAQ,IAAI,+BAAwB,IAAI;AAExC,YAAI,KAAK,WAAW,KAAK,MAAM;AAC7B,kBAAQ,IAAI,6BAAwB,KAAK,IAAI;AAC7C,mBAAS,WAAS;AAAA,YAChB,GAAG;AAAA,YACH,MAAM,KAAK;AAAA,YACX,SAAS;AAAA,UACX,EAAE;AAAA,QAEJ,OAAO;AACL,kBAAQ,MAAM,sCAAiC,IAAI;AACnD,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC1C;AAAA,MACF,WAAW,SAAS,WAAW,KAAK;AAElC,YAAI;AACF,gBAAM,YAAY,MAAM,SAAS,MAAM,EAAE,KAAK;AAC9C,kBAAQ,IAAI,2DAAiD;AAE7D,mBAAS,WAAS;AAAA,YAChB,GAAG;AAAA,YACH,SAAS;AAAA,YACT,OAAO,UAAU,WAAW;AAAA,UAC9B,EAAE;AACF;AAAA,QACF,SAAS,YAAY;AACnB,kBAAQ,IAAI,8CAAuC;AACnD,mBAAS,WAAS;AAAA,YAChB,GAAG;AAAA,YACH,SAAS;AAAA,YACT,OAAO;AAAA,UACT,EAAE;AACF;AAAA,QACF;AAAA,MACF,WAAW,SAAS,WAAW,KAAK;AAElC,gBAAQ,IAAI,+DAAwD;AAEpE,eAAO;AAEP,YAAI,OAAO,WAAW,aAAa;AACjC,iBAAO,SAAS,OAAO;AAAA,QACzB;AAAA,MACF,OAAO;AACL,gBAAQ,MAAM,qBAAgB,SAAS,QAAQ,SAAS,UAAU;AAElE,gBAAQ,IAAI,uEAA6D;AACzE,iBAAS,WAAS,EAAE,GAAG,MAAM,SAAS,MAAM,EAAE;AAE9C,YAAI,SAAS,UAAU,KAAK;AAC1B,kBAAQ,IAAI,iEAA0D;AAAA,QACxE;AAAA,MACF;AAAA,IACF,SAAS,KAAK;AACZ,cAAQ,MAAM,oCAA6B,GAAG;AAG9C,cAAQ,IAAI,6DAAmD;AAC/D,eAAS,WAAS,EAAE,GAAG,MAAM,SAAS,MAAM,EAAE;AAE9C,UAAI,eAAe,UACjB,IAAI,QAAQ,SAAS,iBAAiB,KACtC,IAAI,QAAQ,SAAS,eAAe,KACpC,IAAI,QAAQ,SAAS,OAAO,IAC3B;AACD,gBAAQ,IAAI,2DAAoD;AAAA,MAClE;AAAA,IACF;AAAA,EACF,GAAG,CAAC,MAAM,CAAC;AAMX,8BAAU,MAAM;AAEd,UAAM,YAAQ,2BAAa;AAC3B,UAAM,iBAAa,4BAAc;AAEjC,YAAQ,IAAI,qDAA8C;AAAA,MACxD,UAAU,CAAC,CAAC;AAAA,MACZ,eAAe,CAAC,CAAC;AAAA,MACjB,aAAa,OAAO;AAAA,MACpB,cAAc,QAAQ,MAAM,UAAU,GAAG,EAAE,IAAI,QAAQ;AAAA,MACvD,mBAAmB,aAAa,KAAK,UAAU,UAAU,EAAE,UAAU,GAAG,GAAG,IAAI,QAAQ;AAAA,MACvF,qBAAqB,YAAY;AAAA,MACjC,oBAAoB,YAAY;AAAA,MAChC,iBAAiB,YAAY;AAAA,IAC/B,CAAC;AAED,QAAI,SAAS,YAAY;AACvB,cAAQ,IAAI,kCAA6B,UAAU;AACnD,eAAS,WAAS,EAAE,GAAG,MAAM,MAAM;AAAA,QACjC,GAAG;AAAA,QACH,IAAI,WAAW;AAAA;AAAA,MACjB,GAAW,SAAS,MAAM,EAAE;AAI5B,UAAI,CAAC,WAAW,cAAc,CAAC,WAAW,UAAU;AAClD,gBAAQ,IAAI,uFAAgF;AAE5F,oBAAY;AAAA,MACd,WAAW,CAAC,WAAW,aAAa,CAAC,WAAW,UAAU;AACxD,gBAAQ,IAAI,sFAA+E;AAE3F,oBAAY;AAAA,MACd,OAAO;AACL,gBAAQ,IAAI,gDAA2C;AAAA,MACzD;AAAA,IACF,WAAW,SAAS,CAAC,YAAY;AAC/B,cAAQ,IAAI,kEAA2D;AAEvE,kBAAY;AAAA,IACd,OAAO;AACL,cAAQ,IAAI,oDAA+C;AAC3D,eAAS,WAAS,EAAE,GAAG,MAAM,MAAM,MAAM,SAAS,MAAM,EAAE;AAAA,IAC5D;AAAA,EACF,GAAG,CAAC,WAAW,CAAC;AAMhB,8BAAU,MAAM;AAEd,UAAM,mBAAmB,MAAM;AAC7B,YAAM,YAAQ,2BAAa;AAC3B,UAAI,CAAC;AAAO;AAEZ,UAAI;AACF,cAAM,QAAQ,MAAM,MAAM,GAAG;AAC7B,YAAI,MAAM,WAAW,GAAG;AACtB,gBAAM,UAAU,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC;AACzC,gBAAM,MAAM,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AACxC,gBAAM,kBAAkB,QAAQ,MAAM;AAGtC,cAAI,kBAAkB,OAAO,kBAAkB,GAAG;AAChD,oBAAQ,IAAI,6CAAsC;AAClD,wBAAY;AAAA,UACd;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,gBAAQ,KAAK,iCAAiC,KAAK;AAAA,MACrD;AAAA,IACF;AAGA,UAAM,WAAW,YAAY,kBAAkB,GAAK;AAGpD,qBAAiB;AAEjB,WAAO,MAAM,cAAc,QAAQ;AAAA,EACrC,GAAG,CAAC,WAAW,CAAC;AAMhB,SAAO;AAAA,IACL,MAAM,MAAM;AAAA,IACZ,SAAS,MAAM;AAAA,IACf,OAAO,MAAM;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC9TA,IAAAA,gBAA4B;AAC5B,IAAAC,gBAA8B;AAMvB,IAAM,sBAAsB,MAAM;AACvC,QAAM,sBAAkB,2BAAY,CAAC,UAAe;AAClD,YAAQ,MAAM,kCAAkC,KAAK;AAGrD,QACE,OAAO,SAAS,SAAS,yBAAyB,KAClD,OAAO,SAAS,SAAS,cAAc,KACvC,OAAO,SAAS,SAAS,eAAe,KACxC,OAAO,SAAS,SAAS,eAAe,KACxC,OAAO,WAAW,KAClB;AACA,cAAQ,IAAI,2DAAoD;AAGhE,uCAAc;AAGd,UAAI,OAAO,WAAW,aAAa;AAAA,MAEnC;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,SAAO,EAAE,gBAAgB;AAC3B;;;AC9BA,IAAAC,gBAA4B;;;ACA5B,IAAAC,gBAAiD;AA8C1C,SAAS,0BACd,UAA4C,CAAC,GACrB;AACxB,QAAM,EAAE,gBAAgB,IAAI,KAAK,IAAK,IAAI;AAC1C,QAAM,EAAE,KAAK,IAAI,QAAQ;AAEzB,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAS,IAAI;AAC3C,QAAM,CAAC,uBAAuB,wBAAwB,QAAI,wBAAS,KAAK;AACxE,QAAM,CAAC,WAAW,YAAY,QAAI,wBAAS,KAAK;AAChD,QAAM,CAAC,gBAAgB,iBAAiB,QAAI,wBAAS,KAAK;AAC1D,QAAM,CAAC,iBAAiB,kBAAkB,QAAI,wBAAwB,IAAI;AAC1E,QAAM,CAAC,kBAAkB,mBAAmB,QAAI,wBAAwB,IAAI;AAG5E,QAAM,CAAC,iBAAiB,kBAAkB,QAAI,wBAAS,KAAK;AAC5D,QAAM,CAAC,cAAc,eAAe,QAAI,wBAAc,IAAI;AAC1D,QAAM,CAAC,QAAQ,SAAS,QAAI,wBAAiB,EAAE;AAC/C,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAS,KAAK;AAC5C,QAAM,CAAC,UAAU,WAAW,QAAI,wBAAS,KAAK;AAC9C,QAAM,CAAC,UAAU,WAAW,QAAI,wBAAiB,EAAE;AACnD,QAAM,CAAC,OAAO,QAAQ,QAAI,wBAAwB,IAAI;AAGtD,QAAM,8BAA0B,2BAAY,YAAY;AACtD,QAAI,CAAC,MAAM;AACT,iBAAW,KAAK;AAChB;AAAA,IACF;AAEA,QAAI;AACF,iBAAW,IAAI;AAGf,YAAM,EAAE,iBAAiB,IAAI,MAAM,OAAO,mBAAmB;AAC7D,YAAM,WAAW,MAAM,iBAAiB,iCAAiC;AAEzE,UAAI,SAAS,WAAW,SAAS,MAAM;AACrC,cAAM,OAAO,SAAS;AAiBtB,cAAM,iBAAiB,KAAK,UAAU;AACtC,cAAM,eAAe,KAAK,aAAa;AACvC,cAAM,mBAAmB,KAAK,iBAAiB;AAC/C,cAAM,oBAAoB,KAAK,kBAAkB;AAGjD,cAAMC,YAAW,mBAAmB;AACpC,cAAMC,aAAY,mBAAmB;AACrC,cAAMC,WAAU,mBAAmB;AACnC,cAAM,aAAa,mBAAmB;AACtC,cAAM,YAAY,mBAAmB;AACrC,cAAM,WAAW,mBAAmB;AAGpC,cAAM,YAAY;AAGlB,iCAAyB,SAAS;AAClC,qBAAaD,UAAS;AACtB,0BAAkB,iBAAiB;AACnC,2BAAmB,gBAAgB;AACnC,4BAAoB,KAAK,YAAY,cAAc;AAGnD,2BAAmB,IAAI;AACvB,wBAAgB,IAAI;AACpB,kBAAU,cAAc;AACxB,mBAAWC,QAAO;AAClB,oBAAYF,SAAQ;AACpB,oBAAY,KAAK,YAAY,cAAc;AAC3C,iBAAS,IAAI;AAEb,gBAAQ,IAAI,sCAAiC;AAAA,UAC3C;AAAA,UACA,WAAW;AAAA,UACX,eAAe;AAAA,UACf,gBAAgB;AAAA,UAChB,cAAc,KAAK;AAAA,QACrB,CAAC;AAAA,MAEH,OAAO;AAEL,iCAAyB,KAAK;AAC9B,qBAAa,IAAI;AACjB,0BAAkB,KAAK;AACvB,2BAAmB,IAAI;AACvB,4BAAoB,IAAI;AAGxB,2BAAmB,KAAK;AACxB,wBAAgB,IAAI;AACpB,kBAAU,iBAAiB;AAC3B,mBAAW,KAAK;AAChB,oBAAY,KAAK;AACjB,oBAAY,EAAE;AACd,iBAAS,uBAAuB;AAAA,MAClC;AAAA,IAEF,SAASG,QAAO;AACd,cAAQ,MAAM,uCAAuCA,MAAK;AAC1D,+BAAyB,KAAK;AAC9B,mBAAa,IAAI;AACjB,wBAAkB,KAAK;AACvB,yBAAmB,IAAI;AACvB,0BAAoB,IAAI;AAGxB,yBAAmB,KAAK;AACxB,sBAAgB,IAAI;AACpB,gBAAU,OAAO;AACjB,iBAAW,KAAK;AAChB,kBAAY,KAAK;AACjB,kBAAY,EAAE;AACd,eAASA,kBAAiB,QAAQA,OAAM,UAAU,8BAA8B;AAAA,IAClF,UAAE;AACA,iBAAW,KAAK;AAAA,IAClB;AAAA,EACF,GAAG,CAAC,IAAI,CAAC;AAGT,QAAM,uBAAmB,2BAAY,CAAC,YAA6B;AACjE,QAAI,CAAC,yBAAyB,WAAW;AACvC,aAAO;AAAA,IACT;AAIA,WAAO;AAAA,EACT,GAAG,CAAC,uBAAuB,SAAS,CAAC;AAGrC,QAAM,oBAAgB,2BAAY,YAAY;AAC5C,UAAM,wBAAwB;AAAA,EAChC,GAAG,CAAC,uBAAuB,CAAC;AAG5B,+BAAU,MAAM;AACd,4BAAwB;AAAA,EAC1B,GAAG,CAAC,uBAAuB,CAAC;AAG5B,+BAAU,MAAM;AACd,QAAI,CAAC;AAAM;AAEX,UAAM,WAAW,YAAY,yBAAyB,aAAa;AACnE,WAAO,MAAM,cAAc,QAAQ;AAAA,EACrC,GAAG,CAAC,MAAM,yBAAyB,aAAa,CAAC;AAIjD,QAAM,gBAAgB,cAAc,iBACd,YAAY,yBACZ,iBAAiB,cAAc,eAAe,UAC9C,UAAU,UAAU,eAAe,gBACnC,WAAW,wBAAwB;AAGzD,QAAM,cAAc,WAAW,YAAY,QACxB,WAAW,aAAa,QACxB,WAAW,aAAa,WACxB,WAAW,WAAW,WACtB,iBAAiB,WACjB,WAAW,UAAU,WACrB,WAAW,WAAW,UAAU;AAGnD,QAAM,YAAY,cAAc,cAAc,yBAAyB,CAAC;AAExE,QAAM,cAAc,WAAW,aAAa,WAAW,aAAa,WACjD,WAAW,aAAa,aACxB,WAAW,WAAW,aACtB,WAAW,UAAU,YACrB,WAAW,WAAW,SAAS;AAElD,QAAM,kBAAkB,WAAW,aAAa,WAAW,cAAc;AACzE,QAAM,kBAAkB,WAAW,aAAa,WAAW;AAC3D,QAAM,kBAAkB,kBAAkB,kBAAkB,IAAI,KAAK,KAAK,IAAI,IAAI,kBAAkB,KAAK,KAAK,KAAK,GAAI,IAAI;AAC3H,QAAM,gBAAgB;AACtB,QAAM,eAAe,CAAC,aAAa,WAAW,WAAW,WAAW;AACpE,QAAM,aAAa,WAAW,aAAa,WAAW,cAAc,WAAW;AAC/E,QAAM,YAAY,WAAW;AAC7B,QAAM,WAAW,WAAW,aAAa,WAAW,cAAc,CAAC;AAEnE,SAAO;AAAA;AAAA,IAEL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA,IAGA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ADpPO,SAAS,cAAc,QAA6B;AACzD,QAAM,EAAE,KAAK,IAAI,QAAQ;AACzB,QAAM,EAAE,uBAAuB,WAAW,iBAAiB,IAAI,0BAA0B;AAEzF,QAAM,sBAAkB,2BAAY,CAACC,YAAgC;AAEnE,QAAI,CAAC,MAAM;AACT,aAAO;AAAA,IACT;AAGA,UAAM,oBAA0D;AAAA;AAAA,MAE9D,gBAAgB;AAAA,QACd,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,QAAQ;AAAA,MAC7B;AAAA,MACA,cAAc;AAAA,QACZ,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,QAAQ;AAAA,MAC7B;AAAA,MACA,gBAAgB;AAAA,QACd,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,QAAQ;AAAA,MAC7B;AAAA;AAAA,MAGA,mBAAmB;AAAA,QACjB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,WAAW;AAAA,MAChC;AAAA,MACA,iBAAiB;AAAA,QACf,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,WAAW;AAAA,MAChC;AAAA,MACA,mBAAmB;AAAA,QACjB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,WAAW;AAAA,MAChC;AAAA;AAAA,MAGA,kBAAkB;AAAA,QAChB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,UAAU;AAAA,MAC/B;AAAA,MACA,gBAAgB;AAAA,QACd,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,UAAU;AAAA,MAC/B;AAAA,MACA,kBAAkB;AAAA,QAChB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,UAAU;AAAA,MAC/B;AAAA;AAAA,MAGA,kBAAkB;AAAA,QAChB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,WAAW;AAAA,MAChC;AAAA,MACA,eAAe;AAAA,QACb,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,aAAa,QAAQ;AAAA,MAC1C;AAAA;AAAA,MAGA,gBAAgB;AAAA,QACd,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,cAAc,CAAC,SAAS,YAAY,cAAc;AAAA,MACpD;AAAA;AAAA,MAGA,mBAAmB;AAAA,QACjB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,cAAc,CAAC,SAAS,UAAU;AAAA,MACpC;AAAA;AAAA,MAGA,mBAAmB;AAAA,QACjB,QAAQ;AAAA,QACR,sBAAsB;AAAA,QACtB,kBAAkB,CAAC,iBAAiB;AAAA,MACtC;AAAA,IACF;AAEA,UAAM,aAAa,kBAAkBA,OAAM;AAG3C,QAAI,CAAC,YAAY;AACf,aAAO;AAAA,IACT;AAGA,QAAI,WAAW,sBAAsB;AACnC,UAAI,CAAC,yBAAyB,WAAW;AACvC,eAAO;AAAA,MACT;AAAA,IACF;AAGA,QAAI,WAAW,kBAAkB;AAC/B,iBAAW,WAAW,WAAW,kBAAkB;AACjD,YAAI,CAAC,iBAAiB,OAAO,GAAG;AAC9B,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAGA,QAAI,WAAW,cAAc;AAC3B,UAAI,CAAC,WAAW,aAAa,SAAS,KAAK,IAAI,GAAG;AAChD,eAAO;AAAA,MACT;AAAA,IACF;AAGA,QAAI,WAAW,aAAa;AAC1B,aAAO,WAAW,YAAY,MAAM,EAAE,uBAAuB,UAAU,CAAC;AAAA,IAC1E;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,MAAM,uBAAuB,WAAW,gBAAgB,CAAC;AAE7D,SAAO,gBAAgB,MAAM;AAC/B;;;AErKA,IAAAC,gBAAuF;AAMvF,IAAAC,gBAIO;AAuBP,IAAM,sBAAkB,6BAA+C,MAAS;AAYzE,SAAS,iBAAiB;AAAA,EAC/B;AAAA,EACA,kBAAkB,CAAC;AACrB,GAA0B;AAExB,QAAM,CAAC,UAAU,WAAW,QAAI,wBAA2B;AAAA,IACzD,GAAG;AAAA,IACH,GAAG;AAAA,EACL,CAAC;AAGD,QAAM,sBAAkB,kCAAmB,QAAQ;AAGnD,QAAM,kBAAc,2BAAY,CAAC,iBAA+B;AAC9D,gBAAY,WAAS;AAAA,MACnB,GAAG;AAAA,MACH,iBAAiB;AAAA,IACnB,EAAE;AAGF,iBAAa,QAAQ,uBAAuB,YAAY;AAAA,EAC1D,GAAG,CAAC,CAAC;AAGL,QAAM,mBAAe,2BAAY,MAAM;AACrC,gBAAY,WAAS;AAAA,MACnB,GAAG;AAAA,MACH,YAAY,CAAC,KAAK;AAAA,IACpB,EAAE;AAGF,iBAAa,QAAQ,2BAA2B,CAAC,SAAS,YAAY,SAAS,CAAC;AAAA,EAClF,GAAG,CAAC,SAAS,UAAU,CAAC;AAGxB,QAAM,iBAAa,2BAAY,MAAM;AACnC,gBAAY,WAAS;AAAA,MACnB,GAAG;AAAA,MACH,UAAU,CAAC,KAAK;AAAA,IAClB,EAAE;AAGF,iBAAa,QAAQ,yBAAyB,CAAC,SAAS,UAAU,SAAS,CAAC;AAAA,EAC9E,GAAG,CAAC,SAAS,QAAQ,CAAC;AAGtB,QAAM,wBAAoB,2BAAY,CAAC,SAAuB;AAC5D,eAAO,2BAAY,IAAI;AAAA,EACzB,GAAG,CAAC,CAAC;AAGL,QAAM,oBAAgB,2BAAY,CAAC,QAAgB,MAAoB,OAAqB;AAC1F,QAAI,SAAS;AAAI,aAAO;AAExB,UAAM,mBAAe,2BAAY,IAAI;AACrC,UAAM,iBAAa,2BAAY,EAAE;AAEjC,QAAI,CAAC,gBAAgB,CAAC,YAAY;AAChC,YAAM,IAAI,MAAM,0BAA0B,IAAI,OAAO,EAAE,EAAE;AAAA,IAC3D;AAGA,UAAM,cAAc,SAAS,aAAa;AAC1C,WAAO,cAAc,WAAW;AAAA,EAClC,GAAG,CAAC,CAAC;AAGL,+BAAU,MAAM;AACd,QAAI;AACF,YAAM,gBAAgB,aAAa,QAAQ,qBAAqB;AAChE,YAAM,kBAAkB,aAAa,QAAQ,wBAAwB;AACrE,YAAM,gBAAgB,aAAa,QAAQ,sBAAsB;AAEjE,UAAI,iBAAiB,oBAAoB,aAAa,GAAG;AACvD,oBAAY,WAAS,EAAE,GAAG,MAAM,iBAAiB,cAAc,EAAE;AAAA,MACnE;AAEA,UAAI,oBAAoB,MAAM;AAC5B,oBAAY,WAAS,EAAE,GAAG,MAAM,YAAY,oBAAoB,OAAO,EAAE;AAAA,MAC3E;AAEA,UAAI,kBAAkB,MAAM;AAC1B,oBAAY,WAAS,EAAE,GAAG,MAAM,UAAU,kBAAkB,OAAO,EAAE;AAAA,MACvE;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,KAAK,uDAAuD,KAAK;AAAA,IAC3E;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,eAAoC;AAAA,IACxC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SACE,oCAAC,gBAAgB,UAAhB,EAAyB,OAAO,gBAC9B,QACH;AAEJ;AAMO,SAAS,cAAmC;AACjD,QAAM,cAAU,0BAAW,eAAe;AAE1C,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AAEA,SAAO;AACT;AAMA,SAAS,oBAAoB,MAAoC;AAC/D,SAAO,CAAC,OAAO,KAAK,EAAE,SAAS,IAAoB;AACrD;;;AChLA,IAAAC,gBAA4C;AAC5C,IAAAC,gBAA6B;AAyCtB,SAAS,iBAAiB,SAA0D;AACzF,QAAM,EAAE,SAAS,UAAU,MAAM,iBAAiB,MAAM,aAAa,IAAI,IAAI;AAE7E,QAAM,CAAC,MAAM,OAAO,QAAI,wBAAuC,IAAI;AACnE,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAS,IAAI;AAC3C,QAAM,CAAC,OAAO,QAAQ,QAAI,wBAAuB,IAAI;AACrD,QAAM,yBAAqB,sBAA+B,IAAI;AAC9D,QAAM,wBAAoB,sBAAO,CAAC;AAGlC,QAAM,UAAU,MAAM;AACpB,sBAAkB,WAAW;AAAA,EAC/B;AAEA,+BAAU,MAAM;AACd,QAAI,CAAC;AAAS;AAGd,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AAAA,IACnC;AACA,uBAAmB,UAAU,IAAI,gBAAgB;AAEjD,UAAM,YAAY,YAAY;AAC5B,UAAI;AACF,mBAAW,IAAI;AACf,iBAAS,IAAI;AAEb,gBAAQ,IAAI,sDAA+C,OAAO;AAElE,cAAM,WAAW,MAAM,2BAAa,gBAAgB,OAAO;AAG3D,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AAEA,YAAI,SAAS,WAAW,SAAS,MAAM;AAErC,gBAAM,UAAU,SAAS;AACzB,gBAAM,gBAAgB,QAAQ,aAAa,CAAC;AAC5C,gBAAM,QAAQ,QAAQ,SAAS;AAC/B,gBAAM,QAAQ,QAAQ,SAAS,QAAQ,SAAS;AAChD,gBAAM,cAAc,QAAQ,QAAQ,QAAQ,QAAQ;AACpD,gBAAM,aAAa,QAAQ,cAAc,KAAK,KAAK,QAAQ,KAAK;AAChE,gBAAM,UAAU,QAAQ,YAAY,SAAY,QAAQ,UAAU,cAAc;AAEhF,kBAAQ;AAAA,YACN,WAAW;AAAA,YACX;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACH,OAAO;AACL,gBAAM,IAAI,MAAM,2BAA2B;AAAA,QAC7C;AAAA,MACF,SAAS,KAAK;AACZ,YAAK,IAAc,SAAS,cAAc;AACxC,kBAAQ,MAAM,yDAAkD,GAAG;AACnE,mBAAS,GAAY;AAAA,QACvB;AAAA,MACF,UAAE;AACA,YAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS;AAC/C,qBAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,mBAAmB,QAAQ,UAAU,QAAQ,IAAI;AACnD,cAAQ,IAAI,qDAA8C;AAC1D,YAAM,QAAQ,WAAW,WAAW,UAAU;AAC9C,aAAO,MAAM;AACX,qBAAa,KAAK;AAClB,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF,OAAO;AAEL,gBAAU;AACV,aAAO,MAAM;AACX,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG;AAAA,IACD;AAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,EACpB,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC7IA,IAAAC,gBAA4C;AAC5C,IAAAC,gBAA0B;AAyCnB,SAAS,cAAc,SAAoD;AAChF,QAAM,EAAE,SAAS,UAAU,MAAM,iBAAiB,MAAM,aAAa,IAAI,IAAI;AAE7E,QAAM,CAAC,MAAM,OAAO,QAAI,wBAAoC,IAAI;AAChE,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAS,IAAI;AAC3C,QAAM,CAAC,OAAO,QAAQ,QAAI,wBAAuB,IAAI;AACrD,QAAM,yBAAqB,sBAA+B,IAAI;AAC9D,QAAM,wBAAoB,sBAAO,CAAC;AAGlC,QAAM,UAAU,MAAM;AACpB,sBAAkB,WAAW;AAAA,EAC/B;AAEA,+BAAU,MAAM;AACd,QAAI,CAAC;AAAS;AAGd,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AAAA,IACnC;AACA,uBAAmB,UAAU,IAAI,gBAAgB;AAEjD,UAAM,YAAY,YAAY;AAC5B,UAAI;AACF,mBAAW,IAAI;AACf,iBAAS,IAAI;AAEb,gBAAQ,IAAI,mDAA4C,OAAO;AAE/D,cAAM,WAAW,MAAM,wBAAU,aAAa,OAAO;AAGrD,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AAEA,YAAI,SAAS,WAAW,SAAS,MAAM;AACrC,gBAAM,aAAa,SAAS,KAAK,UAAU,CAAC;AAC5C,gBAAM,QAAQ,SAAS,KAAK,SAAS;AACrC,gBAAM,QAAQ,QAAQ,SAAS;AAC/B,gBAAM,cAAc,QAAQ,QAAQ;AACpC,gBAAM,aAAa,KAAK,KAAK,QAAQ,KAAK;AAE1C,kBAAQ;AAAA,YACN,QAAQ;AAAA,YACR;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,SAAS,cAAc;AAAA,UACzB,CAAC;AAAA,QACH,OAAO;AACL,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC1C;AAAA,MACF,SAAS,KAAK;AACZ,YAAK,IAAc,SAAS,cAAc;AACxC,kBAAQ,MAAM,mDAA4C,GAAG;AAC7D,mBAAS,GAAY;AAAA,QACvB;AAAA,MACF,UAAE;AACA,YAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS;AAC/C,qBAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,kBAAkB,QAAQ,QAAQ;AACpC,cAAQ,IAAI,kDAA2C;AACvD,YAAM,QAAQ,WAAW,WAAW,UAAU;AAC9C,aAAO,MAAM;AACX,qBAAa,KAAK;AAClB,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF,OAAO;AAEL,gBAAU;AACV,aAAO,MAAM;AACX,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG;AAAA,IACD;AAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,EACpB,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC1IA,IAAAC,gBAA4C;AAC5C,IAAAC,gBAA2B;AAyCpB,SAAS,eAAe,SAAsD;AACnF,QAAM,EAAE,SAAS,UAAU,MAAM,iBAAiB,MAAM,aAAa,IAAI,IAAI;AAE7E,QAAM,CAAC,MAAM,OAAO,QAAI,wBAAqC,IAAI;AACjE,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAS,IAAI;AAC3C,QAAM,CAAC,OAAO,QAAQ,QAAI,wBAAuB,IAAI;AACrD,QAAM,yBAAqB,sBAA+B,IAAI;AAC9D,QAAM,wBAAoB,sBAAO,CAAC;AAElC,QAAM,UAAU,MAAM;AACpB,sBAAkB,WAAW;AAAA,EAC/B;AAEA,+BAAU,MAAM;AACd,QAAI,CAAC;AAAS;AAEd,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AAAA,IACnC;AACA,uBAAmB,UAAU,IAAI,gBAAgB;AAEjD,UAAM,YAAY,YAAY;AAC5B,UAAI;AACF,mBAAW,IAAI;AACf,iBAAS,IAAI;AAEb,gBAAQ,IAAI,oDAA6C,OAAO;AAEhE,cAAM,WAAW,MAAM,yBAAW,cAAc,OAAO;AAEvD,gBAAQ,IAAI,2CAAoC,QAAQ;AACxD,gBAAQ,IAAI,4CAAqC,SAAS,IAAI;AAE9D,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AAEA,YAAI,SAAS,WAAW,SAAS,MAAM;AACrC,gBAAM,UAAU,SAAS;AAGzB,cAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,kBAAM,aAAc,SAAiB,cAAc,CAAC;AACpD,kBAAM,cAAc;AACpB,kBAAM,QAAQ,WAAW,SAAS,QAAQ;AAC1C,kBAAM,QAAQ,WAAW,SAAS,QAAQ,SAAS;AACnD,kBAAM,cAAc,WAAW,QAAQ,QAAQ,QAAQ;AACvD,kBAAM,aAAa,KAAK,KAAK,QAAQ,KAAK;AAC1C,kBAAM,UAAU,WAAW,YAAY,SAAY,WAAW,UAAU,cAAc;AAEtF,oBAAQ;AAAA,cACN,SAAS;AAAA,cACT;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AACL,kBAAM,cAAc,QAAQ,WAAW,CAAC;AACxC,kBAAM,QAAQ,QAAQ,SAAS;AAC/B,kBAAM,QAAQ,QAAQ,SAAS,QAAQ,SAAS;AAChD,kBAAM,cAAc,QAAQ,QAAQ,QAAQ,QAAQ;AACpD,kBAAM,aAAa,QAAQ,cAAc,KAAK,KAAK,QAAQ,KAAK;AAChE,kBAAM,UAAU,QAAQ,YAAY,SAAY,QAAQ,UAAU,cAAc;AAEhF,oBAAQ;AAAA,cACN,SAAS;AAAA,cACT;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,OAAO;AACL,gBAAM,IAAI,MAAM,yBAAyB;AAAA,QAC3C;AAAA,MACF,SAAS,KAAK;AACZ,YAAK,IAAc,SAAS,cAAc;AACxC,kBAAQ,MAAM,qDAA8C,GAAG;AAC/D,mBAAS,GAAY;AAAA,QACvB;AAAA,MACF,UAAE;AACA,YAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS;AAC/C,qBAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAEA,QAAI,mBAAmB,QAAQ,UAAU,QAAQ,IAAI;AACnD,cAAQ,IAAI,mDAA4C;AACxD,YAAM,QAAQ,WAAW,WAAW,UAAU;AAC9C,aAAO,MAAM;AACX,qBAAa,KAAK;AAClB,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF,OAAO;AACL,gBAAU;AACV,aAAO,MAAM;AACX,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,EACpB,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACjKA,IAAAC,gBAA4C;AAC5C,IAAAC,gBAA8B;AA8BvB,SAAS,kBAAkB,SAA4D;AAC5F,QAAM,EAAE,SAAS,UAAU,MAAM,iBAAiB,OAAO,aAAa,IAAI,IAAI;AAE9E,QAAM,CAAC,MAAM,OAAO,QAAI,wBAAwC,IAAI;AACpE,QAAM,CAAC,SAAS,UAAU,QAAI,wBAAkB,KAAK;AACrD,QAAM,CAAC,OAAO,QAAQ,QAAI,wBAAwB,IAAI;AAEtD,QAAM,yBAAqB,sBAA+B,IAAI;AAC9D,QAAM,wBAAoB,sBAAe,CAAC;AAC1C,QAAM,wBAAoB,sBAA8B,IAAI;AAE5D,QAAM,UAAU,MAAM;AACpB,sBAAkB,WAAW;AAAA,EAC/B;AAEA,+BAAU,MAAM;AACd,QAAI,CAAC;AAAS;AAEd,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AAAA,IACnC;AACA,uBAAmB,UAAU,IAAI,gBAAgB;AAEjD,UAAM,YAAY,YAAY;AAC5B,UAAI;AACF,mBAAW,IAAI;AACf,iBAAS,IAAI;AAEb,gBAAQ,IAAI,uDAAgD,OAAO;AAEnE,cAAM,WAAW,MAAM,4BAAc,iBAAiB,OAAO;AAE7D,gBAAQ,IAAI,8CAAuC,QAAQ;AAC3D,gBAAQ,IAAI,+CAAwC,SAAS,IAAI;AAEjE,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AAEA,YAAI,SAAS,WAAW,SAAS,MAAM;AACrC,gBAAM,UAAU,SAAS;AAGzB,cAAI,MAAM,QAAQ,OAAO,GAAG;AAC1B,kBAAM,aAAc,SAAiB,cAAc,CAAC;AACpD,kBAAM,iBAAiB;AACvB,kBAAM,QAAQ,WAAW,SAAS,QAAQ;AAC1C,kBAAM,QAAQ,WAAW,SAAS,QAAQ,SAAS;AACnD,kBAAM,cAAc,WAAW,QAAQ,QAAQ,QAAQ;AACvD,kBAAM,aAAa,KAAK,KAAK,QAAQ,KAAK;AAC1C,kBAAM,UAAU,WAAW,YAAY,SAAY,WAAW,UAAU,cAAc;AAEtF,oBAAQ;AAAA,cACN,YAAY;AAAA,cACZ;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AACL,kBAAM,iBAAiB,QAAQ,cAAc,CAAC;AAC9C,kBAAM,QAAQ,QAAQ,SAAS;AAC/B,kBAAM,QAAQ,QAAQ,SAAS,QAAQ,SAAS;AAChD,kBAAM,cAAc,QAAQ,QAAQ,QAAQ,QAAQ;AACpD,kBAAM,aAAa,QAAQ,cAAc,KAAK,KAAK,QAAQ,KAAK;AAChE,kBAAM,UAAU,QAAQ,YAAY,SAAY,QAAQ,UAAU,cAAc;AAEhF,oBAAQ;AAAA,cACN,YAAY;AAAA,cACZ;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,OAAO;AACL,gBAAM,IAAI,MAAM,SAAS,WAAW,4BAA4B;AAAA,QAClE;AAAA,MACF,SAAS,KAAU;AACjB,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AACA,gBAAQ,MAAM,iDAAiD,GAAG;AAClE,iBAAS,IAAI,WAAW,4BAA4B;AACpD,gBAAQ,IAAI;AAAA,MACd,UAAE;AACA,YAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS;AAC/C,qBAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAGA,UAAM,iBAAiB,mBAAmB,QAAQ,KAAK,QAAQ;AAE/D,QAAI,gBAAgB;AAClB,cAAQ,IAAI,sDAA+C;AAC3D,UAAI,kBAAkB,SAAS;AAC7B,qBAAa,kBAAkB,OAAO;AAAA,MACxC;AACA,wBAAkB,UAAU,WAAW,MAAM;AAC3C,kBAAU;AAAA,MACZ,GAAG,UAAU;AAAA,IACf,OAAO;AACL,gBAAU;AAAA,IACZ;AAEA,WAAO,MAAM;AACX,UAAI,mBAAmB,SAAS;AAC9B,2BAAmB,QAAQ,MAAM;AAAA,MACnC;AACA,UAAI,kBAAkB,SAAS;AAC7B,qBAAa,kBAAkB,OAAO;AAAA,MACxC;AAAA,IACF;AAAA,EACF,GAAG,CAAC,SAAS,SAAS,gBAAgB,YAAY,kBAAkB,OAAO,CAAC;AAE5E,SAAO,EAAE,MAAM,SAAS,OAAO,QAAQ;AACzC;;;ACrJA,IAAAC,iBAAsC;AACtC,uBAA2B;AA6BpB,SAAS,cAAc,SAA2B,CAAC,GAAwB;AAChF,QAAM,EAAE,eAAe,4BAAW,mBAAmB,gBAAgB,EAAE,IAAI;AAE3E,QAAM,CAAC,YAAY,kBAAkB,QAAI,yBAA0B;AAAA,IACjE,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,aAAa;AAAA,IACb,YAAY;AAAA,EACd,CAAC;AAED,QAAM,oBAAgB,4BAAY,CAAC,kBAA4C;AAC7E,uBAAmB,WAAS;AAAA,MAC1B,GAAG;AAAA,MACH,GAAG;AAAA,MACH,aAAa,KAAK,OAAO,cAAc,UAAU,KAAK,WAAW,cAAc,SAAS,KAAK,MAAM,IAAI;AAAA,MACvG,YAAY,KAAK,MAAM,cAAc,SAAS,KAAK,UAAU,cAAc,SAAS,KAAK,MAAM;AAAA,IACjG,EAAE;AAAA,EACJ,GAAG,CAAC,CAAC;AAEL,QAAM,uBAAmB,4BAAY,CAAC,SAAiB;AACrD,UAAM,aAAa,OAAO,KAAK,WAAW;AAC1C,kBAAc;AAAA,MACZ,QAAQ;AAAA,MACR,aAAa;AAAA,IACf,CAAC;AAAA,EACH,GAAG,CAAC,WAAW,OAAO,aAAa,CAAC;AAIpC,QAAM,sBAAkB,4BAAY,MAAM;AACxC,kBAAc;AAAA,MACZ,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,SAAS;AAAA,MACT,aAAa;AAAA,MACb,YAAY;AAAA,IACd,CAAC;AAAA,EACH,GAAG,CAAC,eAAe,aAAa,CAAC;AAEjC,QAAM,mCAA+B,4BAAY,CAAC,aAK5C;AACJ,kBAAc;AAAA,MACZ,OAAO,SAAS;AAAA,MAChB,OAAO,SAAS;AAAA,MAChB,QAAQ,SAAS;AAAA,MACjB,SAAS,SAAS,WAAY,SAAS,SAAS,SAAS,QAAQ,SAAS;AAAA,MAC1E,aAAa,KAAK,MAAM,SAAS,SAAS,SAAS,KAAK,IAAI;AAAA,MAC5D,YAAY,KAAK,KAAK,SAAS,QAAQ,SAAS,KAAK;AAAA,IACvD,CAAC;AAAA,EACH,GAAG,CAAC,aAAa,CAAC;AAElB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC9FA,IAAAC,iBAA4B;AAiCrB,SAAS,yBAAyB;AAKvC,QAAM,4BAAwB,4BAAY,CACxC,SACA,YACA,YACA,mBACA,iBAA0B,CAAC,MACJ;AAEvB,UAAM,SAAS,IAAI,KAAK,UAAU;AAClC,UAAM,UAAU,IAAI,KAAK,UAAU;AAGnC,QAAI,UAAU,SAAS;AACrB,aAAO;AAAA,QACL,WAAW;AAAA,QACX,mBAAmB;AAAA,QACnB,WAAW,CAAC;AAAA,QACZ,SAAS;AAAA,MACX;AAAA,IACF;AAGA,UAAM,YAAY,eAAe,OAAO,WAAS;AAE/C,UAAI,MAAM,cAAc;AAAQ,eAAO;AAGvC,YAAM,iBAAiB,CAAC,YAAY,UAAU;AAC9C,UAAI,CAAC,eAAe,SAAS,MAAM,MAAM;AAAG,eAAO;AAGnD,YAAM,aAAa,MAAM,WAAW,KAAK,UAAQ,KAAK,cAAc,QAAQ,EAAE;AAC9E,UAAI,CAAC;AAAY,eAAO;AAGxB,YAAM,cAAc,IAAI,KAAK,MAAM,YAAY;AAC/C,YAAM,cAAc,IAAI,KAAK,MAAM,YAAY;AAG/C,aACG,UAAU,eAAe,WAAW,eACpC,eAAe,WAAW,eAAe;AAAA,IAE9C,CAAC;AAGD,UAAM,sBAAsB,UAAU,OAAO,CAAC,OAAO,UAAU;AAC7D,YAAM,YAAY,MAAM,WAAW,KAAK,UAAQ,KAAK,cAAc,QAAQ,EAAE;AAC7E,aAAO,SAAS,WAAW,YAAY;AAAA,IACzC,GAAG,CAAC;AAGJ,UAAM,oBAAoB,KAAK,IAAI,GAAG,QAAQ,YAAY,mBAAmB;AAC7E,UAAM,YAAY,qBAAqB;AAGvC,QAAI,UAAU;AACd,QAAI,WAAW;AACb,gBAAU,cAAc,iBAAiB;AAAA,IAC3C,OAAO;AACL,gBAAU,QAAQ,iBAAiB,gCAAgC,iBAAiB;AAAA,IACtF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAML,QAAM,yBAAqB,4BAAY,CACrC,SACA,YACA,YACA,mBACA,iBAA0B,CAAC,MACf;AACZ,UAAM,SAAS,sBAAsB,SAAS,YAAY,YAAY,mBAAmB,cAAc;AACvG,WAAO,OAAO;AAAA,EAChB,GAAG,CAAC,qBAAqB,CAAC;AAM1B,QAAM,kCAA8B,4BAAY,CAC9C,SACA,WACA,SACA,iBAA0B,CAAC,MACwC;AACnE,UAAM,QAAQ,IAAI,KAAK,SAAS;AAChC,UAAM,MAAM,IAAI,KAAK,OAAO;AAC5B,UAAM,UAAU,CAAC;AAGjB,aAAS,OAAO,IAAI,KAAK,KAAK,GAAG,QAAQ,KAAK,KAAK,QAAQ,KAAK,QAAQ,IAAI,CAAC,GAAG;AAC9E,YAAM,UAAU,KAAK,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AAC/C,YAAM,SAAS;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,cAAQ,KAAK;AAAA,QACX,MAAM;AAAA,QACN,WAAW,OAAO;AAAA,QAClB,WAAW,OAAO;AAAA,MACpB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,qBAAqB,CAAC;AAM1B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACxKA,IAAAC,iBAA4C;AAC5C,IAAAC,gBAA4B;AAyCrB,SAAS,gBAAgB,SAAwD;AACtF,QAAM,EAAE,SAAS,UAAU,MAAM,iBAAiB,MAAM,aAAa,IAAI,IAAI;AAE7E,QAAM,CAAC,MAAM,OAAO,QAAI,yBAAsC,IAAI;AAClE,QAAM,CAAC,SAAS,UAAU,QAAI,yBAAS,IAAI;AAC3C,QAAM,CAAC,OAAO,QAAQ,QAAI,yBAAuB,IAAI;AACrD,QAAM,yBAAqB,uBAA+B,IAAI;AAC9D,QAAM,wBAAoB,uBAAO,CAAC;AAGlC,QAAM,UAAU,MAAM;AACpB,sBAAkB,WAAW;AAAA,EAC/B;AAEA,gCAAU,MAAM;AACd,QAAI,CAAC;AAAS;AAGd,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AAAA,IACnC;AACA,uBAAmB,UAAU,IAAI,gBAAgB;AAEjD,UAAM,YAAY,YAAY;AAC5B,UAAI;AACF,mBAAW,IAAI;AACf,iBAAS,IAAI;AAEb,gBAAQ,IAAI,qDAA8C,OAAO;AAEjE,cAAM,WAAW,MAAM,0BAAY,eAAe,OAAO;AAGzD,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AAEA,YAAI,SAAS,WAAW,SAAS,MAAM;AAErC,gBAAM,UAAU,SAAS;AACzB,gBAAM,eAAe,QAAQ,YAAY,CAAC;AAC1C,gBAAM,QAAQ,QAAQ,SAAS;AAC/B,gBAAM,QAAQ,QAAQ,SAAS,QAAQ,SAAS;AAChD,gBAAM,cAAc,QAAQ,QAAQ,QAAQ,QAAQ;AACpD,gBAAM,aAAa,QAAQ,cAAc,KAAK,KAAK,QAAQ,KAAK;AAChE,gBAAM,UAAU,QAAQ,YAAY,SAAY,QAAQ,UAAU,cAAc;AAEhF,kBAAQ;AAAA,YACN,UAAU;AAAA,YACV;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF,CAAC;AAAA,QACH,OAAO;AACL,gBAAM,IAAI,MAAM,0BAA0B;AAAA,QAC5C;AAAA,MACF,SAAS,KAAK;AACZ,YAAK,IAAc,SAAS,cAAc;AACxC,kBAAQ,MAAM,uDAAgD,GAAG;AACjE,mBAAS,GAAY;AAAA,QACvB;AAAA,MACF,UAAE;AACA,YAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS;AAC/C,qBAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,mBAAmB,QAAQ,UAAU,QAAQ,IAAI;AACnD,cAAQ,IAAI,oDAA6C;AACzD,YAAM,QAAQ,WAAW,WAAW,UAAU;AAC9C,aAAO,MAAM;AACX,qBAAa,KAAK;AAClB,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF,OAAO;AAEL,gBAAU;AACV,aAAO,MAAM;AACX,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG;AAAA,IACD;AAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,EACpB,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACzIA,IAAAC,iBAAsC;AACtC,gBAA0B;AAoBnB,SAAS,uBAAmD;AACjE,QAAM,CAAC,OAAO,QAAQ,QAAI,yBAAmC,IAAI;AACjE,QAAM,EAAE,SAAS,QAAI,qBAAU;AAE/B,QAAM,8BAA0B,4BAAY,CAACC,WAAe;AAC1D,YAAQ,MAAM,uBAAuBA,MAAK;AAG1C,QAAIA,QAAO,UAAU,wBAAwBA,QAAO,SAAS,yBAAyB;AACpF,YAAM,oBAAuC;AAAA,QAC3C,SAASA,OAAM,WAAW;AAAA,QAC1B,oBAAoBA,OAAM;AAAA,QAC1B,gBAAgBA,OAAM;AAAA,QACtB,MAAMA,OAAM;AAAA,MACd;AAEA,eAAS,iBAAiB;AAC1B,4BAAsB,iBAAiB;AAAA,IACzC,OAAO;AAEL,eAAS,SAAS,SAASA,QAAO,WAAW,mBAAmB;AAAA,IAClE;AAAA,EACF,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,4BAAwB,4BAAY,CAACA,WAA6B;AACtE,UAAM,EAAE,oBAAoB,eAAe,IAAIA;AAE/C,QAAI,UAAUA,OAAM;AACpB,QAAI,SAAS;AAGb,QAAI,uBAAuB,UAAU;AACnC,gBAAU;AACV,eAAS;AAAA,IACX,WAAW,uBAAuB,WAAW;AAC3C,gBAAU;AACV,eAAS;AAAA,IACX,WAAW,uBAAuB,aAAa;AAC7C,gBAAU;AACV,eAAS;AAAA,IACX,WAAW,uBAAuB,YAAY;AAC5C,gBAAU;AACV,eAAS;AAAA,IACX,WAAW,kBAAkB,CAAC,CAAC,QAAQ,EAAE,SAAS,cAAc,GAAG;AACjE,gBAAU,4BAA4B,cAAc;AACpD,eAAS;AAAA,IACX;AAGA,aAAS,SAAS,sBAAsB,SAAS,GAAG,OAAO;AAAA;AAAA,EAAO,MAAM,KAAK,SAAS,GAAI;AAAA,EAC5F,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,iBAAa,4BAAY,MAAM;AACnC,aAAS,IAAI;AAAA,EACf,GAAG,CAAC,CAAC;AAEL,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACvFA,IAAAC,iBAAyD;AAyBlD,SAAS,mBAAmB,SAAwD;AACzF,QAAM,EAAE,OAAO,WAAW,SAAS,IAAI;AAEvC,QAAM,CAAC,OAAO,QAAQ,QAAI,yBAAS,EAAE;AACrC,QAAM,CAAC,aAAa,cAAc,QAAI,yBAAS,KAAK;AACpD,QAAM,iBAAa,uBAA8B,IAAI;AACrD,QAAM,qBAAiB,uBAAO,KAAK;AACnC,QAAM,sBAAkB,uBAAO,IAAI;AAGnC,QAAM,kBAAc,uBAAO,QAAQ;AAGnC,gCAAU,MAAM;AACd,gBAAY,UAAU;AAAA,EACxB,GAAG,CAAC,QAAQ,CAAC;AAMb,QAAM,yBAAqB,4BAAY,CAAC,UAAkB;AACxD,YAAQ,IAAI,iEAA0D,KAAK;AAC3E,aAAS,KAAK;AAGd,QAAI,WAAW,SAAS;AACtB,mBAAa,WAAW,OAAO;AAAA,IACjC;AAGA,QAAI,MAAM,UAAU,WAAW;AAC7B,cAAQ,IAAI,yEAAkE;AAC9E,qBAAe,IAAI;AACnB,qBAAe,UAAU;AAGzB,iBAAW,UAAU,WAAW,MAAM;AACpC,gBAAQ,IAAI,2EAAoE,KAAK;AACrF,oBAAY,QAAQ,KAAK;AACzB,uBAAe,KAAK;AACpB,uBAAe,UAAU;AAAA,MAC3B,GAAG,KAAK;AAAA,IACV,WAAW,MAAM,WAAW,GAAG;AAC7B,cAAQ,IAAI,+DAAwD;AAEpE,qBAAe,KAAK;AACpB,qBAAe,UAAU;AACzB,UAAI,CAAC,gBAAgB,SAAS;AAC5B,oBAAY,QAAQ,EAAE;AAAA,MACxB;AAAA,IACF,OAAO;AACL,cAAQ,IAAI,8DAAuD;AAEnE,qBAAe,KAAK;AACpB,qBAAe,UAAU;AAAA,IAC3B;AAAA,EACF,GAAG,CAAC,OAAO,SAAS,CAAC;AAErB,QAAM,kBAAc,4BAAY,MAAM;AACpC,aAAS,EAAE;AACX,mBAAe,KAAK;AACpB,mBAAe,UAAU;AAEzB,QAAI,WAAW,SAAS;AACtB,mBAAa,WAAW,OAAO;AAAA,IACjC;AAEA,QAAI,CAAC,gBAAgB,SAAS;AAC5B,kBAAY,QAAQ,EAAE;AAAA,IACxB;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,QAAM,cAAU,4BAAY,MAAM;AAChC,QAAI,WAAW,SAAS;AACtB,mBAAa,WAAW,OAAO;AAAA,IACjC;AAAA,EACF,GAAG,CAAC,CAAC;AAML,gCAAU,MAAM;AAEd,oBAAgB,UAAU;AAI1B,WAAO;AAAA,EACT,GAAG,CAAC,OAAO,CAAC;AAMZ,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;ACjIA,IAAAC,iBAAsC;AACtC,IAAAC,gBAMO;AACP,IAAAC,aAA0B;AAqCnB,IAAM,kBAAkB,CAAC,UAAkC,CAAC,MAA6B;AAC9F,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA,iBAAiB;AAAA,EACnB,IAAI;AAEJ,QAAM,CAAC,WAAW,YAAY,QAAI,yBAAS,KAAK;AAChD,QAAM,EAAE,SAAS,QAAI,sBAAU;AAE/B,QAAM,kBAAc,4BAAY,CAAC,UAA0B;AACzD,UAAM,gBAAY,4BAAa,KAAK;AACpC,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAEL,QAAM,qBAAiB,4BAAY,CAAC,UAAe;AACjD,UAAM,gBAAY,4BAAa,KAAK;AACpC,UAAM,gBAAY,4BAAa,UAAU,IAAI;AAG7C,QAAI,eAAe,UAAU;AAE7B,QAAI,UAAU,iBAAiB;AAC7B,UAAI,UAAU,SAAS,QAAQ;AAC7B,wBAAgB;AAAA,MAClB,WAAW,UAAU,SAAS,cAAc;AAC1C,wBAAgB;AAAA,MAClB,WAAW,UAAU,SAAS,gBAAgB;AAC5C,wBAAgB;AAAA,MAClB,OAAO;AACL,wBAAgB;AAAA,MAClB;AAAA,IACF;AAEA,aAAS,WAAW,UAAU,OAAO,cAAc,CAAC;AAAA,EACtD,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,oBAAgB,4BAAY,OAAU,YAA8B;AACxE,iBAAa,IAAI;AAEjB,QAAI;AACF,YAAM,SAAS,UAAM,sCAAuB,OAAO;AAEnD,UAAI,OAAO,OAAO;AAChB,uBAAe,OAAO,KAAK;AAAA,MAC7B;AAEA,aAAO;AAAA,IACT,UAAE;AACA,mBAAa,KAAK;AAAA,IACpB;AAAA,EACF,GAAG,CAAC,cAAc,CAAC;AAEnB,QAAM,YAAQ,4BAAY,MAAM;AAC9B,QAAI,SAAS;AACX,cAAQ;AAAA,IACV;AAAA,EACF,GAAG,CAAC,OAAO,CAAC;AAEZ,QAAM,YAAQ,4BAAY,MAAM;AAC9B,QAAI,SAAS;AACX,cAAQ;AAAA,IACV,WAAW,OAAO,WAAW,aAAa;AAAA,IAG1C;AAAA,EACF,GAAG,CAAC,OAAO,CAAC;AAEZ,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAKO,IAAM,wBAAwB,MAAM;AACzC,QAAM,EAAE,SAAS,QAAI,sBAAU;AAE/B,QAAM,kBAAc,4BAAY,CAAC,UAAe;AAC9C,UAAM,gBAAY,4BAAa,KAAK;AACpC,UAAM,gBAAY,4BAAa,UAAU,IAAI;AAE7C,QAAI,eAAe,UAAU;AAC7B,QAAI,UAAU,iBAAiB;AAC7B,UAAI,UAAU,SAAS,QAAQ;AAC7B,wBAAgB;AAAA,MAClB,WAAW,UAAU,SAAS,cAAc;AAC1C,wBAAgB;AAAA,MAClB,WAAW,UAAU,SAAS,gBAAgB;AAC5C,wBAAgB;AAAA,MAClB,OAAO;AACL,wBAAgB;AAAA,MAClB;AAAA,IACF;AAEA,aAAS,WAAW,UAAU,OAAO,cAAc,CAAC;AACpD,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,CAAC;AAEb,SAAO;AAAA,IACL;AAAA,EACF;AACF;AAMO,IAAM,kBAAkB,MAAM;AACnC,QAAM,EAAE,SAAS,QAAI,sBAAU;AAE/B,QAAM,gBAAY,4BAAY,CAAC,OAAe,YAAqB;AACjE,aAAS,SAAS,OAAO,SAAS,CAAC;AAAA,EACrC,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,kBAAc,4BAAY,CAAC,OAAe,YAAqB;AACnE,aAAS,WAAW,OAAO,SAAS,GAAI;AAAA,EAC1C,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,kBAAc,4BAAY,CAAC,OAAe,YAAqB;AACnE,aAAS,WAAW,OAAO,SAAS,GAAI;AAAA,EAC1C,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,eAAW,4BAAY,CAAC,OAAe,YAAqB;AAChE,aAAS,QAAQ,OAAO,SAAS,GAAI;AAAA,EACvC,GAAG,CAAC,QAAQ,CAAC;AAEb,QAAM,kBAAc,4BAAY,CAAC,UAAe;AAC9C,UAAM,gBAAY,4BAAa,KAAK;AACpC,UAAM,gBAAY,4BAAa,UAAU,IAAI;AAE7C,QAAI,eAAe,UAAU;AAC7B,QAAI,UAAU,iBAAiB;AAC7B,UAAI,UAAU,SAAS,QAAQ;AAC7B,wBAAgB;AAAA,MAClB,WAAW,UAAU,SAAS,cAAc;AAC1C,wBAAgB;AAAA,MAClB,WAAW,UAAU,SAAS,gBAAgB;AAC5C,wBAAgB;AAAA,MAClB,OAAO;AACL,wBAAgB;AAAA,MAClB;AAAA,IACF;AAEA,aAAS,WAAW,UAAU,OAAO,cAAc,CAAC;AACpD,WAAO;AAAA,EACT,GAAG,CAAC,QAAQ,CAAC;AAEb,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;;;AC1LO,SAAS,cAA4B;AAC1C,QAAM,EAAE,KAAK,IAAI,QAAQ;AAEzB,QAAM,OAAO,MAAM;AAEnB,SAAO;AAAA,IACL;AAAA,IACA,SAAS,SAAS;AAAA,IAClB,YAAY,SAAS;AAAA,IACrB,eAAe,SAAS;AAAA,IACxB,eAAe,SAAS;AAAA;AAAA,IAGxB,gBAAgB,SAAS,WAAW,SAAS,cAAc,SAAS;AAAA,IACpE,mBAAmB,SAAS,WAAW,SAAS,cAAc,SAAS;AAAA,IACvE,qBAAqB,SAAS,WAAW,SAAS;AAAA,IAClD,kBAAkB,SAAS,WAAW,SAAS;AAAA,IAC/C,wBAAwB,SAAS,WAAW,SAAS;AAAA,IACrD,gBAAgB,SAAS,WAAW,SAAS;AAAA,IAC7C,eAAe,SAAS,WAAW,SAAS;AAAA,EAC9C;AACF;AAMO,SAAS,uBAAgC;AAC9C,QAAM,EAAE,kBAAkB,IAAI,YAAY;AAC1C,SAAO;AACT;AAEO,SAAS,yBAAkC;AAChD,QAAM,EAAE,oBAAoB,IAAI,YAAY;AAC5C,SAAO;AACT;AAEO,SAAS,oBAA6B;AAC3C,QAAM,EAAE,eAAe,IAAI,YAAY;AACvC,SAAO;AACT;AAEO,SAAS,sBAA+B;AAC7C,QAAM,EAAE,iBAAiB,IAAI,YAAY;AACzC,SAAO;AACT;AAEO,SAAS,4BAAqC;AACnD,QAAM,EAAE,uBAAuB,IAAI,YAAY;AAC/C,SAAO;AACT;AAEO,SAAS,oBAA6B;AAC3C,QAAM,EAAE,eAAe,IAAI,YAAY;AACvC,SAAO;AACT;AAEO,SAAS,mBAA4B;AAC1C,QAAM,EAAE,cAAc,IAAI,YAAY;AACtC,SAAO;AACT;;;ACjFA,IAAAC,iBAA4C;AAC5C,IAAAC,iBAAyB;AAyClB,SAAS,aAAa,SAAkD;AAC7E,QAAM,EAAE,SAAS,UAAU,MAAM,iBAAiB,MAAM,aAAa,IAAI,IAAI;AAE7E,QAAM,CAAC,MAAM,OAAO,QAAI,yBAAmC,IAAI;AAC/D,QAAM,CAAC,SAAS,UAAU,QAAI,yBAAS,IAAI;AAC3C,QAAM,CAAC,OAAO,QAAQ,QAAI,yBAAuB,IAAI;AACrD,QAAM,yBAAqB,uBAA+B,IAAI;AAC9D,QAAM,wBAAoB,uBAAO,CAAC;AAGlC,QAAM,UAAU,MAAM;AACpB,sBAAkB,WAAW;AAAA,EAC/B;AAEA,gCAAU,MAAM;AACd,QAAI,CAAC;AAAS;AAGd,QAAI,mBAAmB,SAAS;AAC9B,yBAAmB,QAAQ,MAAM;AAAA,IACnC;AACA,uBAAmB,UAAU,IAAI,gBAAgB;AAEjD,UAAM,YAAY,YAAY;AAC5B,UAAI;AACF,mBAAW,IAAI;AACf,iBAAS,IAAI;AAEb,gBAAQ,IAAI,kDAA2C,OAAO;AAE9D,cAAM,WAAW,MAAM,wBAAS,YAAY,OAAO;AAGnD,YAAI,mBAAmB,SAAS,OAAO,SAAS;AAC9C;AAAA,QACF;AAEA,YAAI,SAAS,WAAW,SAAS,MAAM;AAErC,gBAAM,UAAU,SAAS;AAGzB,cAAI,MAAM,QAAQ,OAAO,GAAG;AAE1B,kBAAM,aAAc,SAAiB,cAAc,CAAC;AACpD,kBAAM,YAAY;AAClB,kBAAM,QAAQ,WAAW,SAAS,QAAQ;AAC1C,kBAAM,QAAQ,WAAW,SAAS,QAAQ,SAAS;AACnD,kBAAM,cAAc,WAAW,QAAQ,QAAQ,QAAQ;AACvD,kBAAM,aAAa,KAAK,KAAK,QAAQ,KAAK;AAC1C,kBAAM,UAAU,WAAW,YAAY,SAAY,WAAW,UAAU,cAAc;AAEtF,oBAAQ;AAAA,cACN,OAAO;AAAA,cACP;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH,OAAO;AAEL,kBAAM,YAAY,QAAQ,SAAS,CAAC;AACpC,kBAAM,QAAQ,QAAQ,SAAS;AAC/B,kBAAM,QAAQ,QAAQ,SAAS,QAAQ,SAAS;AAChD,kBAAM,cAAc,QAAQ,QAAQ,QAAQ,QAAQ;AACpD,kBAAM,aAAa,QAAQ,cAAc,KAAK,KAAK,QAAQ,KAAK;AAChE,kBAAM,UAAU,QAAQ,YAAY,SAAY,QAAQ,UAAU,cAAc;AAEhF,oBAAQ;AAAA,cACN,OAAO;AAAA,cACP;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF,OAAO;AACL,gBAAM,IAAI,MAAM,uBAAuB;AAAA,QACzC;AAAA,MACF,SAAS,KAAK;AACZ,YAAK,IAAc,SAAS,cAAc;AACxC,kBAAQ,MAAM,iDAA0C,GAAG;AAC3D,mBAAS,GAAY;AAAA,QACvB;AAAA,MACF,UAAE;AACA,YAAI,CAAC,mBAAmB,SAAS,OAAO,SAAS;AAC/C,qBAAW,KAAK;AAAA,QAClB;AAAA,MACF;AAAA,IACF;AAGA,QAAI,mBAAmB,QAAQ,UAAU,QAAQ,IAAI;AACnD,cAAQ,IAAI,iDAA0C;AACtD,YAAM,QAAQ,WAAW,WAAW,UAAU;AAC9C,aAAO,MAAM;AACX,qBAAa,KAAK;AAClB,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF,OAAO;AAEL,gBAAU;AACV,aAAO,MAAM;AACX,2BAAmB,SAAS,MAAM;AAAA,MACpC;AAAA,IACF;AAAA,EACF,GAAG;AAAA,IACD;AAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB;AAAA,EACpB,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;","names":["import_react","import_utils","import_react","import_react","isActive","isExpired","isTrial","error","action","import_react","import_utils","import_react","import_utils","import_react","import_utils","import_react","import_utils","import_react","import_utils","import_react","import_react","import_react","import_utils","import_react","error","import_react","import_react","import_utils","import_ui","import_react","import_utils"]}