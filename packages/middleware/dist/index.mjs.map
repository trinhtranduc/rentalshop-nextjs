{"version":3,"sources":["../src/audit/audit.ts","../src/audit/audit-context.ts","../src/rate-limit/rate-limit.ts","../src/auth/auth.ts","../../constants/src/validation.ts","../../constants/src/environment.ts","../../constants/src/api.ts","../../constants/src/currency.ts","../src/subscription-manager.ts","../src/subscription-middleware.ts"],"sourcesContent":["/**\n * Audit Middleware for Next.js API Routes\n * \n * This middleware automatically logs API requests and responses for audit purposes.\n * It can be applied to individual routes or globally.\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { getAuditLogger, extractAuditContext, AuditContext } from '@rentalshop/database';\nimport { prisma } from '@rentalshop/database';\nimport { verifyTokenSimple } from '@rentalshop/auth';\n\n// Audit middleware configuration\nexport interface AuditMiddlewareConfig {\n  // Which HTTP methods to audit\n  methods?: string[];\n  // Which routes to audit (regex patterns)\n  includeRoutes?: RegExp[];\n  // Which routes to exclude (regex patterns)\n  excludeRoutes?: RegExp[];\n  // Whether to log request/response bodies\n  logBodies?: boolean;\n  // Maximum body size to log (in bytes)\n  maxBodySize?: number;\n  // Whether to log successful operations\n  logSuccess?: boolean;\n  // Whether to log failed operations\n  logErrors?: boolean;\n  // Custom severity mapping\n  severityMap?: Record<number, 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL'>;\n}\n\n// Default configuration\nconst defaultConfig: AuditMiddlewareConfig = {\n  methods: ['POST', 'PUT', 'PATCH', 'DELETE'],\n  includeRoutes: [/^\\/api\\//],\n  excludeRoutes: [/^\\/api\\/health/, /^\\/api\\/docs/],\n  logBodies: false,\n  maxBodySize: 1024, // 1KB\n  logSuccess: true,\n  logErrors: true,\n  severityMap: {\n    200: 'INFO',\n    201: 'INFO',\n    400: 'WARNING',\n    401: 'WARNING',\n    403: 'WARNING',\n    404: 'INFO',\n    500: 'ERROR',\n    502: 'ERROR',\n    503: 'ERROR'\n  }\n};\n\n// Audit middleware function\nexport function createAuditMiddleware(config: AuditMiddlewareConfig = {}) {\n  const finalConfig = { ...defaultConfig, ...config };\n  const auditLogger = getAuditLogger(prisma);\n\n  return async function auditMiddleware(\n    request: NextRequest,\n    next: () => Promise<NextResponse>\n  ): Promise<NextResponse> {\n    const startTime = Date.now();\n    let response: NextResponse;\n    let user: any = null;\n    let requestBody: any = null;\n    let responseBody: any = null;\n\n    try {\n      // Check if this request should be audited\n      if (!shouldAuditRequest(request, finalConfig)) {\n        return await next();\n      }\n\n      // Extract user information from token\n      try {\n        const token = request.headers.get('authorization')?.replace('Bearer ', '');\n        if (token) {\n          user = await verifyTokenSimple(token);\n        }\n      } catch (error) {\n        // Ignore auth errors for audit purposes\n      }\n\n      // Extract request body if needed\n      if (finalConfig.logBodies && request.body) {\n        try {\n          const clonedRequest = request.clone();\n          const body = await clonedRequest.text();\n          if (body.length <= finalConfig.maxBodySize!) {\n            requestBody = JSON.parse(body);\n          }\n        } catch (error) {\n          // Ignore body parsing errors\n        }\n      }\n\n      // Execute the actual request\n      response = await next();\n\n      // Extract response body if needed\n      if (finalConfig.logBodies && response.body) {\n        try {\n          const clonedResponse = response.clone();\n          const body = await clonedResponse.text();\n          if (body.length <= finalConfig.maxBodySize!) {\n            responseBody = JSON.parse(body);\n          }\n        } catch (error) {\n          // Ignore body parsing errors\n        }\n      }\n\n      // Log the audit event\n      await logAuditEventInternal(\n        request,\n        response,\n        user,\n        requestBody,\n        responseBody,\n        Date.now() - startTime,\n        finalConfig,\n        auditLogger\n      );\n\n      return response;\n\n    } catch (error) {\n      // Log error events\n      if (finalConfig.logErrors) {\n        await logErrorEvent(\n          request,\n          error,\n          user,\n          requestBody,\n          Date.now() - startTime,\n          finalConfig,\n          auditLogger\n        );\n      }\n      throw error;\n    }\n  };\n}\n\n// Check if request should be audited\nfunction shouldAuditRequest(request: NextRequest, config: AuditMiddlewareConfig): boolean {\n  const method = request.method;\n  const pathname = request.nextUrl.pathname;\n\n  // Check method\n  if (config.methods && !config.methods.includes(method)) {\n    return false;\n  }\n\n  // Check include routes\n  if (config.includeRoutes) {\n    const shouldInclude = config.includeRoutes.some(pattern => pattern.test(pathname));\n    if (!shouldInclude) {\n      return false;\n    }\n  }\n\n  // Check exclude routes\n  if (config.excludeRoutes) {\n    const shouldExclude = config.excludeRoutes.some(pattern => pattern.test(pathname));\n    if (shouldExclude) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// Log successful audit events\nasync function logAuditEventInternal(\n  request: NextRequest,\n  response: NextResponse,\n  user: any,\n  requestBody: any,\n  responseBody: any,\n  duration: number,\n  config: AuditMiddlewareConfig,\n  auditLogger: any\n) {\n  if (!config.logSuccess) return;\n\n  const status = response.status;\n  const severity = config.severityMap?.[status] || 'INFO';\n  \n  // Determine entity type and action from the request\n  const { entityType, action, entityId } = extractEntityInfo(request, requestBody);\n  \n  const context = extractAuditContext(request, user);\n  context.metadata = {\n    ...context.metadata,\n    duration,\n    status,\n    requestBody: config.logBodies ? requestBody : undefined,\n    responseBody: config.logBodies ? responseBody : undefined\n  };\n\n  await auditLogger.log({\n    action,\n    entityType,\n    entityId,\n    entityName: extractEntityName(request, requestBody, responseBody),\n    newValues: config.logBodies ? requestBody : undefined,\n    severity,\n    category: getCategoryFromPath(request.nextUrl.pathname),\n    description: `${request.method} ${request.nextUrl.pathname} - ${status}`,\n    context\n  });\n}\n\n// Log error events\nasync function logErrorEvent(\n  request: NextRequest,\n  error: any,\n  user: any,\n  requestBody: any,\n  duration: number,\n  config: AuditMiddlewareConfig,\n  auditLogger: any\n) {\n  const { entityType, action, entityId } = extractEntityInfo(request, requestBody);\n  \n  const context = extractAuditContext(request, user);\n  context.metadata = {\n    ...context.metadata,\n    duration,\n    error: error.message,\n    requestBody: config.logBodies ? requestBody : undefined\n  };\n\n  await auditLogger.log({\n    action,\n    entityType,\n    entityId,\n    entityName: extractEntityName(request, requestBody),\n    severity: 'ERROR',\n    category: 'SYSTEM',\n    description: `Error in ${request.method} ${request.nextUrl.pathname}: ${error.message}`,\n    context\n  });\n}\n\n// Extract entity information from request\nfunction extractEntityInfo(request: NextRequest, requestBody: any): {\n  entityType: string;\n  action: string;\n  entityId: string;\n} {\n  const pathname = request.nextUrl.pathname;\n  const method = request.method;\n  \n  // Extract entity type from path\n  const pathParts = pathname.split('/').filter(Boolean);\n  let entityType = 'Unknown';\n  let entityId = 'unknown';\n  \n  if (pathParts.length >= 2) {\n    entityType = pathParts[1].charAt(0).toUpperCase() + pathParts[1].slice(1);\n    \n    // Try to extract ID from path or body\n    if (pathParts.length >= 3) {\n      entityId = pathParts[2];\n    } else if (requestBody?.id) {\n      entityId = requestBody.id;\n    } else if (requestBody?.id) {\n      entityId = requestBody.id;\n    }\n  }\n  \n  // Map HTTP method to action\n  const actionMap: Record<string, string> = {\n    'GET': 'VIEW',\n    'POST': 'CREATE',\n    'PUT': 'UPDATE',\n    'PATCH': 'UPDATE',\n    'DELETE': 'DELETE'\n  };\n  \n  const action = actionMap[method] || 'CUSTOM';\n  \n  return { entityType, action, entityId };\n}\n\n// Extract entity name from request/response\nfunction extractEntityName(request: NextRequest, requestBody: any, responseBody?: any): string {\n  // Try to get name from various sources\n  if (requestBody?.name) return requestBody.name;\n  if (requestBody?.email) return requestBody.email;\n  if (requestBody?.title) return requestBody.title;\n  if (responseBody?.data?.name) return responseBody.data.name;\n  if (responseBody?.data?.email) return responseBody.data.email;\n  \n  // Fallback to path-based name\n  const pathParts = request.nextUrl.pathname.split('/').filter(Boolean);\n  if (pathParts.length >= 2) {\n    return `${pathParts[1]} ${pathParts[2] || 'operation'}`;\n  }\n  \n  return 'Unknown entity';\n}\n\n// Get category from path\nfunction getCategoryFromPath(pathname: string): 'GENERAL' | 'SECURITY' | 'BUSINESS' | 'SYSTEM' {\n  if (pathname.includes('/auth/') || pathname.includes('/login') || pathname.includes('/logout')) {\n    return 'SECURITY';\n  }\n  if (pathname.includes('/settings/') || pathname.includes('/admin/')) {\n    return 'SYSTEM';\n  }\n  if (pathname.includes('/orders/') || pathname.includes('/products/') || pathname.includes('/customers/')) {\n    return 'BUSINESS';\n  }\n  return 'GENERAL';\n}\n\n// Higher-order function to wrap API route handlers with audit logging\nexport function withAuditLogging(\n  handler: (request: NextRequest) => Promise<NextResponse>,\n  config?: AuditMiddlewareConfig\n) {\n  const auditMiddleware = createAuditMiddleware(config);\n  \n  return async function(request: NextRequest): Promise<NextResponse> {\n    return auditMiddleware(request, () => handler(request));\n  };\n}\n\n// Utility function to manually log audit events in route handlers\nexport async function logAuditEvent(\n  action: string,\n  entityType: string,\n  entityId: string,\n  entityName: string,\n  oldValues: Record<string, any> | undefined,\n  newValues: Record<string, any> | undefined,\n  request: NextRequest,\n  user: any,\n  description?: string\n) {\n  const auditLogger = getAuditLogger(prisma);\n  const context = extractAuditContext(request, user);\n  \n  await auditLogger.log({\n    action: action as any,\n    entityType,\n    entityId,\n    entityName,\n    oldValues,\n    newValues,\n    description,\n    context\n  });\n}\n","/**\n * Audit Context Middleware\n * \n * This middleware captures request context (user, IP, session, etc.) \n * and makes it available for audit logging throughout the request lifecycle.\n */\n\nimport { NextRequest } from 'next/server';\nimport { verifyTokenSimple } from '@rentalshop/auth';\n\nexport interface AuditContext {\n  userId?: string;\n  userEmail?: string;\n  userRole?: string;\n  merchantId?: string;\n  outletId?: string;\n  ipAddress?: string;\n  userAgent?: string;\n  sessionId?: string;\n  requestId?: string;\n  metadata?: Record<string, any>;\n}\n\n// Global context store (in production, use Redis or similar)\nconst requestContexts = new Map<string, AuditContext>();\nlet currentContext: AuditContext | undefined;\n\nexport function generateRequestId(): string {\n  return `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\nexport async function captureAuditContext(request: NextRequest): Promise<AuditContext> {\n  const requestId = generateRequestId();\n  \n  // Extract basic request info\n  const ipAddress = request.headers.get('x-forwarded-for') || \n                   request.headers.get('x-real-ip') || \n                   '127.0.0.1';\n  const userAgent = request.headers.get('user-agent') || 'Unknown';\n  const sessionId = request.headers.get('x-session-id') || 'unknown';\n  \n  let context: AuditContext = {\n    ipAddress,\n    userAgent,\n    sessionId,\n    requestId,\n    metadata: {\n      method: request.method,\n      url: request.url,\n      timestamp: new Date().toISOString()\n    }\n  };\n\n  // Try to extract user information from token\n  try {\n    const token = request.headers.get('authorization')?.replace('Bearer ', '');\n    if (token) {\n      const user = await verifyTokenSimple(token);\n      if (user) {\n        context.userId = user.id;\n        context.userEmail = user.email || undefined;\n        context.userRole = user.role || undefined;\n        context.merchantId = user.merchantId;\n        context.outletId = user.outletId;\n      }\n    }\n  } catch (error) {\n    console.error('Error extracting user context for audit:', error);\n  }\n\n  // Store context for this request and set as current\n  requestContexts.set(requestId, context);\n  currentContext = context;\n  \n  return context;\n}\n\nexport function getAuditContext(): AuditContext | undefined {\n  return currentContext;\n}\n\nexport function getAuditContextById(requestId: string): AuditContext | undefined {\n  return requestContexts.get(requestId);\n}\n\nexport function clearAuditContext(requestId: string): void {\n  requestContexts.delete(requestId);\n  if (currentContext?.requestId === requestId) {\n    currentContext = undefined;\n  }\n}\n\n// Clean up old contexts periodically (in production, use a proper cleanup mechanism)\nsetInterval(() => {\n  const now = Date.now();\n  for (const [requestId, context] of requestContexts.entries()) {\n    const contextAge = now - parseInt(requestId.split('-')[1]);\n    if (contextAge > 300000) { // 5 minutes\n      requestContexts.delete(requestId);\n    }\n  }\n}, 60000); // Clean up every minute\n","import { NextRequest, NextResponse } from 'next/server';\n\ninterface RateLimitConfig {\n  windowMs: number; // Time window in milliseconds\n  maxRequests: number; // Maximum requests per window\n  keyGenerator?: (request: NextRequest) => string; // Function to generate unique keys\n}\n\ninterface RateLimitStore {\n  [key: string]: {\n    count: number;\n    resetTime: number;\n  };\n}\n\n// In-memory store for rate limiting (in production, use Redis or similar)\nconst rateLimitStore: RateLimitStore = {};\n\nexport const createRateLimiter = (config: RateLimitConfig) => {\n  const {\n    windowMs = 60000, // 1 minute default\n    maxRequests = 10, // 10 requests per minute default\n    keyGenerator = (req: NextRequest) => {\n      // Use IP address as default key\n      const forwarded = req.headers.get('x-forwarded-for');\n      const ip = forwarded ? forwarded.split(',')[0] : req.ip || 'unknown';\n      return `rate_limit:${ip}`;\n    }\n  } = config;\n\n  return (request: NextRequest): NextResponse | null => {\n    const key = keyGenerator(request);\n    const now = Date.now();\n    \n    // Get or create rate limit entry\n    if (!rateLimitStore[key] || now > rateLimitStore[key].resetTime) {\n      rateLimitStore[key] = {\n        count: 1,\n        resetTime: now + windowMs\n      };\n    } else {\n      rateLimitStore[key].count++;\n    }\n\n    // Check if limit exceeded\n    if (rateLimitStore[key].count > maxRequests) {\n      return NextResponse.json(\n        {\n          error: 'Too many requests',\n          message: `Rate limit exceeded. Maximum ${maxRequests} requests per ${windowMs / 1000} seconds.`,\n          retryAfter: Math.ceil((rateLimitStore[key].resetTime - now) / 1000)\n        },\n        {\n          status: 429,\n          headers: {\n            'Retry-After': Math.ceil((rateLimitStore[key].resetTime - now) / 1000).toString(),\n            'X-RateLimit-Limit': maxRequests.toString(),\n            'X-RateLimit-Remaining': '0',\n            'X-RateLimit-Reset': rateLimitStore[key].resetTime.toString()\n          }\n        }\n      );\n    }\n\n    // Return null to indicate the request should continue\n    // Rate limit headers will be added by the route handler if needed\n    return null;\n  };\n};\n\n// Pre-configured rate limiters for different use cases\nexport const searchRateLimiter = createRateLimiter({\n  windowMs: 30000, // 30 seconds\n  maxRequests: 20, // 20 requests per 30 seconds\n  keyGenerator: (req: NextRequest) => {\n    // Use IP + user agent for search endpoints\n    const forwarded = req.headers.get('x-forwarded-for');\n    const ip = forwarded ? forwarded.split(',')[0] : req.ip || 'unknown';\n    const userAgent = req.headers.get('user-agent') || 'unknown';\n    return `search_rate_limit:${ip}:${userAgent}`;\n  }\n});\n\nexport const apiRateLimiter = createRateLimiter({\n  windowMs: 60000, // 1 minute\n  maxRequests: 100, // 100 requests per minute\n});\n\n// Clean up old entries periodically (every 5 minutes)\nsetInterval(() => {\n  const now = Date.now();\n  Object.keys(rateLimitStore).forEach(key => {\n    if (now > rateLimitStore[key].resetTime) {\n      delete rateLimitStore[key];\n    }\n  });\n}, 5 * 60 * 1000);\n","/**\n * Authentication Middleware for Next.js API Routes\n * \n * This middleware provides authentication and authorization utilities\n * for API routes with role-based access control.\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { verifyTokenSimple, assertAnyRole, getUserScope } from '@rentalshop/auth';\nimport {API} from '@rentalshop/constants';\n\nexport interface AuthMiddlewareConfig {\n  // Required roles for access\n  requiredRoles?: string[];\n  // Whether to allow unauthenticated access\n  allowUnauthenticated?: boolean;\n  // Custom authorization function\n  customAuth?: (user: any, request: NextRequest) => boolean;\n}\n\n/**\n * Create authentication middleware\n */\nexport function createAuthMiddleware(config: AuthMiddlewareConfig = {}) {\n  const {\n    requiredRoles = [],\n    allowUnauthenticated = false,\n    customAuth\n  } = config;\n\n  return async function authMiddleware(\n    request: NextRequest,\n    next: () => Promise<NextResponse>\n  ): Promise<NextResponse> {\n    try {\n      // Extract token from request\n      const token = request.headers.get('authorization')?.replace('Bearer ', '');\n      \n      if (!token) {\n        if (allowUnauthenticated) {\n          return await next();\n        }\n        return NextResponse.json(\n          { success: false, message: 'Access token required' },\n          { status: 401 }\n        );\n      }\n\n      // Verify token\n      const user = await verifyTokenSimple(token);\n      if (!user) {\n        return NextResponse.json(\n          { success: false, message: 'Invalid or expired token' },\n          { status: 401 }\n        );\n      }\n\n      // Check role-based authorization\n      if (requiredRoles.length > 0) {\n        try {\n          assertAnyRole(user as any, requiredRoles as any);\n        } catch {\n          return NextResponse.json(\n            { success: false, message: 'Insufficient permissions' },\n            { status: API.STATUS.FORBIDDEN }\n          );\n        }\n      }\n\n      // Custom authorization check\n      if (customAuth && !customAuth(user, request)) {\n        return NextResponse.json(\n          { success: false, message: 'Access denied' },\n          { status: API.STATUS.FORBIDDEN }\n        );\n      }\n\n      // Add user to request headers for downstream handlers\n      const requestHeaders = new Headers(request.headers);\n      requestHeaders.set('x-user-id', user.id);\n      requestHeaders.set('x-user-email', user.email || '');\n      requestHeaders.set('x-user-role', user.role || '');\n      requestHeaders.set('x-user-merchant-id', user.merchantId?.toString() || '');\n      requestHeaders.set('x-user-outlet-id', user.outletId?.toString() || '');\n\n      // Continue with the request\n      return await next();\n\n    } catch (error) {\n      console.error('Auth middleware error:', error);\n      return NextResponse.json(\n        { success: false, message: 'Authentication failed' },\n        { status: API.STATUS.INTERNAL_SERVER_ERROR }\n      );\n    }\n  };\n}\n\n/**\n * Higher-order function to wrap API route handlers with authentication\n */\nexport function withAuth(\n  handler: (request: NextRequest) => Promise<NextResponse>,\n  config?: AuthMiddlewareConfig\n) {\n  const authMiddleware = createAuthMiddleware(config);\n  \n  return async function(request: NextRequest): Promise<NextResponse> {\n    return authMiddleware(request, () => handler(request));\n  };\n}\n\n/**\n * Utility function to extract user from request headers\n */\nexport function getUserFromRequest(request: NextRequest) {\n  const userId = request.headers.get('x-user-id');\n  const userEmail = request.headers.get('x-user-email');\n  const userRole = request.headers.get('x-user-role');\n  const merchantId = request.headers.get('x-user-merchant-id');\n  const outletId = request.headers.get('x-user-outlet-id');\n\n  if (!userId) return null;\n\n  return {\n    id: userId,\n    email: userEmail,\n    role: userRole,\n    merchantId: merchantId ? parseInt(merchantId) : undefined,\n    outletId: outletId ? parseInt(outletId) : undefined,\n  };\n}\n\n/**\n * Pre-configured auth middleware for different use cases\n */\nexport const adminAuth = createAuthMiddleware({\n  requiredRoles: ['ADMIN']\n});\n\nexport const merchantAuth = createAuthMiddleware({\n  requiredRoles: ['ADMIN', 'MERCHANT']\n});\n\nexport const outletAuth = createAuthMiddleware({\n  requiredRoles: ['ADMIN', 'MERCHANT', 'OUTLET_ADMIN', 'OUTLET_STAFF']\n});\n\nexport const optionalAuth = createAuthMiddleware({\n  allowUnauthenticated: true\n});\n","/**\n * Validation and Business Rule Constants\n * \n * These constants define validation rules and business logic limits\n */\n\nexport const VALIDATION = {\n  // Rental Rules\n  MIN_RENTAL_DAYS: 1,\n  MAX_RENTAL_DAYS: 365,\n  \n  // Stock and Inventory\n  LOW_STOCK_THRESHOLD: 2,\n  CRITICAL_STOCK_THRESHOLD: 0,\n  MAX_STOCK_QUANTITY: 9999,\n  \n  // User Input\n  MIN_PASSWORD_LENGTH: 8,\n  MAX_PASSWORD_LENGTH: 128,\n  MIN_NAME_LENGTH: 1,\n  MAX_NAME_LENGTH: 100,\n  MAX_PHONE_LENGTH: 20,\n  MAX_EMAIL_LENGTH: 255,\n  \n  // Order Rules\n  MIN_ORDER_AMOUNT: 0.01,\n  MAX_ORDER_AMOUNT: 999999.99,\n  MAX_ORDER_ITEMS: 50,\n  \n  // Financial\n  MIN_DEPOSIT_AMOUNT: 0,\n  MAX_DEPOSIT_AMOUNT: 99999.99,\n  MIN_DISCOUNT_AMOUNT: 0,\n  MAX_DISCOUNT_PERCENTAGE: 100,\n  \n  // File Uploads\n  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB\n  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/webp'],\n} as const;\n\n// Type for validation values\nexport type ValidationValue = typeof VALIDATION[keyof typeof VALIDATION];\n","/**\n * Environment-Specific Constants\n * \n * These constants can vary based on the environment (development, staging, production)\n */\n\nexport const ENVIRONMENT = {\n  // API Configuration\n  API_TIMEOUT: process.env.NODE_ENV === 'production' ? 10000 : 30000,\n  API_RETRY_ATTEMPTS: process.env.NODE_ENV === 'production' ? 3 : 1,\n  \n  // Search and Pagination (Production vs Development)\n  SEARCH_LIMIT: process.env.NODE_ENV === 'production' ? 50 : 20,\n  DASHBOARD_ITEMS: process.env.NODE_ENV === 'production' ? 20 : 10,\n  \n  // Caching\n  CACHE_TTL: process.env.NODE_ENV === 'production' ? 300 : 60, // seconds\n  CACHE_MAX_SIZE: process.env.NODE_ENV === 'production' ? 1000 : 100,\n  \n  // Logging\n  LOG_LEVEL: process.env.NODE_ENV === 'production' ? 'error' : 'debug',\n  LOG_RETENTION: process.env.NODE_ENV === 'production' ? 30 : 7, // days\n  \n  // Performance\n  DEBOUNCE_DELAY: process.env.NODE_ENV === 'production' ? 500 : 300,\n  THROTTLE_DELAY: process.env.NODE_ENV === 'production' ? 200 : 100,\n  \n  // Security\n  SESSION_TIMEOUT: process.env.NODE_ENV === 'production' ? 3600 : 7200, // seconds\n  MAX_LOGIN_ATTEMPTS: process.env.NODE_ENV === 'production' ? 5 : 10,\n  \n  // Feature Flags\n  ENABLE_ANALYTICS: process.env.NODE_ENV === 'production',\n  ENABLE_DEBUG_MODE: process.env.NODE_ENV !== 'production',\n  ENABLE_PERFORMANCE_MONITORING: process.env.NODE_ENV === 'production',\n} as const;\n\n// Type for environment values\nexport type EnvironmentValue = typeof ENVIRONMENT[keyof typeof ENVIRONMENT];\n","/**\n * API and Network Constants\n * \n * These constants define API behavior, endpoints, and network settings\n */\n\nexport const API = {\n  // HTTP Status Codes\n  STATUS: {\n    OK: 200,\n    CREATED: 201,\n    NO_CONTENT: 204,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402, // For subscription errors (expired, paused, etc.)\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    CONFLICT: 409,\n    UNPROCESSABLE_ENTITY: 422,\n    INTERNAL_SERVER_ERROR: 500,\n    SERVICE_UNAVAILABLE: 503,\n  },\n  \n  // HTTP Methods\n  METHODS: {\n    GET: 'GET',\n    POST: 'POST',\n    PUT: 'PUT',\n    PATCH: 'PATCH',\n    DELETE: 'DELETE',\n  },\n  \n  // Content Types\n  CONTENT_TYPES: {\n    JSON: 'application/json',\n    FORM_DATA: 'multipart/form-data',\n    TEXT: 'text/plain',\n    HTML: 'text/html',\n  },\n  \n  // Headers\n  HEADERS: {\n    AUTHORIZATION: 'Authorization',\n    CONTENT_TYPE: 'Content-Type',\n    ACCEPT: 'Accept',\n    USER_AGENT: 'User-Agent',\n    CACHE_CONTROL: 'Cache-Control',\n  },\n  \n  // Rate Limiting\n  RATE_LIMITS: {\n    REQUESTS_PER_MINUTE: 60,\n    REQUESTS_PER_HOUR: 1000,\n    BURST_LIMIT: 10,\n  },\n  \n  // Timeouts\n  TIMEOUTS: {\n    CONNECT: 5000,\n    READ: 30000,\n    WRITE: 30000,\n    IDLE: 60000,\n  },\n  \n  // Retry Configuration\n  RETRY: {\n    MAX_ATTEMPTS: 3,\n    INITIAL_DELAY: 1000,\n    MAX_DELAY: 10000,\n    BACKOFF_MULTIPLIER: 2,\n  },\n  \n  // Cache Headers\n  CACHE: {\n    NO_CACHE: 'no-cache',\n    NO_STORE: 'no-store',\n    MUST_REVALIDATE: 'must-revalidate',\n    PRIVATE: 'private',\n    PUBLIC: 'public',\n  },\n  \n  // Error Codes\n  ERROR_CODES: {\n    NETWORK_ERROR: 'NETWORK_ERROR',\n    TIMEOUT_ERROR: 'TIMEOUT_ERROR',\n    VALIDATION_ERROR: 'VALIDATION_ERROR',\n    AUTHENTICATION_ERROR: 'AUTHENTICATION_ERROR',\n    AUTHORIZATION_ERROR: 'AUTHORIZATION_ERROR',\n    SUBSCRIPTION_ERROR: 'SUBSCRIPTION_ERROR',\n    NOT_FOUND_ERROR: 'NOT_FOUND_ERROR',\n    CONFLICT_ERROR: 'CONFLICT_ERROR',\n    SERVER_ERROR: 'SERVER_ERROR',\n  },\n} as const;\n\n// Type for API values\nexport type ApiValue = typeof API[keyof typeof API];\n","/**\n * Currency Constants\n * \n * Centralized currency-related constants for the rental shop application.\n * Supports USD and VND currencies at the merchant level.\n */\n\n/**\n * Currency code type\n */\nexport type CurrencyCode = 'USD' | 'VND';\n\n/**\n * Supported currency codes\n */\nexport const SUPPORTED_CURRENCIES: readonly CurrencyCode[] = ['USD', 'VND'] as const;\n\n/**\n * Default currency for new merchants\n */\nexport const DEFAULT_CURRENCY: CurrencyCode = 'USD';\n\n/**\n * Currency symbols mapped to currency codes\n */\nexport const CURRENCY_SYMBOLS: Record<CurrencyCode, string> = {\n  USD: '$',\n  VND: 'đ',\n};\n\n/**\n * Currency names mapped to currency codes\n */\nexport const CURRENCY_NAMES: Record<CurrencyCode, string> = {\n  USD: 'US Dollar',\n  VND: 'Vietnamese Dong',\n};\n\n/**\n * Currency locales for formatting\n */\nexport const CURRENCY_LOCALES: Record<CurrencyCode, string> = {\n  USD: 'en-US',\n  VND: 'vi-VN',\n};\n\n/**\n * Currency decimal places\n */\nexport const CURRENCY_DECIMALS: Record<CurrencyCode, number> = {\n  USD: 2,\n  VND: 0,\n};\n\n/**\n * Symbol position (before or after amount)\n */\nexport const CURRENCY_SYMBOL_POSITION: Record<CurrencyCode, 'before' | 'after'> = {\n  USD: 'before',\n  VND: 'after',\n};\n\n/**\n * Exchange rates to USD (base currency)\n * Note: These are approximate rates for reference only\n * In production, fetch real-time rates from an API\n */\nexport const EXCHANGE_RATES: Record<CurrencyCode, number> = {\n  USD: 1,\n  VND: 24500,\n};\n\n/**\n * Currency configuration for easy access\n */\nexport interface CurrencyConfig {\n  code: CurrencyCode;\n  symbol: string;\n  name: string;\n  locale: string;\n  decimals: number;\n  symbolPosition: 'before' | 'after';\n  exchangeRate: number;\n}\n\n/**\n * Complete currency configurations\n */\nexport const CURRENCY_CONFIGS: Record<CurrencyCode, CurrencyConfig> = {\n  USD: {\n    code: 'USD',\n    symbol: CURRENCY_SYMBOLS.USD,\n    name: CURRENCY_NAMES.USD,\n    locale: CURRENCY_LOCALES.USD,\n    decimals: CURRENCY_DECIMALS.USD,\n    symbolPosition: CURRENCY_SYMBOL_POSITION.USD,\n    exchangeRate: EXCHANGE_RATES.USD,\n  },\n  VND: {\n    code: 'VND',\n    symbol: CURRENCY_SYMBOLS.VND,\n    name: CURRENCY_NAMES.VND,\n    locale: CURRENCY_LOCALES.VND,\n    decimals: CURRENCY_DECIMALS.VND,\n    symbolPosition: CURRENCY_SYMBOL_POSITION.VND,\n    exchangeRate: EXCHANGE_RATES.VND,\n  },\n};\n\n/**\n * Get currency configuration by code\n * @param code - Currency code\n * @returns Currency configuration\n */\nexport function getCurrencyConfig(code: CurrencyCode): CurrencyConfig {\n  return CURRENCY_CONFIGS[code];\n}\n\n/**\n * Check if a currency code is valid\n * @param code - Currency code to check\n * @returns True if valid, false otherwise\n */\nexport function isValidCurrency(code: string): code is CurrencyCode {\n  return SUPPORTED_CURRENCIES.includes(code as CurrencyCode);\n}\n\n/**\n * Get currency symbol\n * @param code - Currency code\n * @returns Currency symbol\n */\nexport function getCurrencySymbol(code: CurrencyCode): string {\n  return CURRENCY_SYMBOLS[code];\n}\n\n/**\n * Get currency name\n * @param code - Currency code\n * @returns Currency name\n */\nexport function getCurrencyName(code: CurrencyCode): string {\n  return CURRENCY_NAMES[code];\n}\n\n/**\n * Currency selection options for dropdowns\n */\nexport const CURRENCY_OPTIONS = SUPPORTED_CURRENCIES.map(code => ({\n  value: code,\n  label: `${CURRENCY_SYMBOLS[code]} ${code} - ${CURRENCY_NAMES[code]}`,\n  symbol: CURRENCY_SYMBOLS[code],\n  name: CURRENCY_NAMES[code],\n}));\n\n/**\n * Default currency settings\n */\nexport const DEFAULT_CURRENCY_SETTINGS = {\n  currentCurrency: DEFAULT_CURRENCY,\n  baseCurrency: DEFAULT_CURRENCY,\n  showSymbol: true,\n  showCode: false,\n};\n\n","// ============================================================================\n// UNIFIED SUBSCRIPTION MANAGEMENT MIDDLEWARE\n// ============================================================================\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { prisma } from '@rentalshop/database';\nimport { API } from '@rentalshop/constants';\nimport type { AuthUser } from '@rentalshop/types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface SubscriptionValidationResult {\n  isValid: boolean;\n  error?: string;\n  statusCode?: number;\n  subscription?: any;\n  merchant?: any;\n  isExpired?: boolean;\n  needsStatusUpdate?: boolean;\n}\n\nexport interface SubscriptionValidationOptions {\n  requireActiveSubscription?: boolean;\n  allowedStatuses?: string[];\n  checkMerchantStatus?: boolean;\n  checkSubscriptionStatus?: boolean;\n  autoUpdateExpired?: boolean; // New: Auto-update expired subscriptions\n}\n\nexport interface SubscriptionManagerConfig {\n  checkInterval: number; // Check interval in milliseconds\n  gracePeriod: number;   // Grace period in days before marking as expired\n  autoMarkExpired: boolean; // Whether to automatically mark expired subscriptions\n}\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst DEFAULT_CONFIG: SubscriptionManagerConfig = {\n  checkInterval: 60 * 60 * 1000, // 1 hour\n  gracePeriod: 0, // No grace period\n  autoMarkExpired: true\n};\n\n// ============================================================================\n// GLOBAL STATE\n// ============================================================================\n\nlet lastExpiryCheckTime = 0;\nlet isCheckingExpiry = false;\n\n// ============================================================================\n// CORE SUBSCRIPTION VALIDATION\n// ============================================================================\n\n/**\n * Unified subscription validation with automatic expiry checking\n * This replaces both subscription-validation.ts and subscription-expiry.ts\n */\nexport async function validateSubscriptionAccess(\n  user: AuthUser,\n  options: SubscriptionValidationOptions = {}\n): Promise<SubscriptionValidationResult> {\n  const {\n    requireActiveSubscription = true,\n    allowedStatuses = ['active'],\n    checkMerchantStatus = true,\n    checkSubscriptionStatus = true,\n    autoUpdateExpired = true\n  } = options;\n\n  try {\n    // Get merchant information with subscription\n    const merchant = await prisma.merchant.findUnique({\n      where: { id: user.merchantId },\n      select: {\n        id: true,\n        name: true,\n        email: true,\n        subscriptionStatus: true,\n        subscription: {\n          include: {\n            plan: true\n          }\n        }\n      }\n    });\n\n    if (!merchant) {\n      return {\n        isValid: false,\n        error: 'Merchant not found',\n        statusCode: API.STATUS.NOT_FOUND\n      };\n    }\n\n    // Check merchant subscription status\n    if (checkMerchantStatus) {\n      const merchantStatus = merchant.subscriptionStatus?.toLowerCase();\n      if (merchantStatus && !allowedStatuses.includes(merchantStatus)) {\n        return {\n          isValid: false,\n          error: `Merchant subscription is ${merchantStatus}. Access denied.`,\n          statusCode: API.STATUS.FORBIDDEN,\n          merchant\n        };\n      }\n    }\n\n    // Check active subscription\n    if (checkSubscriptionStatus && requireActiveSubscription) {\n      const subscription = merchant.subscription;\n      \n      if (!subscription) {\n        return {\n          isValid: false,\n          error: 'No active subscription found. Please subscribe to a plan.',\n          statusCode: API.STATUS.FORBIDDEN,\n          merchant\n        };\n      }\n\n      // Check if subscription is expired (real-time check)\n      const now = new Date();\n      const isExpired = subscription.currentPeriodEnd && new Date(subscription.currentPeriodEnd) < now;\n      \n      if (isExpired && autoUpdateExpired) {\n        // Auto-update expired subscription status\n        try {\n          await prisma.subscription.update({\n            where: { id: subscription.id },\n            data: { \n              status: 'expired',\n              updatedAt: now\n            }\n          });\n          \n          console.log(`🔄 Auto-updated expired subscription ${subscription.id}`);\n          \n          // Update the subscription object for response\n          subscription.status = 'expired';\n        } catch (error) {\n          console.error(`❌ Failed to update expired subscription ${subscription.id}:`, error);\n        }\n      }\n\n      const subscriptionStatus = subscription.status?.toLowerCase();\n      \n      // Check if subscription is expired (after potential update)\n      if (isExpired) {\n        return {\n          isValid: false,\n          error: 'Subscription has expired. Please renew to continue.',\n          statusCode: API.STATUS.FORBIDDEN,\n          subscription,\n          merchant,\n          isExpired: true,\n          needsStatusUpdate: true\n        };\n      }\n\n      if (!allowedStatuses.includes(subscriptionStatus)) {\n        return {\n          isValid: false,\n          error: `Subscription is ${subscriptionStatus}. Access denied.`,\n          statusCode: API.STATUS.FORBIDDEN,\n          subscription,\n          merchant\n        };\n      }\n    }\n\n    return {\n      isValid: true,\n      subscription: merchant.subscription,\n      merchant\n    };\n\n  } catch (error) {\n    console.error('Subscription validation error:', error);\n    return {\n      isValid: false,\n      error: 'Failed to validate subscription',\n      statusCode: API.STATUS.INTERNAL_SERVER_ERROR\n    };\n  }\n}\n\n// ============================================================================\n// BACKGROUND EXPIRY CHECKING\n// ============================================================================\n\n/**\n * Background expiry check (runs periodically)\n * This replaces the separate expiry checking logic\n */\nexport async function checkSubscriptionExpiry(config: SubscriptionManagerConfig = DEFAULT_CONFIG) {\n  // Prevent concurrent checks\n  if (isCheckingExpiry) {\n    return;\n  }\n\n  const now = Date.now();\n  if (now - lastExpiryCheckTime < config.checkInterval) {\n    return;\n  }\n\n  try {\n    isCheckingExpiry = true;\n    lastExpiryCheckTime = now;\n\n    console.log('🔍 Running background subscription expiry check...');\n\n    // Find subscriptions that should be expired\n    const expiredSubscriptions = await prisma.subscription.findMany({\n      where: {\n        status: { in: ['active', 'paused'] },\n        currentPeriodEnd: { lt: new Date() }\n      },\n      include: {\n        merchant: {\n          select: {\n            id: true,\n            name: true,\n            email: true\n          }\n        }\n      }\n    });\n\n    if (expiredSubscriptions.length === 0) {\n      console.log('✅ No expired subscriptions found');\n      return;\n    }\n\n    console.log(`⚠️ Found ${expiredSubscriptions.length} expired subscriptions`);\n\n    // Process each expired subscription\n    for (const subscription of expiredSubscriptions) {\n      try {\n        if (config.autoMarkExpired) {\n          // Mark as expired\n          await prisma.subscription.update({\n            where: { id: subscription.id },\n            data: { \n              status: 'expired',\n              updatedAt: new Date()\n            }\n          });\n          \n          console.log(`✅ Marked subscription ${subscription.id} as expired`);\n          \n          // TODO: Send notifications\n          // await sendExpiryNotification(subscription);\n          // await sendAdminNotification(subscription);\n        }\n      } catch (error) {\n        console.error(`❌ Error processing expired subscription ${subscription.id}:`, error);\n      }\n    }\n\n    console.log('✅ Background expiry check completed');\n  } catch (error) {\n    console.error('❌ Error in background expiry check:', error);\n  } finally {\n    isCheckingExpiry = false;\n  }\n}\n\n// ============================================================================\n// MIDDLEWARE WRAPPER\n// ============================================================================\n\n/**\n * Middleware wrapper for API routes that require subscription validation\n */\nexport function withSubscriptionValidation(\n  handler: (request: NextRequest, context: any, validation: SubscriptionValidationResult) => Promise<NextResponse>,\n  options: SubscriptionValidationOptions = {}\n) {\n  return async (request: NextRequest, context: any) => {\n    try {\n      // Get user from request (assuming it's already authenticated)\n      const user = (request as any).user as AuthUser;\n      \n      if (!user) {\n        return NextResponse.json(\n          { success: false, message: 'Authentication required' },\n          { status: API.STATUS.UNAUTHORIZED }\n        );\n      }\n\n      // Validate subscription access (includes auto-expiry checking)\n      const validation = await validateSubscriptionAccess(user, options);\n      \n      if (!validation.isValid) {\n        return NextResponse.json(\n          { \n            success: false, \n            message: validation.error,\n            error: 'SUBSCRIPTION_ERROR',\n            subscriptionStatus: validation.subscription?.status,\n            merchantStatus: validation.merchant?.subscriptionStatus,\n            isExpired: validation.isExpired,\n            needsStatusUpdate: validation.needsStatusUpdate\n          },\n          { status: validation.statusCode || API.STATUS.FORBIDDEN }\n        );\n      }\n\n      // Call the original handler with validation result\n      return await handler(request, context, validation);\n\n    } catch (error) {\n      console.error('Subscription validation middleware error:', error);\n      return NextResponse.json(\n        { success: false, message: 'Internal server error' },\n        { status: API.STATUS.INTERNAL_SERVER_ERROR }\n      );\n    }\n  };\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Check if subscription status allows specific operations\n */\nexport function canPerformOperation(\n  subscriptionStatus: string,\n  operation: 'create' | 'read' | 'update' | 'delete' | 'admin'\n): boolean {\n  const status = subscriptionStatus.toLowerCase();\n  \n  switch (status) {\n    case 'active':\n      return true; // All operations allowed\n    case 'paused':\n      return ['read'].includes(operation); // Only read operations\n    case 'expired':\n    case 'cancelled':\n    case 'past_due':\n      return false; // No operations allowed\n    default:\n      return false;\n  }\n}\n\n/**\n * Get subscription error message for frontend display\n */\nexport function getSubscriptionErrorMessage(\n  subscriptionStatus: string,\n  merchantStatus?: string\n): string {\n  const status = subscriptionStatus.toLowerCase();\n  const merchant = merchantStatus?.toLowerCase();\n\n  if (merchant && !['active'].includes(merchant)) {\n    return `Merchant account is ${merchant}. Please contact support.`;\n  }\n\n  switch (status) {\n    case 'paused':\n      return 'Your subscription is paused. Some features may be limited.';\n    case 'expired':\n      return 'Your subscription has expired. Please renew to continue.';\n    case 'cancelled':\n      return 'Your subscription has been cancelled. Please choose a new plan.';\n    case 'past_due':\n      return 'Payment is past due. Please update your payment method.';\n    default:\n      return 'Subscription status error. Please contact support.';\n  }\n}\n\n/**\n * Get allowed operations for current subscription status\n */\nexport function getAllowedOperations(subscriptionStatus: string): string[] {\n  const status = subscriptionStatus.toLowerCase();\n  \n  switch (status) {\n    case 'active':\n      return ['create', 'read', 'update', 'delete', 'admin'];\n    case 'paused':\n      return ['read'];\n    case 'expired':\n    case 'cancelled':\n    case 'past_due':\n      return [];\n    default:\n      return [];\n  }\n}\n\n/**\n * Manual expiry check (for admin use)\n */\nexport async function manualExpiryCheck() {\n  try {\n    console.log('🔍 Running manual subscription expiry check...');\n    \n    const expiredSubscriptions = await prisma.subscription.findMany({\n      where: {\n        status: { in: ['active', 'paused'] },\n        currentPeriodEnd: { lt: new Date() }\n      }\n    });\n    \n    const results = {\n      totalChecked: expiredSubscriptions.length,\n      expiredFound: 0,\n      markedAsExpired: 0,\n      errors: [] as string[]\n    };\n\n    for (const subscription of expiredSubscriptions) {\n      try {\n        results.expiredFound++;\n        \n        // Mark as expired\n        await prisma.subscription.update({\n          where: { id: subscription.id },\n          data: { \n            status: 'expired',\n            updatedAt: new Date()\n          }\n        });\n        \n        results.markedAsExpired++;\n        console.log(`✅ Marked subscription ${subscription.id} as expired`);\n      } catch (error) {\n        const errorMsg = `Failed to mark subscription ${subscription.id} as expired: ${error}`;\n        results.errors.push(errorMsg);\n        console.error(`❌ ${errorMsg}`);\n      }\n    }\n\n    console.log('✅ Manual expiry check completed:', results);\n    return results;\n  } catch (error) {\n    console.error('❌ Manual expiry check failed:', error);\n    throw error;\n  }\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport default {\n  validateSubscriptionAccess,\n  checkSubscriptionExpiry,\n  withSubscriptionValidation,\n  canPerformOperation,\n  getSubscriptionErrorMessage,\n  getAllowedOperations,\n  manualExpiryCheck,\n  DEFAULT_CONFIG\n};\n","// ============================================================================\n// SUBSCRIPTION MIDDLEWARE FOR API ROUTES\n// ============================================================================\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport { validateSubscriptionAccess } from '@rentalshop/utils';\nimport { API } from '@rentalshop/constants';\nimport type { AuthUser } from '@rentalshop/types';\n\n// ============================================================================\n// ROUTE CONFIGURATION\n// ============================================================================\n\n// Routes that require subscription validation\nexport const subscriptionRequiredRoutes = [\n  '/api/orders',\n  '/api/products', \n  '/api/customers',\n  '/api/payments',\n  '/api/notifications',\n  '/api/settings'\n];\n\n// Routes that don't require subscription validation (admin/system routes)\nexport const subscriptionExemptRoutes = [\n  '/api/auth',\n  '/api/health',\n  '/api/system',\n  '/api/plans',\n  '/api/subscriptions',\n  '/api/users' // User management doesn't require subscription\n];\n\n// ============================================================================\n// SUBSCRIPTION VALIDATION FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a route requires subscription validation\n */\nexport function requiresSubscriptionValidation(pathname: string): boolean {\n  const requiresSubscription = subscriptionRequiredRoutes.some(route => pathname.startsWith(route));\n  const isSubscriptionExempt = subscriptionExemptRoutes.some(route => pathname.startsWith(route));\n  \n  return requiresSubscription && !isSubscriptionExempt;\n}\n\n/**\n * Validate subscription access for API routes\n * This function should be called at the beginning of each protected API route\n */\nexport async function validateSubscriptionForRoute(\n  user: AuthUser,\n  pathname: string\n): Promise<{ isValid: boolean; response?: NextResponse }> {\n  // Check if this route requires subscription validation\n  if (!requiresSubscriptionValidation(pathname)) {\n    return { isValid: true };\n  }\n\n  console.log('🔍 SUBSCRIPTION MIDDLEWARE: Validating subscription for:', pathname);\n  console.log('🔍 SUBSCRIPTION MIDDLEWARE: User:', {\n    id: user.id,\n    email: user.email,\n    role: user.role,\n    merchantId: user.merchantId\n  });\n\n  try {\n    // Validate subscription access\n    const subscriptionResult = await validateSubscriptionAccess(user, {\n      requireActiveSubscription: true,\n      allowedStatuses: ['active'],\n      checkMerchantStatus: true,\n      checkSubscriptionStatus: true,\n      autoUpdateExpired: true\n    });\n\n    if (!subscriptionResult.isValid) {\n      console.log('🔍 SUBSCRIPTION MIDDLEWARE: Validation failed:', subscriptionResult.error);\n      \n      const errorResponse = NextResponse.json(\n        { \n          success: false, \n          message: subscriptionResult.error,\n          error: 'SUBSCRIPTION_ERROR',\n          subscriptionStatus: subscriptionResult.subscription?.status,\n          merchantStatus: subscriptionResult.merchant?.subscriptionStatus,\n          isExpired: subscriptionResult.isExpired,\n          needsStatusUpdate: subscriptionResult.needsStatusUpdate\n        },\n        { status: subscriptionResult.statusCode || API.STATUS.FORBIDDEN }\n      );\n\n      return { isValid: false, response: errorResponse };\n    }\n\n    console.log('🔍 SUBSCRIPTION MIDDLEWARE: Validation passed');\n    return { isValid: true };\n\n  } catch (error) {\n    console.error('🔍 SUBSCRIPTION MIDDLEWARE: Validation error:', error);\n    \n    const errorResponse = NextResponse.json(\n      { \n        success: false, \n        message: 'Failed to validate subscription',\n        error: 'SUBSCRIPTION_VALIDATION_ERROR'\n      },\n      { status: API.STATUS.INTERNAL_SERVER_ERROR }\n    );\n\n    return { isValid: false, response: errorResponse };\n  }\n}\n\n/**\n * Higher-order function to wrap API route handlers with subscription validation\n */\nexport function withSubscriptionValidation<T extends any[]>(\n  handler: (request: NextRequest, ...args: T) => Promise<NextResponse>\n) {\n  return async (request: NextRequest, ...args: T): Promise<NextResponse> => {\n    const pathname = request.nextUrl.pathname;\n    \n    // Check if subscription validation is required\n    if (!requiresSubscriptionValidation(pathname)) {\n      return handler(request, ...args);\n    }\n\n    // Get user from request headers (set by main middleware)\n    const userId = request.headers.get('x-user-id');\n    const userEmail = request.headers.get('x-user-email');\n    const userRole = request.headers.get('x-user-role');\n\n    if (!userId || !userEmail || !userRole) {\n      return NextResponse.json(\n        { success: false, message: 'User information not found in request' },\n        { status: API.STATUS.UNAUTHORIZED }\n      );\n    }\n\n    // Create minimal user object for validation\n    // Note: This is a simplified approach. In production, you might want to\n    // fetch full user data from database or include more fields in JWT\n    const user: AuthUser = {\n      id: parseInt(userId),\n      email: userEmail,\n      name: '', // Will be filled by subscription validation if needed\n      role: userRole as any,\n      merchantId: undefined, // Will be fetched during validation\n      outletId: undefined,\n      isActive: true,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    // Validate subscription\n    const validation = await validateSubscriptionForRoute(user, pathname);\n    if (!validation.isValid) {\n      return validation.response!;\n    }\n\n    // Call the original handler\n    return handler(request, ...args);\n  };\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport default {\n  requiresSubscriptionValidation,\n  validateSubscriptionForRoute,\n  withSubscriptionValidation,\n  subscriptionRequiredRoutes,\n  subscriptionExemptRoutes\n};\n"],"mappings":"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","names":["verifyTokenSimple","NextResponse","verifyTokenSimple","NextResponse","verifyTokenSimple","NextResponse","prisma","prisma","NextResponse","NextResponse","validateSubscriptionAccess","validateSubscriptionAccess","NextResponse","withSubscriptionValidation"]}